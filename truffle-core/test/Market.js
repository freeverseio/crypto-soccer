const BN = require('bn.js');
require('chai')
    .use(require('chai-as-promised'))
    .use(require('chai-bn')(BN))
    .should();
const truffleAssert = require('truffle-assertions');
const Market = artifacts.require("Market");
const Assets = artifacts.require('Assets');

// THE 2 MAIN API FUNCTIONS: signPutForSaleMTx & signAgreeToBuyPlayerMTx:
// - the 'rnd' number must be a random generated by the Seller's endpoint. It has 2 purposes:
// - ... i) distinguish different put-for-sale MTXs 
// - ... ii) hide the price of the sale when we communicate with the BC (only hashed-prices appear there, with 'rnd' acting as salt)
async function signPutForSaleMTx(currencyId, price, rnd, validUntil, asssetId, sellerAccount) {
  const hiddenPrice = concatHash(
      ['uint8', 'uint256', 'uint256'],
      [currencyId, price, rnd]
  )
  const sellerTxMsg = concatHash(
      ['bytes32', 'uint256', 'uint256'],
      [hiddenPrice, validUntil, asssetId]
  )
  const sigSeller = await sellerAccount.sign(sellerTxMsg);
  sigSeller.message.should.be.equal(sellerTxMsg);
  return sigSeller;
}

// Buyer explicitly agrees to all of sellers data, and only adds the 'buyerTeamId' to it.
async function signAgreeToBuyPlayerMTx(currencyId, price, extraPrice, sellerRnd, buyerRnd, validUntil, playerId, isOffer2StartAuction, buyerTeamId, buyerAccount) {
  const sellerHiddenPrice = concatHash(
    ['uint8', 'uint256', 'uint256'],
    [currencyId, price, sellerRnd]
  )
  const buyerHiddenPrice = concatHash(
    ['uint256', 'uint256'],
    [extraPrice, buyerRnd]
  )
  const sellerTxMsg = concatHash(
      ['bytes32', 'uint256', 'uint256'],
      [sellerHiddenPrice, validUntil, playerId]
  )
  const sellerTxHash = getMessageHash(sellerTxMsg);
  buyerTxMsg = concatHash(
      ['bytes32', 'bytes32', 'uint256', 'bool'],
      [sellerTxHash, buyerHiddenPrice, buyerTeamId, isOffer2StartAuction]
  )
  const sigBuyer = await buyerAccount.sign(buyerTxMsg);
  return sigBuyer;
}

// Buyer explicitly agrees to all of sellers data, and only adds the 'buyerTeamId' to it.
async function signAgreeToBuyTeamMTx(currencyId, price, extraPrice, sellerRnd, buyerRnd, validUntil, playerId, isOffer2StartAuction, buyerAccount) {
  const sellerHiddenPrice = concatHash(
    ['uint8', 'uint256', 'uint256'],
    [currencyId, price, sellerRnd]
  )
  const buyerHiddenPrice = concatHash(
    ['uint256', 'uint256'],
    [extraPrice, buyerRnd]
  )
  const sellerTxMsg = concatHash(
      ['bytes32', 'uint256', 'uint256'],
      [sellerHiddenPrice, validUntil, playerId]
  )
  const sellerTxHash = getMessageHash(sellerTxMsg);
  buyerTxMsg = concatHash(
      ['bytes32', 'bytes32', 'bool'],
      [sellerTxHash, buyerHiddenPrice, isOffer2StartAuction]
  )
  const sigBuyer = await buyerAccount.sign(buyerTxMsg);
  return sigBuyer;
}


function buildOfferToBuyPlayerMsg(currencyId, price, rnd, validUntil, playerId, buyerTeamId) {
  const privHash = concatHash(
      ['uint8', 'uint256', 'uint256'],
      [currencyId, price, rnd]
  )
  const buyerTxMsg = concatHash(
      ['bytes32', 'uint256', 'uint256', 'uint256'],
      [privHash, validUntil, playerId, buyerTeamId]
  )
  return buyerTxMsg;
}

async function signOfferToBuyPlayerMTx(currencyId, price, rnd, validUntil, playerId, buyerTeamId, buyerAccount) {
  const buyerTxMsg = buildOfferToBuyPlayerMsg(currencyId, price, rnd, validUntil, playerId, buyerTeamId);
  const sigBuyer = await buyerAccount.sign(buyerTxMsg);
  sigBuyer.message.should.be.equal(buyerTxMsg);
  return sigBuyer;
}

// The two needed helpers: concatHash & getMessageHash
function concatHash(types, vals) {
    assert(types.length == vals.length, "Length of inputs should be equal")
    return web3.utils.keccak256(
        web3.eth.abi.encodeParameters(types, vals)
    )
}

// this function does the crazy thing solidity does for hex...
function getMessageHash(msg)Â {
    assert(web3.utils.isHexStrict(msg), "We currently only support signing hashes, which are 0x stating hex numbers")
    message = web3.utils.hexToBytes(msg);
    var messageBuffer = Buffer.from(message);
    var preamble = "\x19Ethereum Signed Message:\n" + message.length;
    var preambleBuffer = Buffer.from(preamble);
    var ethMessage = Buffer.concat([preambleBuffer, messageBuffer]);
    return web3.utils.keccak256(ethMessage);
}

contract("Market", accounts => {

  beforeEach(async () => {
    assets = await Assets.new().should.be.fulfilled;
    await assets.init().should.be.fulfilled;
    market = await Market.new().should.be.fulfilled;
    await market.setAssetsAddress(assets.address).should.be.fulfilled;
    encoding = assets;

    sellerAccount = await web3.eth.accounts.create("iamaseller");
    buyerAccount = await web3.eth.accounts.create("iamabuyer");
    playerId = await encoding.encodeTZCountryAndVal(tz = 1, countryIdxInTZ = 0, playerIdxInCountry = 4);
    sellerTeamId = await encoding.encodeTZCountryAndVal(tz = 1, countryIdxInTZ = 0, teamIdxInCountry1 = 0);
    buyerTeamId = await encoding.encodeTZCountryAndVal(tz = 1, countryIdxInTZ = 0, teamIdxInCountry2 = 1);
    await assets.transferFirstBotToAddr(tz = 1, countryIdxInTZ = 0, sellerAccount.address).should.be.fulfilled;
    await assets.transferFirstBotToAddr(tz = 1, countryIdxInTZ = 0, buyerAccount.address).should.be.fulfilled;
    now = await market.getBlockchainNowTime().should.be.fulfilled;
    
    AUCTION_TIME = await market.AUCTION_TIME().should.be.fulfilled;
    AUCTION_TIME = AUCTION_TIME.toNumber();
    
    POST_AUCTION_TIME = await market.POST_AUCTION_TIME().should.be.fulfilled;
    POST_AUCTION_TIME = POST_AUCTION_TIME.toNumber();
    
    validUntil = now.toNumber() + AUCTION_TIME;
    currencyId = 1;
    price = 41234;
    sellerRnd = 42321;
    extraPrice = 332;
    buyerRnd = 1243523;

  });

  // *************************************************************************
  // *********************************   TEST  *******************************
  // *************************************************************************
  
  // it('deterministic sign (values used in market.notary test)', async () => {
  //   sellerTeamId.should.be.bignumber.equal('274877906944');
  //   buyerTeamId.should.be.bignumber.equal('274877906945');
  //   sellerTeamPlayerIds = await assets.getPlayerIdsInTeam(sellerTeamId).should.be.fulfilled;
  //   const playerIdToSell = sellerTeamPlayerIds[0];
  //   playerIdToSell.should.be.bignumber.equal('274877906944');

  //   const sellerAccount = web3.eth.accounts.privateKeyToAccount('0x3B878F7892FBBFA30C8AED1DF317C19B853685E707C2CF0EE1927DC516060A54');
  //   const buyerAccount = await web3.eth.accounts.privateKeyToAccount('0x3693a221b147b7338490aa65a86dbef946eccaff76cc1fc93265468822dfb882');

  //   // Define params of the seller, and sign
  //   validUntil = 2000000000;
  //   buyerHiddenPrice = concatHash(
  //     ["uint256", "uint256"],
  //     [extraPrice, buyerRnd]
  //   );


  //   const privateHash = await market.hashPrivateMsg(currencyId, price, sellerRnd).should.be.fulfilled;
  //   privateHash.should.be.equal('0x4200de738160a9e6b8f69648fbb7feb323f73fac5acff1b7bb546bb7ac3591fa');
  //   const message = await market.buildPutForSaleTxMsg(privateHash, validUntil, playerIdToSell).should.be.fulfilled;
  //   message.should.be.equal('0x909e2fbc45b398649f58c7ea4b632ff1b457ee5f60a43a70abfe00d50e7c917d');
  //   const sigSeller = sellerAccount.sign(message);
  //   sigSeller.messageHash.should.be.equal('0x55d0b23ce4ce7530aa71b177b169ca4bf52dec4866ffbf37fa84fd0146a5f36a');
  //   sigSeller.signature.should.be.equal('0x4cc92984c7ee4fe678b0c9b1da26b6757d9000964d514bdaddc73493393ab299276bad78fd41091f9fe6c169adaa3e8e7db146a83e0a2e1b60480320443919471c');

  //   const prefixed = await market.prefixed(message).should.be.fulfilled;
  //   const buyerMsg = await market.buildAgreeToBuyTxMsg(prefixed, buyerHiddenPrice, buyerTeamId).should.be.fulfilled;
  //   buyerMsg.should.be.equal('0x44be0cc9346f1bb12704bd9cd27b56dfda87932bfd7ae6bc755197d1f710c5c0');
  //   const sigBuyer = buyerAccount.sign(buyerMsg);
  //   sigBuyer.messageHash.should.be.equal('0xe791281515bce955edbc5cef6af64fcc018a5a7b0384f7cc5357b9c40476983a');
  //   sigBuyer.signature.should.be.equal('0x84b2c5e27eec9a6fd467414e2ee9a8788077b4a040637769bc909f9d72b17fb92a5c2a5bbbde8cb8eb57cff0d8fadefb2b25493508c1ba1302cd79e1efe4791e1b');
  // });

  
  
  // ------------------------------------------------------------------------------------ 
  // ------------------------------------------------------------------------------------ 
  // ------------------------------------------------------------------------------------ 
  // ----------------------------------------------------------------- TEAMS 
  // ------------------------------------------------------------------------------------
  // ------------------------------------------------------------------------------------
  // ------------------------------------------------------------------------------------
  
  
  
  
  // // *************************************************************************
  // // *********************************   TEST  *******************************
  // // *************************************************************************
  
  
  // it("teams: completes a MAKE_AN_OFFER via MTXs", async () => {
  //   // now, sellerRnd is fixed by offerer
  //   offererRnd = 23987435;
  //   offerValidUntil = now.toNumber() + 3600; // valid for an hour
  //   const validUntil = now.toNumber() + 3000 + AUCTION_TIME; // this is, at most, offerValidUntil + AUCTION_TIME
    
  //   let sigOffer = await signAgreeToBuyPlayerMTx(
  //     currencyId,
  //     price,
  //     extraPrice = 0,
  //     offererRnd,
  //     buyerRnd = 0,
  //     offerValidUntil,
  //     playerId.toNumber(),
  //     isOffer2StartAuction = true,
  //     buyerTeamId.toNumber(),
  //     buyerAccount
  //   ).should.be.fulfilled;

  //   sigSeller = await signPutForSaleMTx(
  //     currencyId,
  //     price,
  //     offererRnd, // he reuses the rnd provided
  //     validUntil, 
  //     playerId.toNumber(),
  //     sellerAccount
  //   );

  //   // First of all, Freeverse and Buyer check the signature
  //   // In this case, using web3:
  //   recoveredSellerAddr = await web3.eth.accounts.recover(sigSeller);
  //   recoveredSellerAddr.should.be.equal(sellerAccount.address);

  //   // The correctness of the seller message can also be checked in the BC:
  //   const sellerHiddenPrice = concatHash(
  //     ["uint8", "uint256", "uint256"],
  //     [currencyId, price, offererRnd]
  //   );
  //   sellerTxMsgBC = await market.buildPutForSaleTxMsg(sellerHiddenPrice, validUntil, playerId).should.be.fulfilled;
  //   sellerTxMsgBC.should.be.equal(sigSeller.message);

  //   // Then, the buyer builds a message to sign
  //   let isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
  //   isPlayerFrozen.should.be.equal(false);

  //   // Add some amount to the price where seller started, and a rnd to obfuscate it
  //   const buyerHiddenPrice = concatHash(
  //     ["uint256", "uint256"],
  //     [extraPrice, buyerRnd]
  //   );
    
  //   isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
  //   isPlayerFrozen.should.be.equal(false);

  //   // Freeverse checks the signature
  //   recoveredBuyerAddr = await web3.eth.accounts.recover(sigOffer);
  //   recoveredBuyerAddr.should.be.equal(buyerAccount.address);

  //   // and send the Freeze TX. 
  //   const sigSellerMsgRS = [
  //     sigSeller.messageHash,
  //     sigSeller.r,
  //     sigSeller.s,
  //   ];
    
  //   // we can double-check that it would work
  //   ok = await market.areFreezePlayerRequirementsOK(
  //     sellerHiddenPrice,
  //     validUntil,
  //     playerId,
  //     sigSellerMsgRS,
  //     sigSeller.v
  //   ).should.be.fulfilled;
  //   ok.should.be.equal(true);
    
  //   // and finally do the freeze 
  //   tx = await market.freezePlayer(
  //     sellerHiddenPrice,
  //     validUntil,
  //     playerId,
  //     sigSellerMsgRS,
  //     sigSeller.v
  //   ).should.be.fulfilled;

  //   isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
  //   isPlayerFrozen.should.be.equal(true);

  //   truffleAssert.eventEmitted(tx, "PlayerFreeze", (event) => {
  //     return event.playerId.should.be.bignumber.equal('274877906948') && event.frozen.should.be.equal(true);
  //   });


  //   // Freeverse waits until actual money has been transferred between users, and completes sale
  //   const sigOfferMsgRS = [
  //     sigOffer.messageHash,
  //     sigOffer.r,
  //     sigOffer.s,
  //   ];
    
  //   // test first
  //   ok = await market.areCompletePlayerAuctionRequirementsOK(
  //     sellerHiddenPrice,
  //     offerValidUntil,
  //     playerId,
  //     buyerHiddenPrice,
  //     buyerTeamId.toNumber(),
  //     sigOfferMsgRS,
  //     sigOffer.v,
  //     isOffer2StartAuction = true
  //   ).should.be.fulfilled;
  //   ok.should.be.equal(true);
    
  //   // write with confidence
  //   tx = await market.completePlayerAuction(
  //     sellerHiddenPrice,
  //     offerValidUntil,
  //     playerId,
  //     buyerHiddenPrice,
  //     buyerTeamId.toNumber(),
  //     sigOfferMsgRS,
  //     sigOffer.v,
  //     isOffer2StartAuction = true
  //   ).should.be.fulfilled;
    
  //   truffleAssert.eventEmitted(tx, "PlayerFreeze", (event) => {
  //     return event.playerId.should.be.bignumber.equal(playerId) && event.frozen.should.be.equal(false);
  //   });

  //   let finalOwner = await assets.getOwnerPlayer(playerId).should.be.fulfilled;
  //   finalOwner.should.be.equal(buyerAccount.address);
  // });
  
  // return
  // // *************************************************************************
  // // *********************************   TEST  *******************************
  // // *************************************************************************
  
  
  // it("fails a MAKE_AN_OFFER via MTXs because offerValidUntil had expired", async () => {
  //   // now, sellerRnd is fixed by offerer
  //   offererRnd = 23987435;
  //   offerValidUntil = now.toNumber() + 3600; // valid for an hour
  //   const validUntil = now.toNumber() + 3601 + AUCTION_TIME; // this is, at most, offerValidUntil + AUCTION_TIME
    
  //   let sigOffer = await signAgreeToBuyPlayerMTx(
  //     currencyId,
  //     price,
  //     extraPrice = 0,
  //     offererRnd,
  //     buyerRnd = 0,
  //     offerValidUntil,
  //     playerId.toNumber(),
  //     isOffer2StartAuction = true,
  //     buyerTeamId.toNumber(),
  //     buyerAccount
  //   ).should.be.fulfilled;

  //   sigSeller = await signPutForSaleMTx(
  //     currencyId,
  //     price,
  //     offererRnd, // he reuses the rnd provided
  //     validUntil, 
  //     playerId.toNumber(),
  //     sellerAccount
  //   );

  //   // First of all, Freeverse and Buyer check the signature
  //   // In this case, using web3:
  //   recoveredSellerAddr = await web3.eth.accounts.recover(sigSeller);
  //   recoveredSellerAddr.should.be.equal(sellerAccount.address);

  //   // The correctness of the seller message can also be checked in the BC:
  //   const sellerHiddenPrice = concatHash(
  //     ["uint8", "uint256", "uint256"],
  //     [currencyId, price, offererRnd]
  //   );
  //   sellerTxMsgBC = await market.buildPutForSaleTxMsg(sellerHiddenPrice, validUntil, playerId).should.be.fulfilled;
  //   sellerTxMsgBC.should.be.equal(sigSeller.message);

  //   // Then, the buyer builds a message to sign
  //   let isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
  //   isPlayerFrozen.should.be.equal(false);

  //   // Add some amount to the price where seller started, and a rnd to obfuscate it
  //   const buyerHiddenPrice = concatHash(
  //     ["uint256", "uint256"],
  //     [extraPrice, buyerRnd]
  //   );
    
  //   isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
  //   isPlayerFrozen.should.be.equal(false);

  //   // Freeverse checks the signature
  //   recoveredBuyerAddr = await web3.eth.accounts.recover(sigOffer);
  //   recoveredBuyerAddr.should.be.equal(buyerAccount.address);

  //   // and send the Freeze TX. 
  //   const sigSellerMsgRS = [
  //     sigSeller.messageHash,
  //     sigSeller.r,
  //     sigSeller.s,
  //   ];

  //   // we can double-check that it would work
  //   ok = await market.areFreezePlayerRequirementsOK(
  //     sellerHiddenPrice,
  //     validUntil,
  //     playerId,
  //     sigSellerMsgRS,
  //     sigSeller.v
  //   ).should.be.fulfilled;
  //   ok.should.be.equal(true);
    
  //   // and finally do the freeze 
  //   tx = await market.freezePlayer(
  //     sellerHiddenPrice,
  //     validUntil,
  //     playerId,
  //     sigSellerMsgRS,
  //     sigSeller.v
  //   ).should.be.fulfilled;

  //   isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
  //   isPlayerFrozen.should.be.equal(true);

  //   truffleAssert.eventEmitted(tx, "PlayerFreeze", (event) => {
  //     return event.playerId.should.be.bignumber.equal('274877906948') && event.frozen.should.be.equal(true);
  //   });


  //   // Freeverse waits until actual money has been transferred between users, and completes sale
  //   const sigOfferMsgRS = [
  //     sigOffer.messageHash,
  //     sigOffer.r,
  //     sigOffer.s,
  //   ];
    
  //   // test first
  //   ok = await market.areCompletePlayerAuctionRequirementsOK(
  //     sellerHiddenPrice,
  //     offerValidUntil,
  //     playerId,
  //     buyerHiddenPrice,
  //     buyerTeamId.toNumber(),
  //     sigOfferMsgRS,
  //     sigOffer.v,
  //     isOffer2StartAuction = true
  //   ).should.be.fulfilled;
  //   ok.should.be.equal(false);
    
  //   // write with confidence    
  //   tx = await market.completePlayerAuction(
  //     sellerHiddenPrice,
  //     offerValidUntil,
  //     playerId,
  //     buyerHiddenPrice,
  //     buyerTeamId.toNumber(),
  //     sigOfferMsgRS,
  //     sigOffer.v,
  //     isOffer2StartAuction = true
  //   ).should.be.rejected;
  // });
  
  // // *************************************************************************
  // // *********************************   TEST  *******************************
  // // *************************************************************************
  
  
  // it("fails a MAKE_AN_OFFER via MTXs because validUntil is too large", async () => {
  //   validUntil = now.toNumber() + 3600*24*2; // two days

  //   sigSeller = await signPutForSaleMTx(
  //     currencyId,
  //     price,
  //     offererRnd, // he reuses the rnd provided
  //     validUntil, 
  //     playerId.toNumber(),
  //     sellerAccount
  //   );

  //   // First of all, Freeverse and Buyer check the signature
  //   // In this case, using web3:
  //   recoveredSellerAddr = await web3.eth.accounts.recover(sigSeller);
  //   recoveredSellerAddr.should.be.equal(sellerAccount.address);

  //   // The correctness of the seller message can also be checked in the BC:
  //   const sellerHiddenPrice = concatHash(
  //     ["uint8", "uint256", "uint256"],
  //     [currencyId, price, offererRnd]
  //   );
  //   sellerTxMsgBC = await market.buildPutForSaleTxMsg(sellerHiddenPrice, validUntil, playerId).should.be.fulfilled;
  //   sellerTxMsgBC.should.be.equal(sigSeller.message);

  //   // Then, the buyer builds a message to sign
  //   let isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
  //   isPlayerFrozen.should.be.equal(false);

  //   // and send the Freeze TX. 
  //   const sigSellerMsgRS = [
  //     sigSeller.messageHash,
  //     sigSeller.r,
  //     sigSeller.s,
  //   ];

  //   // we can double-check that it would work
  //   ok = await market.areFreezePlayerRequirementsOK(
  //     sellerHiddenPrice,
  //     validUntil,
  //     playerId,
  //     sigSellerMsgRS,
  //     sigSeller.v
  //   ).should.be.fulfilled;
  //   ok.should.be.equal(false);
    
  //   // and finally do the freeze 
  //   tx = await market.freezePlayer(
  //     sellerHiddenPrice,
  //     validUntil,
  //     playerId,
  //     sigSellerMsgRS,
  //     sigSeller.v
  //   ).should.be.rejected;
  // });
  
  
  
  
  
  // // *************************************************************************
  // // *********************************   TEST  *******************************
  // // *************************************************************************
  
  // it("completes a PUT_FOR_SALE and AGREE_TO_BUY via MTXs", async () => {
  //   // 1. buyer's mobile app sends to Freeverse: sigBuyer AND params (currencyId, price, ....)
  //   // 2. Freeverse checks signature and returns to buyer: OK, failed
  //   // 3. Freeverse advertises to owner that there is an offer to buy his asset at price
  //   // 4. seller's mobile app sends to Freeverse: sigSeller and params
  //   // 5. Freeverse checks signature and returns to seller: OK, failed
  //   // 6. Freeverse FREEZES the player by sending a TX to the BLOCKCHAIN
  //   // 7. If freeze went OK:
  //   //          urges buyer to complete payment
  //   //    If freeze not OK (he probably sold the player in a different market)
  //   //          tells the buyer to forget about this player
  //   // 8. Freeverse receives confirmation from Paypal, Apple, GooglePay... of payment buyer -> seller
  //   // 9. Freeverse COMPLETES TRANSFER OF PLAYER USING BLOCKCHAIN

  //   // Mobile app does this:
  //   sigSeller = await signPutForSaleMTx(
  //     currencyId,
  //     price,
  //     sellerRnd,
  //     validUntil,
  //     playerId.toNumber(),
  //     sellerAccount
  //   );

  //   // First of all, Freeverse and Buyer check the signature
  //   // In this case, using web3:
  //   recoveredSellerAddr = await web3.eth.accounts.recover(sigSeller);
  //   recoveredSellerAddr.should.be.equal(sellerAccount.address);

  //   // The correctness of the seller message can also be checked in the BC:
  //   const sellerHiddenPrice = concatHash(
  //     ["uint8", "uint256", "uint256"],
  //     [currencyId, price, sellerRnd]
  //   );
  //   sellerTxMsgBC = await market.buildPutForSaleTxMsg(sellerHiddenPrice, validUntil, playerId).should.be.fulfilled;
  //   sellerTxMsgBC.should.be.equal(sigSeller.message);

  //   // Then, the buyer builds a message to sign
  //   let isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
  //   isPlayerFrozen.should.be.equal(false);

  //   // Add some amount to the price where seller started, and a rnd to obfuscate it
  //   const buyerHiddenPrice = concatHash(
  //     ["uint256", "uint256"],
  //     [extraPrice, buyerRnd]
  //   );

  //   let sigBuyer = await signAgreeToBuyPlayerMTx(
  //     currencyId,
  //     price,
  //     extraPrice,
  //     sellerRnd,
  //     buyerRnd,
  //     validUntil,
  //     playerId.toNumber(),
  //     isOffer2StartAuction = false,
  //     buyerTeamId.toNumber(),
  //     buyerAccount
  //   ).should.be.fulfilled;

  //   isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
  //   isPlayerFrozen.should.be.equal(false);

  //   // Freeverse checks the signature
  //   recoveredBuyerAddr = await web3.eth.accounts.recover(sigBuyer);
  //   recoveredBuyerAddr.should.be.equal(buyerAccount.address);

  //   // and send the Freeze TX. 
  //   const sigSellerMsgRS = [
  //     sigSeller.messageHash,
  //     sigSeller.r,
  //     sigSeller.s,
  //   ];
  //   tx = await market.freezePlayer(
  //     sellerHiddenPrice,
  //     validUntil,
  //     playerId,
  //     sigSellerMsgRS,
  //     sigSeller.v
  //   ).should.be.fulfilled;

  //   isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
  //   isPlayerFrozen.should.be.equal(true);

  //   truffleAssert.eventEmitted(tx, "PlayerFreeze", (event) => {
  //     return event.playerId.should.be.bignumber.equal('274877906948') && event.frozen.should.be.equal(true);
  //   });


  //   // Freeverse waits until actual money has been transferred between users, and completes sale
  //   const sigBuyerMsgRS = [
  //     sigBuyer.messageHash,
  //     sigBuyer.r,
  //     sigBuyer.s,
  //   ];
  //   tx = await market.completePlayerAuction(
  //     sellerHiddenPrice,
  //     validUntil,
  //     playerId,
  //     buyerHiddenPrice,
  //     buyerTeamId.toNumber(),
  //     sigBuyerMsgRS,
  //     sigBuyer.v,
  //     isOffer2StartAuction = false
  //   ).should.be.fulfilled;
    
  //   truffleAssert.eventEmitted(tx, "PlayerFreeze", (event) => {
  //     return event.playerId.should.be.bignumber.equal(playerId) && event.frozen.should.be.equal(false);
  //   });

  //   let finalOwner = await assets.getOwnerPlayer(playerId).should.be.fulfilled;
  //   finalOwner.should.be.equal(buyerAccount.address);
  // });

    
  // // *************************************************************************
  // // *********************************   TEST  *******************************
  // // *************************************************************************
  
  // it("fails a PUT_FOR_SALE and AGREE_TO_BUY via MTXs because isOffer2StartAuction is not correctly set ", async () => {
  //   // 1. buyer's mobile app sends to Freeverse: sigBuyer AND params (currencyId, price, ....)
  //   // 2. Freeverse checks signature and returns to buyer: OK, failed
  //   // 3. Freeverse advertises to owner that there is an offer to buy his asset at price
  //   // 4. seller's mobile app sends to Freeverse: sigSeller and params
  //   // 5. Freeverse checks signature and returns to seller: OK, failed
  //   // 6. Freeverse FREEZES the player by sending a TX to the BLOCKCHAIN
  //   // 7. If freeze went OK:
  //   //          urges buyer to complete payment
  //   //    If freeze not OK (he probably sold the player in a different market)
  //   //          tells the buyer to forget about this player
  //   // 8. Freeverse receives confirmation from Paypal, Apple, GooglePay... of payment buyer -> seller
  //   // 9. Freeverse COMPLETES TRANSFER OF PLAYER USING BLOCKCHAIN

  //   // Mobile app does this:
  //   sigSeller = await signPutForSaleMTx(
  //     currencyId,
  //     price,
  //     sellerRnd,
  //     validUntil,
  //     playerId.toNumber(),
  //     sellerAccount
  //   );

  //   // First of all, Freeverse and Buyer check the signature
  //   // In this case, using web3:
  //   recoveredSellerAddr = await web3.eth.accounts.recover(sigSeller);
  //   recoveredSellerAddr.should.be.equal(sellerAccount.address);

  //   // The correctness of the seller message can also be checked in the BC:
  //   const sellerHiddenPrice = concatHash(
  //     ["uint8", "uint256", "uint256"],
  //     [currencyId, price, sellerRnd]
  //   );
  //   sellerTxMsgBC = await market.buildPutForSaleTxMsg(sellerHiddenPrice, validUntil, playerId).should.be.fulfilled;
  //   sellerTxMsgBC.should.be.equal(sigSeller.message);

  //   // Then, the buyer builds a message to sign
  //   let isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
  //   isPlayerFrozen.should.be.equal(false);

  //   // Add some amount to the price where seller started, and a rnd to obfuscate it
  //   const buyerHiddenPrice = concatHash(
  //     ["uint256", "uint256"],
  //     [extraPrice, buyerRnd]
  //   );

  //   let sigBuyer = await signAgreeToBuyPlayerMTx(
  //     currencyId,
  //     price,
  //     extraPrice,
  //     sellerRnd,
  //     buyerRnd,
  //     validUntil,
  //     playerId.toNumber(),
  //     isOffer2StartAuction = false,
  //     buyerTeamId.toNumber(),
  //     buyerAccount
  //   ).should.be.fulfilled;

  //   isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
  //   isPlayerFrozen.should.be.equal(false);

  //   // Freeverse checks the signature
  //   recoveredBuyerAddr = await web3.eth.accounts.recover(sigBuyer);
  //   recoveredBuyerAddr.should.be.equal(buyerAccount.address);

  //   // and send the Freeze TX. 
  //   const sigSellerMsgRS = [
  //     sigSeller.messageHash,
  //     sigSeller.r,
  //     sigSeller.s,
  //   ];
  //   tx = await market.freezePlayer(
  //     sellerHiddenPrice,
  //     validUntil,
  //     playerId,
  //     sigSellerMsgRS,
  //     sigSeller.v
  //   ).should.be.fulfilled;

  //   isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
  //   isPlayerFrozen.should.be.equal(true);

  //   truffleAssert.eventEmitted(tx, "PlayerFreeze", (event) => {
  //     return event.playerId.should.be.bignumber.equal('274877906948') && event.frozen.should.be.equal(true);
  //   });

  //   // Freeverse waits until actual money has been transferred between users, and completes sale
  //   const sigBuyerMsgRS = [
  //     sigBuyer.messageHash,
  //     sigBuyer.r,
  //     sigBuyer.s,
  //   ];
    
  //   tx = await market.completePlayerAuction(
  //     sellerHiddenPrice,
  //     validUntil,
  //     playerId,
  //     buyerHiddenPrice,
  //     buyerTeamId.toNumber(),
  //     sigBuyerMsgRS,
  //     sigBuyer.v,
  //     isOffer2StartAuction = true
  //   ).should.be.rejected;
  // });

  
  

  
  
  // ------------------------------------------------------------------------------------ 
  // ------------------------------------------------------------------------------------ 
  // ------------------------------------------------------------------------------------ 
  // ----------------------------------------------------------------- PLAYERS 
  // ------------------------------------------------------------------------------------
  // ------------------------------------------------------------------------------------
  // ------------------------------------------------------------------------------------
  
  
  
  
  // *************************************************************************
  // *********************************   TEST  *******************************
  // *************************************************************************
  
  
  it("players: completes a MAKE_AN_OFFER via MTXs", async () => {
    // now, sellerRnd is fixed by offerer
    offererRnd = 23987435;
    offerValidUntil = now.toNumber() + 3600; // valid for an hour
    const validUntil = now.toNumber() + 3000 + AUCTION_TIME; // this is, at most, offerValidUntil + AUCTION_TIME
    
    let sigOffer = await signAgreeToBuyPlayerMTx(
      currencyId,
      price,
      extraPrice = 0,
      offererRnd,
      buyerRnd = 0,
      offerValidUntil,
      playerId.toNumber(),
      isOffer2StartAuction = true,
      buyerTeamId.toNumber(),
      buyerAccount
    ).should.be.fulfilled;

    sigSeller = await signPutForSaleMTx(
      currencyId,
      price,
      offererRnd, // he reuses the rnd provided
      validUntil, 
      playerId.toNumber(),
      sellerAccount
    );

    // First of all, Freeverse and Buyer check the signature
    // In this case, using web3:
    recoveredSellerAddr = await web3.eth.accounts.recover(sigSeller);
    recoveredSellerAddr.should.be.equal(sellerAccount.address);

    // The correctness of the seller message can also be checked in the BC:
    const sellerHiddenPrice = concatHash(
      ["uint8", "uint256", "uint256"],
      [currencyId, price, offererRnd]
    );
    sellerTxMsgBC = await market.buildPutForSaleTxMsg(sellerHiddenPrice, validUntil, playerId).should.be.fulfilled;
    sellerTxMsgBC.should.be.equal(sigSeller.message);

    // Then, the buyer builds a message to sign
    let isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
    isPlayerFrozen.should.be.equal(false);

    // Add some amount to the price where seller started, and a rnd to obfuscate it
    const buyerHiddenPrice = concatHash(
      ["uint256", "uint256"],
      [extraPrice, buyerRnd]
    );
    
    isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
    isPlayerFrozen.should.be.equal(false);

    // Freeverse checks the signature
    recoveredBuyerAddr = await web3.eth.accounts.recover(sigOffer);
    recoveredBuyerAddr.should.be.equal(buyerAccount.address);

    // and send the Freeze TX. 
    const sigSellerMsgRS = [
      sigSeller.messageHash,
      sigSeller.r,
      sigSeller.s,
    ];
    
    // we can double-check that it would work
    ok = await market.areFreezePlayerRequirementsOK(
      sellerHiddenPrice,
      validUntil,
      playerId,
      sigSellerMsgRS,
      sigSeller.v
    ).should.be.fulfilled;
    ok.should.be.equal(true);
    
    // and finally do the freeze 
    tx = await market.freezePlayer(
      sellerHiddenPrice,
      validUntil,
      playerId,
      sigSellerMsgRS,
      sigSeller.v
    ).should.be.fulfilled;

    isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
    isPlayerFrozen.should.be.equal(true);

    truffleAssert.eventEmitted(tx, "PlayerFreeze", (event) => {
      return event.playerId.should.be.bignumber.equal('274877906948') && event.frozen.should.be.equal(true);
    });


    // Freeverse waits until actual money has been transferred between users, and completes sale
    const sigOfferMsgRS = [
      sigOffer.messageHash,
      sigOffer.r,
      sigOffer.s,
    ];
    
    // test first
    ok = await market.areCompletePlayerAuctionRequirementsOK(
      sellerHiddenPrice,
      offerValidUntil,
      playerId,
      buyerHiddenPrice,
      buyerTeamId.toNumber(),
      sigOfferMsgRS,
      sigOffer.v,
      isOffer2StartAuction = true
    ).should.be.fulfilled;
    ok.should.be.equal(true);
    
    // write with confidence
    tx = await market.completePlayerAuction(
      sellerHiddenPrice,
      offerValidUntil,
      playerId,
      buyerHiddenPrice,
      buyerTeamId.toNumber(),
      sigOfferMsgRS,
      sigOffer.v,
      isOffer2StartAuction = true
    ).should.be.fulfilled;
    
    truffleAssert.eventEmitted(tx, "PlayerFreeze", (event) => {
      return event.playerId.should.be.bignumber.equal(playerId) && event.frozen.should.be.equal(false);
    });

    let finalOwner = await assets.getOwnerPlayer(playerId).should.be.fulfilled;
    finalOwner.should.be.equal(buyerAccount.address);
  });
  
  // *************************************************************************
  // *********************************   TEST  *******************************
  // *************************************************************************
  
  
  it("players: fails a MAKE_AN_OFFER via MTXs because offerValidUntil had expired", async () => {
    // now, sellerRnd is fixed by offerer
    offererRnd = 23987435;
    offerValidUntil = now.toNumber() + 3600; // valid for an hour
    const validUntil = now.toNumber() + 3601 + AUCTION_TIME; // this is, at most, offerValidUntil + AUCTION_TIME
    
    let sigOffer = await signAgreeToBuyPlayerMTx(
      currencyId,
      price,
      extraPrice = 0,
      offererRnd,
      buyerRnd = 0,
      offerValidUntil,
      playerId.toNumber(),
      isOffer2StartAuction = true,
      buyerTeamId.toNumber(),
      buyerAccount
    ).should.be.fulfilled;

    sigSeller = await signPutForSaleMTx(
      currencyId,
      price,
      offererRnd, // he reuses the rnd provided
      validUntil, 
      playerId.toNumber(),
      sellerAccount
    );

    // First of all, Freeverse and Buyer check the signature
    // In this case, using web3:
    recoveredSellerAddr = await web3.eth.accounts.recover(sigSeller);
    recoveredSellerAddr.should.be.equal(sellerAccount.address);

    // The correctness of the seller message can also be checked in the BC:
    const sellerHiddenPrice = concatHash(
      ["uint8", "uint256", "uint256"],
      [currencyId, price, offererRnd]
    );
    sellerTxMsgBC = await market.buildPutForSaleTxMsg(sellerHiddenPrice, validUntil, playerId).should.be.fulfilled;
    sellerTxMsgBC.should.be.equal(sigSeller.message);

    // Then, the buyer builds a message to sign
    let isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
    isPlayerFrozen.should.be.equal(false);

    // Add some amount to the price where seller started, and a rnd to obfuscate it
    const buyerHiddenPrice = concatHash(
      ["uint256", "uint256"],
      [extraPrice, buyerRnd]
    );
    
    isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
    isPlayerFrozen.should.be.equal(false);

    // Freeverse checks the signature
    recoveredBuyerAddr = await web3.eth.accounts.recover(sigOffer);
    recoveredBuyerAddr.should.be.equal(buyerAccount.address);

    // and send the Freeze TX. 
    const sigSellerMsgRS = [
      sigSeller.messageHash,
      sigSeller.r,
      sigSeller.s,
    ];

    // we can double-check that it would work
    ok = await market.areFreezePlayerRequirementsOK(
      sellerHiddenPrice,
      validUntil,
      playerId,
      sigSellerMsgRS,
      sigSeller.v
    ).should.be.fulfilled;
    ok.should.be.equal(true);
    
    // and finally do the freeze 
    tx = await market.freezePlayer(
      sellerHiddenPrice,
      validUntil,
      playerId,
      sigSellerMsgRS,
      sigSeller.v
    ).should.be.fulfilled;

    isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
    isPlayerFrozen.should.be.equal(true);

    truffleAssert.eventEmitted(tx, "PlayerFreeze", (event) => {
      return event.playerId.should.be.bignumber.equal('274877906948') && event.frozen.should.be.equal(true);
    });


    // Freeverse waits until actual money has been transferred between users, and completes sale
    const sigOfferMsgRS = [
      sigOffer.messageHash,
      sigOffer.r,
      sigOffer.s,
    ];
    
    // test first
    ok = await market.areCompletePlayerAuctionRequirementsOK(
      sellerHiddenPrice,
      offerValidUntil,
      playerId,
      buyerHiddenPrice,
      buyerTeamId.toNumber(),
      sigOfferMsgRS,
      sigOffer.v,
      isOffer2StartAuction = true
    ).should.be.fulfilled;
    ok.should.be.equal(false);
    
    // write with confidence    
    tx = await market.completePlayerAuction(
      sellerHiddenPrice,
      offerValidUntil,
      playerId,
      buyerHiddenPrice,
      buyerTeamId.toNumber(),
      sigOfferMsgRS,
      sigOffer.v,
      isOffer2StartAuction = true
    ).should.be.rejected;
  });
  
  // *************************************************************************
  // *********************************   TEST  *******************************
  // *************************************************************************
  
  
  it("players: fails a MAKE_AN_OFFER via MTXs because validUntil is too large", async () => {
    validUntil = now.toNumber() + 3600*24*2; // two days

    sigSeller = await signPutForSaleMTx(
      currencyId,
      price,
      offererRnd, // he reuses the rnd provided
      validUntil, 
      playerId.toNumber(),
      sellerAccount
    );

    // First of all, Freeverse and Buyer check the signature
    // In this case, using web3:
    recoveredSellerAddr = await web3.eth.accounts.recover(sigSeller);
    recoveredSellerAddr.should.be.equal(sellerAccount.address);

    // The correctness of the seller message can also be checked in the BC:
    const sellerHiddenPrice = concatHash(
      ["uint8", "uint256", "uint256"],
      [currencyId, price, offererRnd]
    );
    sellerTxMsgBC = await market.buildPutForSaleTxMsg(sellerHiddenPrice, validUntil, playerId).should.be.fulfilled;
    sellerTxMsgBC.should.be.equal(sigSeller.message);

    // Then, the buyer builds a message to sign
    let isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
    isPlayerFrozen.should.be.equal(false);

    // and send the Freeze TX. 
    const sigSellerMsgRS = [
      sigSeller.messageHash,
      sigSeller.r,
      sigSeller.s,
    ];

    // we can double-check that it would work
    ok = await market.areFreezePlayerRequirementsOK(
      sellerHiddenPrice,
      validUntil,
      playerId,
      sigSellerMsgRS,
      sigSeller.v
    ).should.be.fulfilled;
    ok.should.be.equal(false);
    
    // and finally do the freeze 
    tx = await market.freezePlayer(
      sellerHiddenPrice,
      validUntil,
      playerId,
      sigSellerMsgRS,
      sigSeller.v
    ).should.be.rejected;
  });
  
  
  
  
  
  // *************************************************************************
  // *********************************   TEST  *******************************
  // *************************************************************************
  
  it("players: completes a PUT_FOR_SALE and AGREE_TO_BUY via MTXs", async () => {
    // 1. buyer's mobile app sends to Freeverse: sigBuyer AND params (currencyId, price, ....)
    // 2. Freeverse checks signature and returns to buyer: OK, failed
    // 3. Freeverse advertises to owner that there is an offer to buy his asset at price
    // 4. seller's mobile app sends to Freeverse: sigSeller and params
    // 5. Freeverse checks signature and returns to seller: OK, failed
    // 6. Freeverse FREEZES the player by sending a TX to the BLOCKCHAIN
    // 7. If freeze went OK:
    //          urges buyer to complete payment
    //    If freeze not OK (he probably sold the player in a different market)
    //          tells the buyer to forget about this player
    // 8. Freeverse receives confirmation from Paypal, Apple, GooglePay... of payment buyer -> seller
    // 9. Freeverse COMPLETES TRANSFER OF PLAYER USING BLOCKCHAIN

    // Mobile app does this:
    sigSeller = await signPutForSaleMTx(
      currencyId,
      price,
      sellerRnd,
      validUntil,
      playerId.toNumber(),
      sellerAccount
    );

    // First of all, Freeverse and Buyer check the signature
    // In this case, using web3:
    recoveredSellerAddr = await web3.eth.accounts.recover(sigSeller);
    recoveredSellerAddr.should.be.equal(sellerAccount.address);

    // The correctness of the seller message can also be checked in the BC:
    const sellerHiddenPrice = concatHash(
      ["uint8", "uint256", "uint256"],
      [currencyId, price, sellerRnd]
    );
    sellerTxMsgBC = await market.buildPutForSaleTxMsg(sellerHiddenPrice, validUntil, playerId).should.be.fulfilled;
    sellerTxMsgBC.should.be.equal(sigSeller.message);

    // Then, the buyer builds a message to sign
    let isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
    isPlayerFrozen.should.be.equal(false);

    // Add some amount to the price where seller started, and a rnd to obfuscate it
    const buyerHiddenPrice = concatHash(
      ["uint256", "uint256"],
      [extraPrice, buyerRnd]
    );

    let sigBuyer = await signAgreeToBuyPlayerMTx(
      currencyId,
      price,
      extraPrice,
      sellerRnd,
      buyerRnd,
      validUntil,
      playerId.toNumber(),
      isOffer2StartAuction = false,
      buyerTeamId.toNumber(),
      buyerAccount
    ).should.be.fulfilled;

    isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
    isPlayerFrozen.should.be.equal(false);

    // Freeverse checks the signature
    recoveredBuyerAddr = await web3.eth.accounts.recover(sigBuyer);
    recoveredBuyerAddr.should.be.equal(buyerAccount.address);

    // and send the Freeze TX. 
    const sigSellerMsgRS = [
      sigSeller.messageHash,
      sigSeller.r,
      sigSeller.s,
    ];
    tx = await market.freezePlayer(
      sellerHiddenPrice,
      validUntil,
      playerId,
      sigSellerMsgRS,
      sigSeller.v
    ).should.be.fulfilled;

    isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
    isPlayerFrozen.should.be.equal(true);

    truffleAssert.eventEmitted(tx, "PlayerFreeze", (event) => {
      return event.playerId.should.be.bignumber.equal('274877906948') && event.frozen.should.be.equal(true);
    });


    // Freeverse waits until actual money has been transferred between users, and completes sale
    const sigBuyerMsgRS = [
      sigBuyer.messageHash,
      sigBuyer.r,
      sigBuyer.s,
    ];
    tx = await market.completePlayerAuction(
      sellerHiddenPrice,
      validUntil,
      playerId,
      buyerHiddenPrice,
      buyerTeamId.toNumber(),
      sigBuyerMsgRS,
      sigBuyer.v,
      isOffer2StartAuction = false
    ).should.be.fulfilled;
    
    truffleAssert.eventEmitted(tx, "PlayerFreeze", (event) => {
      return event.playerId.should.be.bignumber.equal(playerId) && event.frozen.should.be.equal(false);
    });

    let finalOwner = await assets.getOwnerPlayer(playerId).should.be.fulfilled;
    finalOwner.should.be.equal(buyerAccount.address);
  });

    
  // *************************************************************************
  // *********************************   TEST  *******************************
  // *************************************************************************
  
  it("players: fails a PUT_FOR_SALE and AGREE_TO_BUY via MTXs because isOffer2StartAuction is not correctly set ", async () => {
    // 1. buyer's mobile app sends to Freeverse: sigBuyer AND params (currencyId, price, ....)
    // 2. Freeverse checks signature and returns to buyer: OK, failed
    // 3. Freeverse advertises to owner that there is an offer to buy his asset at price
    // 4. seller's mobile app sends to Freeverse: sigSeller and params
    // 5. Freeverse checks signature and returns to seller: OK, failed
    // 6. Freeverse FREEZES the player by sending a TX to the BLOCKCHAIN
    // 7. If freeze went OK:
    //          urges buyer to complete payment
    //    If freeze not OK (he probably sold the player in a different market)
    //          tells the buyer to forget about this player
    // 8. Freeverse receives confirmation from Paypal, Apple, GooglePay... of payment buyer -> seller
    // 9. Freeverse COMPLETES TRANSFER OF PLAYER USING BLOCKCHAIN

    // Mobile app does this:
    sigSeller = await signPutForSaleMTx(
      currencyId,
      price,
      sellerRnd,
      validUntil,
      playerId.toNumber(),
      sellerAccount
    );

    // First of all, Freeverse and Buyer check the signature
    // In this case, using web3:
    recoveredSellerAddr = await web3.eth.accounts.recover(sigSeller);
    recoveredSellerAddr.should.be.equal(sellerAccount.address);

    // The correctness of the seller message can also be checked in the BC:
    const sellerHiddenPrice = concatHash(
      ["uint8", "uint256", "uint256"],
      [currencyId, price, sellerRnd]
    );
    sellerTxMsgBC = await market.buildPutForSaleTxMsg(sellerHiddenPrice, validUntil, playerId).should.be.fulfilled;
    sellerTxMsgBC.should.be.equal(sigSeller.message);

    // Then, the buyer builds a message to sign
    let isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
    isPlayerFrozen.should.be.equal(false);

    // Add some amount to the price where seller started, and a rnd to obfuscate it
    const buyerHiddenPrice = concatHash(
      ["uint256", "uint256"],
      [extraPrice, buyerRnd]
    );

    let sigBuyer = await signAgreeToBuyPlayerMTx(
      currencyId,
      price,
      extraPrice,
      sellerRnd,
      buyerRnd,
      validUntil,
      playerId.toNumber(),
      isOffer2StartAuction = false,
      buyerTeamId.toNumber(),
      buyerAccount
    ).should.be.fulfilled;

    isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
    isPlayerFrozen.should.be.equal(false);

    // Freeverse checks the signature
    recoveredBuyerAddr = await web3.eth.accounts.recover(sigBuyer);
    recoveredBuyerAddr.should.be.equal(buyerAccount.address);

    // and send the Freeze TX. 
    const sigSellerMsgRS = [
      sigSeller.messageHash,
      sigSeller.r,
      sigSeller.s,
    ];
    tx = await market.freezePlayer(
      sellerHiddenPrice,
      validUntil,
      playerId,
      sigSellerMsgRS,
      sigSeller.v
    ).should.be.fulfilled;

    isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
    isPlayerFrozen.should.be.equal(true);

    truffleAssert.eventEmitted(tx, "PlayerFreeze", (event) => {
      return event.playerId.should.be.bignumber.equal('274877906948') && event.frozen.should.be.equal(true);
    });

    // Freeverse waits until actual money has been transferred between users, and completes sale
    const sigBuyerMsgRS = [
      sigBuyer.messageHash,
      sigBuyer.r,
      sigBuyer.s,
    ];
    
    tx = await market.completePlayerAuction(
      sellerHiddenPrice,
      validUntil,
      playerId,
      buyerHiddenPrice,
      buyerTeamId.toNumber(),
      sigBuyerMsgRS,
      sigBuyer.v,
      isOffer2StartAuction = true
    ).should.be.rejected;
  });
  
  // *************************************************************************
  // *********************************   TEST  *******************************
  // *************************************************************************
  

  
  it("test accounts from truffle and web3", async () => {
    accountsWeb3 = await web3.eth.getAccounts().should.be.fulfilled;
    accountsWeb3[0].should.be.equal(accounts[0]);
  });
});
