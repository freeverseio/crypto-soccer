const BN = require('bn.js');
require('chai')
    .use(require('chai-as-promised'))
    .use(require('chai-bn')(BN))
    .should();
const truffleAssert = require('truffle-assertions');
const Market = artifacts.require("Market");
const Assets = artifacts.require('Assets');

// THE 2 MAIN API FUNCTIONS: signPutAssetForSaleMTx & signAgreeToBuyPlayerMTx:
// - the 'rnd' number must be a random generated by the Seller's endpoint. It has 2 purposes:
// - ... i) distinguish different put-for-sale MTXs 
// - ... ii) hide the price of the sale when we communicate with the BC (only hashed-prices appear there, with 'rnd' acting as salt)
async function signPutAssetForSaleMTx(currencyId, price, rnd, validUntil, asssetId, sellerAccount) {
  const hiddenPrice = concatHash(
      ['uint8', 'uint256', 'uint256'],
      [currencyId, price, rnd]
  )
  const sellerTxMsg = concatHash(
      ['bytes32', 'uint256', 'uint256'],
      [hiddenPrice, validUntil, asssetId]
  )
  const sigSeller = await sellerAccount.sign(sellerTxMsg);
  sigSeller.message.should.be.equal(sellerTxMsg);
  return sigSeller;
}

// Buyer explicitly agrees to all of sellers data, and only adds the 'buyerTeamId' to it.
async function signAgreeToBuyPlayerMTx(currencyId, price, extraPrice, sellerRnd, buyerRnd, validUntil, playerId, isOffer2StartAuction, buyerTeamId, buyerAccount) {
  const sellerHiddenPrice = concatHash(
    ['uint8', 'uint256', 'uint256'],
    [currencyId, price, sellerRnd]
  )
  const buyerHiddenPrice = concatHash(
    ['uint256', 'uint256'],
    [extraPrice, buyerRnd]
  )
  const sellerTxMsg = concatHash(
      ['bytes32', 'uint256', 'uint256'],
      [sellerHiddenPrice, validUntil, playerId]
  )
  const sellerTxHash = getMessageHash(sellerTxMsg);
  buyerTxMsg = concatHash(
      ['bytes32', 'bytes32', 'uint256', 'bool'],
      [sellerTxHash, buyerHiddenPrice, buyerTeamId, isOffer2StartAuction]
  )
  const sigBuyer = await buyerAccount.sign(buyerTxMsg);
  return sigBuyer;
}

// Buyer explicitly agrees to all of sellers data, and only adds the 'buyerTeamId' to it.
async function signAgreeToBuyTeamMTx(currencyId, price, extraPrice, sellerRnd, buyerRnd, validUntil, playerId, isOffer2StartAuction, buyerAccount) {
  const sellerHiddenPrice = concatHash(
    ['uint8', 'uint256', 'uint256'],
    [currencyId, price, sellerRnd]
  )
  const buyerHiddenPrice = concatHash(
    ['uint256', 'uint256'],
    [extraPrice, buyerRnd]
  )
  const sellerTxMsg = concatHash(
      ['bytes32', 'uint256', 'uint256'],
      [sellerHiddenPrice, validUntil, playerId]
  )
  const sellerTxHash = getMessageHash(sellerTxMsg);
  buyerTxMsg = concatHash(
      ['bytes32', 'bytes32', 'bool'],
      [sellerTxHash, buyerHiddenPrice, isOffer2StartAuction]
  )
  const sigBuyer = await buyerAccount.sign(buyerTxMsg);
  return sigBuyer;
}


function buildOfferToBuyPlayerMsg(currencyId, price, rnd, validUntil, playerId, buyerTeamId) {
  const privHash = concatHash(
      ['uint8', 'uint256', 'uint256'],
      [currencyId, price, rnd]
  )
  const buyerTxMsg = concatHash(
      ['bytes32', 'uint256', 'uint256', 'uint256'],
      [privHash, validUntil, playerId, buyerTeamId]
  )
  return buyerTxMsg;
}

function buildOfferToBuyTeamMsg(currencyId, price, rnd, validUntil, playerId) {
  const privHash = concatHash(
      ['uint8', 'uint256', 'uint256'],
      [currencyId, price, rnd]
  )
  const buyerTxMsg = concatHash(
      ['bytes32', 'uint256', 'uint256'],
      [privHash, validUntil, playerId]
  )
  return buyerTxMsg;
}

async function signOfferToBuyPlayerMTx(currencyId, price, rnd, validUntil, playerId, buyerTeamId, buyerAccount) {
  const buyerTxMsg = buildOfferToBuyPlayerMsg(currencyId, price, rnd, validUntil, playerId, buyerTeamId);
  const sigBuyer = await buyerAccount.sign(buyerTxMsg);
  sigBuyer.message.should.be.equal(buyerTxMsg);
  return sigBuyer;
}

async function signOfferToBuyTeamMTx(currencyId, price, rnd, validUntil, playerId, buyerAccount) {
  const buyerTxMsg = buildOfferToBuyPlayerMsg(currencyId, price, rnd, validUntil, playerId);
  const sigBuyer = await buyerAccount.sign(buyerTxMsg);
  sigBuyer.message.should.be.equal(buyerTxMsg);
  return sigBuyer;
}

async function freezeTeam(currencyId, price, sellerRnd, validUntil, teamId, sellerAccount) {
  // Mobile app does this:
  sigSeller = await signPutAssetForSaleMTx(
    currencyId,
    price,
    sellerRnd,
    validUntil, 
    teamId.toNumber(),
    sellerAccount
  );

  // First of all, Freeverse and Buyer check the signature
  // In this case, using web3:
  recoveredSellerAddr = await web3.eth.accounts.recover(sigSeller);
  recoveredSellerAddr.should.be.equal(sellerAccount.address);

  // The correctness of the seller message can also be checked in the BC:
  const sellerHiddenPrice = concatHash(
    ["uint8", "uint256", "uint256"],
    [currencyId, price, sellerRnd]
  );
  sellerTxMsgBC = await market.buildPutAssetForSaleTxMsg(sellerHiddenPrice, validUntil, sellerTeamId.toNumber()).should.be.fulfilled;
  sellerTxMsgBC.should.be.equal(sigSeller.message);

  // Then, the buyer builds a message to sign
  let isTeamFrozen = await market.isTeamFrozen(teamId.toNumber()).should.be.fulfilled;
  isTeamFrozen.should.be.equal(false);

  // and send the Freeze TX. 
  const sigSellerMsgRS = [
    sigSeller.messageHash,
    sigSeller.r,
    sigSeller.s,
  ];
  
  tx = await market.freezeTeam(
    sellerHiddenPrice,
    validUntil,
    teamId.toNumber(),
    sigSellerMsgRS,
    sigSeller.v
  ).should.be.fulfilled;
  return tx, sellerHiddenPrice;
};


async function freezePlayer(currencyId, price, sellerRnd, validUntil, playerId, sellerAccount) {
    // Mobile app does this:
    sigSeller = await signPutAssetForSaleMTx(
      currencyId,
      price,
      sellerRnd,
      validUntil,
      playerId.toNumber(),
      sellerAccount
    );

    // First of all, Freeverse and Buyer check the signature
    // In this case, using web3:
    recoveredSellerAddr = await web3.eth.accounts.recover(sigSeller);
    recoveredSellerAddr.should.be.equal(sellerAccount.address);

    // The correctness of the seller message can also be checked in the BC:
    const sellerHiddenPrice = concatHash(
      ["uint8", "uint256", "uint256"],
      [currencyId, price, sellerRnd]
    );
    sellerTxMsgBC = await market.buildPutAssetForSaleTxMsg(sellerHiddenPrice, validUntil, playerId).should.be.fulfilled;
    sellerTxMsgBC.should.be.equal(sigSeller.message);

    // Then, the buyer builds a message to sign
    let isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
    isPlayerFrozen.should.be.equal(false);

    // and send the Freeze TX. 
    const sigSellerMsgRS = [
      sigSeller.messageHash,
      sigSeller.r,
      sigSeller.s,
    ];
    
    tx = await market.freezePlayer(
      sellerHiddenPrice,
      validUntil,
      playerId,
      sigSellerMsgRS,
      sigSeller.v
    ).should.be.fulfilled;
    return tx, sellerHiddenPrice;
}

async function completeTeamAuction(
  currencyId, price, sellerRnd, validUntil, sellerTeamId, 
  extraPrice, buyerRnd, isOffer2StartAuctionSig, isOffer2StartAuctionBC, buyerAccount) 
{
  // Add some amount to the price where seller started, and a rnd to obfuscate it
  const buyerHiddenPrice = concatHash(
    ["uint256", "uint256"],
    [extraPrice, buyerRnd]
  );
  let sigBuyer = await signAgreeToBuyTeamMTx(
    currencyId,
    price,
    extraPrice,
    sellerRnd,
    buyerRnd,
    validUntil,
    sellerTeamId.toNumber(),
    isOffer2StartAuctionSig,
    buyerAccount
  ).should.be.fulfilled;

  // Freeverse checks the signature
  recoveredBuyerAddr = await web3.eth.accounts.recover(sigBuyer);
  recoveredBuyerAddr.should.be.equal(buyerAccount.address);

  // Freeverse waits until actual money has been transferred between users, and completes sale
  const sigBuyerMsgRS = [
    sigBuyer.messageHash,
    sigBuyer.r,
    sigBuyer.s,
  ];
  tx = await market.completeTeamAuction(
    sellerHiddenPrice,
    validUntil,
    sellerTeamId.toNumber(),
    buyerHiddenPrice,
    sigBuyerMsgRS,
    sigBuyer.v,
    isOffer2StartAuctionBC
  ).should.be.fulfilled;
  return tx;
}

async function completePlayerAuction(
    currencyId, price, sellerRnd, validUntil, playerId, 
    extraPrice, buyerRnd, isOffer2StartAuctionSig, isOffer2StartAuctionBC, buyerTeamId, buyerAccount
  ) {
  // Add some amount to the price where seller started, and a rnd to obfuscate it
  const buyerHiddenPrice = concatHash(
    ["uint256", "uint256"],
    [extraPrice, buyerRnd]
  );

  let sigBuyer = await signAgreeToBuyPlayerMTx(
    currencyId,
    price,
    extraPrice,
    sellerRnd,
    buyerRnd,
    validUntil,
    playerId.toNumber(),
    isOffer2StartAuctionSig,
    buyerTeamId.toNumber(),
    buyerAccount
  ).should.be.fulfilled;

  // Freeverse checks the signature
  recoveredBuyerAddr = await web3.eth.accounts.recover(sigBuyer);
  recoveredBuyerAddr.should.be.equal(buyerAccount.address);

  // Freeverse waits until actual money has been transferred between users, and completes sale
  const sigBuyerMsgRS = [
    sigBuyer.messageHash,
    sigBuyer.r,
    sigBuyer.s,
  ];
  tx = await market.completePlayerAuction(
    sellerHiddenPrice,
    validUntil,
    playerId,
    buyerHiddenPrice,
    buyerTeamId.toNumber(),
    sigBuyerMsgRS,
    sigBuyer.v,
    isOffer2StartAuctionBC
  ).should.be.fulfilled;
    
  return tx
}


// The two needed helpers: concatHash & getMessageHash
function concatHash(types, vals) {
    assert(types.length == vals.length, "Length of inputs should be equal")
    return web3.utils.keccak256(
        web3.eth.abi.encodeParameters(types, vals)
    )
}

// this function does the crazy thing solidity does for hex...
function getMessageHash(msg)Â {
    assert(web3.utils.isHexStrict(msg), "We currently only support signing hashes, which are 0x stating hex numbers")
    message = web3.utils.hexToBytes(msg);
    var messageBuffer = Buffer.from(message);
    var preamble = "\x19Ethereum Signed Message:\n" + message.length;
    var preambleBuffer = Buffer.from(preamble);
    var ethMessage = Buffer.concat([preambleBuffer, messageBuffer]);
    return web3.utils.keccak256(ethMessage);
}

contract("Market", accounts => {
  let ok;
  
  beforeEach(async () => {
    assets = await Assets.new().should.be.fulfilled;
    await assets.init().should.be.fulfilled;
    market = await Market.new().should.be.fulfilled;
    await market.setAssetsAddress(assets.address).should.be.fulfilled;
    encoding = assets;

    sellerAccount = await web3.eth.accounts.create("iamaseller");
    buyerAccount = await web3.eth.accounts.create("iamabuyer");
    playerId = await encoding.encodeTZCountryAndVal(tz = 1, countryIdxInTZ = 0, playerIdxInCountry = 4);
    sellerTeamId = await encoding.encodeTZCountryAndVal(tz = 1, countryIdxInTZ = 0, teamIdxInCountry1 = 0);
    buyerTeamId = await encoding.encodeTZCountryAndVal(tz = 1, countryIdxInTZ = 0, teamIdxInCountry2 = 1);
    await assets.transferFirstBotToAddr(tz = 1, countryIdxInTZ = 0, sellerAccount.address).should.be.fulfilled;
    await assets.transferFirstBotToAddr(tz = 1, countryIdxInTZ = 0, buyerAccount.address).should.be.fulfilled;
    now = await market.getBlockchainNowTime().should.be.fulfilled;
    
    AUCTION_TIME = await market.AUCTION_TIME().should.be.fulfilled;
    AUCTION_TIME = AUCTION_TIME.toNumber();
    
    POST_AUCTION_TIME = await market.POST_AUCTION_TIME().should.be.fulfilled;
    POST_AUCTION_TIME = POST_AUCTION_TIME.toNumber();
    
    validUntil = now.toNumber() + AUCTION_TIME;
    currencyId = 1;
    price = 41234;
    sellerRnd = 42321;
    extraPrice = 332;
    buyerRnd = 1243523;

  });

  // *************************************************************************
  // *********************************   TEST  *******************************
  // *************************************************************************
  it ('players: put for sale msg', async () => {
    const validUntil = 2000000000;
    const playerId = 10;
    const currencyId = 1;
    const price = 41234;
    const rnd = 42321;
    const sellerAccount = web3.eth.accounts.privateKeyToAccount('0x3B878F7892FBBFA30C8AED1DF317C19B853685E707C2CF0EE1927DC516060A54');

    const sellerHiddenPrice = await market.hashPrivateMsg(currencyId, price, rnd).should.be.fulfilled;
    sellerHiddenPrice.should.be.equal('0x4200de738160a9e6b8f69648fbb7feb323f73fac5acff1b7bb546bb7ac3591fa');
    const message = await market.buildPutAssetForSaleTxMsg(sellerHiddenPrice, validUntil, playerId).should.be.fulfilled;
    message.should.be.equal('0x07d43490a59d38783f03854081c1ecd738a6cb320c1767befdbc147e6b496eed');
    const sigSeller = sellerAccount.sign(message);
    sigSeller.messageHash.should.be.equal('0xc50d978b8a838b6c437a162a94c715f95e92e11fe680cf0f1caf054ad78cd796');
    sigSeller.signature.should.be.equal('0x075ddf60b307abf0ecf323dcdd57230fcb81b30217fb947ee5dbd683cb8bcf074a63f87c97c736f85cd3e56e95f4fcc1e9b159059817915d0be68f944f5b4e531c');
  });
  
   
  it('players: deterministic sign (values used in market.notary test)', async () => {
    sellerTeamId.should.be.bignumber.equal('274877906944');
    buyerTeamId.should.be.bignumber.equal('274877906945');
    sellerTeamPlayerIds = await assets.getPlayerIdsInTeam(sellerTeamId).should.be.fulfilled;
    const playerIdToSell = sellerTeamPlayerIds[0];
    playerIdToSell.should.be.bignumber.equal('274877906944');

    const sellerAccount = web3.eth.accounts.privateKeyToAccount('0x3B878F7892FBBFA30C8AED1DF317C19B853685E707C2CF0EE1927DC516060A54');
    const buyerAccount = await web3.eth.accounts.privateKeyToAccount('0x3693a221b147b7338490aa65a86dbef946eccaff76cc1fc93265468822dfb882');

    // Define params of the seller, and sign
    validUntil = 2000000000;
    buyerHiddenPrice = concatHash(
      ["uint256", "uint256"],
      [extraPrice, buyerRnd]
    );

    const sellerHiddenPrice = await market.hashPrivateMsg(currencyId, price, sellerRnd).should.be.fulfilled;
    sellerHiddenPrice.should.be.equal('0x4200de738160a9e6b8f69648fbb7feb323f73fac5acff1b7bb546bb7ac3591fa');
    const message = await market.buildPutAssetForSaleTxMsg(sellerHiddenPrice, validUntil, playerIdToSell).should.be.fulfilled;

    message.should.be.equal('0x909e2fbc45b398649f58c7ea4b632ff1b457ee5f60a43a70abfe00d50e7c917d');
    const sigSeller = sellerAccount.sign(message);
    sigSeller.messageHash.should.be.equal('0x55d0b23ce4ce7530aa71b177b169ca4bf52dec4866ffbf37fa84fd0146a5f36a');
    sigSeller.signature.should.be.equal('0x4cc92984c7ee4fe678b0c9b1da26b6757d9000964d514bdaddc73493393ab299276bad78fd41091f9fe6c169adaa3e8e7db146a83e0a2e1b60480320443919471c');

    const prefixed = await market.prefixed(message).should.be.fulfilled;
    const isOffer2StartAuction = true;
    const buyerMsg = await market.buildAgreeToBuyPlayerTxMsg(prefixed, buyerHiddenPrice, buyerTeamId, isOffer2StartAuction).should.be.fulfilled;
    buyerMsg.should.be.equal('0xc049e2032b873dd67cc7cc43fb2488f7c770d1654716fc75024cda693c74488c');
    const sigBuyer = buyerAccount.sign(buyerMsg);
    sigBuyer.messageHash.should.be.equal('0xe04d23ec0424b22adec87879118715ce75997a4fd47897c398f3a8cad79b3041');
    sigBuyer.signature.should.be.equal('0xdbe104e7b51c9b1e38cdda4e31c2036e531f7d3338d392bee2f526c4c892437f5e50ddd44224af8b3bd92916b93e4b0d7af2974175010323da7dedea19f30d621c');
  });

  it('teams: deterministic sign (values used in market.notary test)', async () => {
    sellerTeamId.should.be.bignumber.equal('274877906944');

    const sellerAccount = web3.eth.accounts.privateKeyToAccount('0x3B878F7892FBBFA30C8AED1DF317C19B853685E707C2CF0EE1927DC516060A54');
    const buyerAccount = await web3.eth.accounts.privateKeyToAccount('0x3693a221b147b7338490aa65a86dbef946eccaff76cc1fc93265468822dfb882');

    // Define params of the seller, and sign
    validUntil = 2000000000;
    buyerHiddenPrice = concatHash(
      ["uint256", "uint256"],
      [extraPrice, buyerRnd]
    );

    const sellerHiddenPrice = await market.hashPrivateMsg(currencyId, price, sellerRnd).should.be.fulfilled;
    sellerHiddenPrice.should.be.equal('0x4200de738160a9e6b8f69648fbb7feb323f73fac5acff1b7bb546bb7ac3591fa');
    const message = await market.buildPutAssetForSaleTxMsg(sellerHiddenPrice, validUntil, sellerTeamId).should.be.fulfilled;

    message.should.be.equal('0x909e2fbc45b398649f58c7ea4b632ff1b457ee5f60a43a70abfe00d50e7c917d');
    const sigSeller = sellerAccount.sign(message);
    sigSeller.messageHash.should.be.equal('0x55d0b23ce4ce7530aa71b177b169ca4bf52dec4866ffbf37fa84fd0146a5f36a');
    sigSeller.signature.should.be.equal('0x4cc92984c7ee4fe678b0c9b1da26b6757d9000964d514bdaddc73493393ab299276bad78fd41091f9fe6c169adaa3e8e7db146a83e0a2e1b60480320443919471c');

    const prefixed = await market.prefixed(message).should.be.fulfilled;
    const isOffer2StartAuction = true;
    const buyerMsg = await market.buildAgreeToBuyTeamTxMsg(prefixed, buyerHiddenPrice, isOffer2StartAuction).should.be.fulfilled;
    buyerMsg.should.be.equal('0xdd3d39b424073a7a74a333d3b35bc2b0adea64c4a51c47c4669d190111e7b5e5');
    const sigBuyer = buyerAccount.sign(buyerMsg);
    sigBuyer.messageHash.should.be.equal('0xeb0feff7cbf76cd8f6a6bb07b2d92305e1978c66a157b7738e249689682942f7');
    sigBuyer.signature.should.be.equal('0x7c6b08dfff430bd5dd1785463846f3961f3844b9b4d1cccc941ad2d5441b4496556ffc4518f9be660e2c34ba3d74ef67665af727c25eae6758695354b36462f71b');
  });

  
  // ------------------------------------------------------------------------------------ 
  // ------------------------------------------------------------------------------------ 
  // ------------------------------------------------------------------------------------ 
  // ----------------------------------------------------------------- TEAMS 
  // ------------------------------------------------------------------------------------
  // ------------------------------------------------------------------------------------
  // ------------------------------------------------------------------------------------
  

  
  // *************************************************************************
  // *********************************   TEST  *******************************
  // *************************************************************************
  
  
  it("teams: completes a MAKE_AN_OFFER via MTXs", async () => {
    // now, sellerRnd is fixed by offerer
    offererRnd = 23987435;
    offerValidUntil = now.toNumber() + 3600; // valid for an hour
    const validUntil = now.toNumber() + 3000 + AUCTION_TIME; // this is, at most, offerValidUntil + AUCTION_TIME
    
    tx, sellerHiddenPrice = await freezeTeam(currencyId, price, offererRnd, validUntil, sellerTeamId, sellerAccount).should.be.fulfilled;
    isTeamFrozen = await market.isTeamFrozen(sellerTeamId.toNumber()).should.be.fulfilled;
    isTeamFrozen.should.be.equal(true);
    truffleAssert.eventEmitted(tx, "TeamFreeze", (event) => {
      return event.teamId.should.be.bignumber.equal(sellerTeamId) && event.frozen.should.be.equal(true);
    });
    
    tx = await completeTeamAuction(
      currencyId, price, offererRnd, offerValidUntil, sellerTeamId, 
      extraPrice = 0, buyerRnd = 0, isOffer2StartAuctionSig = true, isOffer2StartAuctionBC = true, buyerAccount
    ).should.be.fulfilled;
  });
  

  // *************************************************************************
  // *********************************   TEST  *******************************
  // *************************************************************************
  
  
  it("teams: fails a MAKE_AN_OFFER via MTXs because offerValidUntil had expired", async () => {
    // now, sellerRnd is fixed by offerer
    offererRnd = 23987435;
    offerValidUntil = now.toNumber() + 3600; // valid for an hour
    const validUntil = now.toNumber() + 3601 + AUCTION_TIME; // this is, at most, offerValidUntil + AUCTION_TIME

    tx, sellerHiddenPrice = await freezeTeam(currencyId, price, offererRnd, validUntil, sellerTeamId, sellerAccount).should.be.fulfilled;
    isTeamFrozen = await market.isTeamFrozen(sellerTeamId.toNumber()).should.be.fulfilled;
    isTeamFrozen.should.be.equal(true);
    truffleAssert.eventEmitted(tx, "TeamFreeze", (event) => {
      return event.teamId.should.be.bignumber.equal(sellerTeamId) && event.frozen.should.be.equal(true);
    });
    
    tx = await completeTeamAuction(
      currencyId, price, offererRnd, offerValidUntil, sellerTeamId, 
      extraPrice = 0, buyerRnd = 0, isOffer2StartAuctionSig = true, isOffer2StartAuctionBC = true, buyerAccount
    ).should.be.rejected;
  });

  // *************************************************************************
  // *********************************   TEST  *******************************
  // *************************************************************************
  
  
  it("teams: fails a MAKE_AN_OFFER via MTXs because validUntil is too large", async () => {
    validUntil = now.toNumber() + 3600*24*2; // two days

    sigSeller = await signPutAssetForSaleMTx(
      currencyId,
      price,
      offererRnd, // he reuses the rnd provided
      validUntil, 
      sellerTeamId.toNumber(),
      sellerAccount
    );


    // First of all, Freeverse and Buyer check the signature
    // In this case, using web3:
    recoveredSellerAddr = await web3.eth.accounts.recover(sigSeller);
    recoveredSellerAddr.should.be.equal(sellerAccount.address);

    // The correctness of the seller message can also be checked in the BC:
    const sellerHiddenPrice = concatHash(
      ["uint8", "uint256", "uint256"],
      [currencyId, price, offererRnd]
    );
    sellerTxMsgBC = await market.buildPutAssetForSaleTxMsg(sellerHiddenPrice, validUntil, sellerTeamId.toNumber()).should.be.fulfilled;
    sellerTxMsgBC.should.be.equal(sigSeller.message);

    // Then, the buyer builds a message to sign
    let isTeamFrozen = await market.isTeamFrozen(sellerTeamId.toNumber()).should.be.fulfilled;
    isTeamFrozen.should.be.equal(false);

    // and send the Freeze TX. 
    const sigSellerMsgRS = [
      sigSeller.messageHash,
      sigSeller.r,
      sigSeller.s,
    ];

    // we can double-check that it would work
    ok = await market.areFreezeTeamRequirementsOK(
      sellerHiddenPrice,
      validUntil,
      sellerTeamId.toNumber(),
      sigSellerMsgRS,
      sigSeller.v
    ).should.be.fulfilled;
    ok.should.be.equal(false);
    
    // and finally do the freeze 
    tx = await market.freezeTeam(
      sellerHiddenPrice,
      validUntil,
      sellerTeamId.toNumber(),
      sigSellerMsgRS,
      sigSeller.v
    ).should.be.rejected;
  });
  
  
  // *************************************************************************
  // *********************************   TEST  *******************************
  // *************************************************************************
  
  it("teams: completes a PUT_FOR_SALE and AGREE_TO_BUY via MTXs", async () => {
    // 1. buyer's mobile app sends to Freeverse: sigBuyer AND params (currencyId, price, ....)
    // 2. Freeverse checks signature and returns to buyer: OK, failed
    // 3. Freeverse advertises to owner that there is an offer to buy his asset at price
    // 4. seller's mobile app sends to Freeverse: sigSeller and params
    // 5. Freeverse checks signature and returns to seller: OK, failed
    // 6. Freeverse FREEZES the player by sending a TX to the BLOCKCHAIN
    // 7. If freeze went OK:
    //          urges buyer to complete payment
    //    If freeze not OK (he probably sold the player in a different market)
    //          tells the buyer to forget about this player
    // 8. Freeverse receives confirmation from Paypal, Apple, GooglePay... of payment buyer -> seller
    // 9. Freeverse COMPLETES TRANSFER OF PLAYER USING BLOCKCHAIN

    tx, sellerHiddenPrice = await freezeTeam(currencyId, price, sellerRnd, validUntil, sellerTeamId, sellerAccount).should.be.fulfilled;
    isTeamFrozen = await market.isTeamFrozen(sellerTeamId.toNumber()).should.be.fulfilled;
    isTeamFrozen.should.be.equal(true);
    truffleAssert.eventEmitted(tx, "TeamFreeze", (event) => {
      return event.teamId.should.be.bignumber.equal(sellerTeamId) && event.frozen.should.be.equal(true);
    });
    
    tx = await completeTeamAuction(
      currencyId, price, sellerRnd, validUntil, sellerTeamId, 
      extraPrice, buyerRnd, isOffer2StartAuctionSig = false, isOffer2StartAuctionBC = false, buyerAccount
    ).should.be.fulfilled;
    
    truffleAssert.eventEmitted(tx, "TeamFreeze", (event) => {
      return event.teamId.should.be.bignumber.equal(sellerTeamId) && event.frozen.should.be.equal(false);
    });

    let finalOwner = await assets.getOwnerTeam(sellerTeamId.toNumber()).should.be.fulfilled;
    finalOwner.should.be.equal(buyerAccount.address);
  });

  // *************************************************************************
  // *********************************   TEST  *******************************
  // *************************************************************************
  
  it("teams: fails a PUT_FOR_SALE and AGREE_TO_BUY via MTXs because isOffer2StartAuction is not correctly set ", async () => {
    tx, sellerHiddenPrice = await freezeTeam(currencyId, price, sellerRnd, validUntil, sellerTeamId, sellerAccount).should.be.fulfilled;
    isTeamFrozen = await market.isTeamFrozen(sellerTeamId.toNumber()).should.be.fulfilled;
    isTeamFrozen.should.be.equal(true);
    truffleAssert.eventEmitted(tx, "TeamFreeze", (event) => {
      return event.teamId.should.be.bignumber.equal(sellerTeamId) && event.frozen.should.be.equal(true);
    });
    
    tx = await completeTeamAuction(
      currencyId, price, sellerRnd, validUntil, sellerTeamId, 
      extraPrice, buyerRnd, isOffer2StartAuctionSig = false, isOffer2StartAuctionBC = true, buyerAccount
    ).should.be.rejected;    
  });

  // // ------------------------------------------------------------------------------------ 
  // // ------------------------------------------------------------------------------------ 
  // // ------------------------------------------------------------------------------------ 
  // // ----------------------------------------------------------------- PLAYERS 
  // // ------------------------------------------------------------------------------------
  // // ------------------------------------------------------------------------------------
  // // ------------------------------------------------------------------------------------
  
  
  
  
  // *************************************************************************
  // *********************************   TEST  *******************************
  // *************************************************************************
  
  
  it("players: completes a MAKE_AN_OFFER via MTXs", async () => {
    // now, sellerRnd is fixed by offerer
    offererRnd = 23987435;
    offerValidUntil = now.toNumber() + 3600; // valid for an hour
    const validUntil = now.toNumber() + 3000 + AUCTION_TIME; // this is, at most, offerValidUntil + AUCTION_TIME

    tx, sellerHiddenPrice = await freezePlayer(currencyId, price, offererRnd, validUntil, playerId, sellerAccount).should.be.fulfilled;
    isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
    isPlayerFrozen.should.be.equal(true);
    truffleAssert.eventEmitted(tx, "PlayerFreeze", (event) => {
      return event.playerId.should.be.bignumber.equal(playerId) && event.frozen.should.be.equal(true);
    });

    // the MTX was actually created before the seller put the asset for sale, but it is used now to complete the auction  
    tx = await completePlayerAuction(
      currencyId, price,  offererRnd, offerValidUntil, playerId, 
      extraPrice = 0, buyerRnd = 0, isOffer2StartAuctionSig = true, isOffer2StartAuctionBC = true, buyerTeamId, buyerAccount
    ).should.be.fulfilled;

    truffleAssert.eventEmitted(tx, "PlayerFreeze", (event) => {
      return event.playerId.should.be.bignumber.equal(playerId) && event.frozen.should.be.equal(false);
    });

    let finalOwner = await assets.getOwnerPlayer(playerId).should.be.fulfilled;
    finalOwner.should.be.equal(buyerAccount.address);
  });
  
  // *************************************************************************
  // *********************************   TEST  *******************************
  // *************************************************************************
  
  
  it("players: fails a MAKE_AN_OFFER via MTXs because offerValidUntil had expired", async () => {
    // now, sellerRnd is fixed by offerer
    offererRnd = 23987435;
    offerValidUntil = now.toNumber() + 3600; // valid for an hour
    const validUntil = now.toNumber() + 3601 + AUCTION_TIME; // this is, at most, offerValidUntil + AUCTION_TIME

    tx, sellerHiddenPrice = await freezePlayer(currencyId, price, offererRnd, validUntil, playerId, sellerAccount).should.be.fulfilled;
    isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
    isPlayerFrozen.should.be.equal(true);
    truffleAssert.eventEmitted(tx, "PlayerFreeze", (event) => {
      return event.playerId.should.be.bignumber.equal(playerId) && event.frozen.should.be.equal(true);
    });

    // the MTX was actually created before the seller put the asset for sale, but it is used now to complete the auction  
    tx = await completePlayerAuction(
      currencyId, price,  offererRnd, offerValidUntil, playerId, 
      extraPrice = 0, buyerRnd = 0, isOffer2StartAuctionSig = true, isOffer2StartAuctionBC = true, buyerTeamId, buyerAccount
    ).should.be.rejected;
    
  });
  
  // *************************************************************************
  // *********************************   TEST  *******************************
  // *************************************************************************
  
  
  it("players: fails a MAKE_AN_OFFER via MTXs because validUntil is too large", async () => {
    tx, sellerHiddenPrice = await freezePlayer(currencyId, price, sellerRnd, validUntil, playerId, sellerAccount).should.be.fulfilled;
    validUntil = now.toNumber() + 3600*24*2; // two days
    tx, sellerHiddenPrice = await freezePlayer(currencyId, price, sellerRnd, validUntil, playerId, sellerAccount).should.be.rejected;
  });
  
  
  
  // *************************************************************************
  // *********************************   TEST  *******************************
  // *************************************************************************
  
  it("players: completes a PUT_FOR_SALE and AGREE_TO_BUY via MTXs", async () => {
    // 1. buyer's mobile app sends to Freeverse: sigBuyer AND params (currencyId, price, ....)
    // 2. Freeverse checks signature and returns to buyer: OK, failed
    // 3. Freeverse advertises to owner that there is an offer to buy his asset at price
    // 4. seller's mobile app sends to Freeverse: sigSeller and params
    // 5. Freeverse checks signature and returns to seller: OK, failed
    // 6. Freeverse FREEZES the player by sending a TX to the BLOCKCHAIN
    // 7. If freeze went OK:
    //          urges buyer to complete payment
    //    If freeze not OK (he probably sold the player in a different market)
    //          tells the buyer to forget about this player
    // 8. Freeverse receives confirmation from Paypal, Apple, GooglePay... of payment buyer -> seller
    // 9. Freeverse COMPLETES TRANSFER OF PLAYER USING BLOCKCHAIN

    tx, sellerHiddenPrice = await freezePlayer(currencyId, price, sellerRnd, validUntil, playerId, sellerAccount).should.be.fulfilled;
    isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
    isPlayerFrozen.should.be.equal(true);
    truffleAssert.eventEmitted(tx, "PlayerFreeze", (event) => {
      return event.playerId.should.be.bignumber.equal(playerId) && event.frozen.should.be.equal(true);
    });
    
    tx = await completePlayerAuction(
      currencyId, price,  sellerRnd, validUntil, playerId, 
      extraPrice, buyerRnd, isOffer2StartAuctionSig = false, isOffer2StartAuctionBC = false, buyerTeamId, buyerAccount
    ).should.be.fulfilled;

    truffleAssert.eventEmitted(tx, "PlayerFreeze", (event) => {
      return event.playerId.should.be.bignumber.equal(playerId) && event.frozen.should.be.equal(false);
    });

    let finalOwner = await assets.getOwnerPlayer(playerId).should.be.fulfilled;
    finalOwner.should.be.equal(buyerAccount.address);
  });

  // *************************************************************************
  // *********************************   TEST  *******************************
  // *************************************************************************
  
  it("players: fails a PUT_FOR_SALE and AGREE_TO_BUY via MTXs because isOffer2StartAuction is not correctly set ", async () => {

    tx, sellerHiddenPrice = await freezePlayer(currencyId, price, sellerRnd, validUntil, playerId, sellerAccount).should.be.fulfilled;
    isPlayerFrozen = await market.isPlayerFrozen(playerId).should.be.fulfilled;
    isPlayerFrozen.should.be.equal(true);
    truffleAssert.eventEmitted(tx, "PlayerFreeze", (event) => {
      return event.playerId.should.be.bignumber.equal(playerId) && event.frozen.should.be.equal(true);
    });
    tx = await completePlayerAuction(
      currencyId, price,  sellerRnd, validUntil, playerId, 
      extraPrice, buyerRnd, isOffer2StartAuctionSig = false, isOffer2StartAuctionBC = true, buyerTeamId, buyerAccount
    ).should.be.rejected;
  });
  
  it("test accounts from truffle and web3", async () => {
    accountsWeb3 = await web3.eth.getAccounts().should.be.fulfilled;
    accountsWeb3[0].should.be.equal(accounts[0]);
  });
});
