const BN = require("bn.js");
require("chai")
  .use(require("chai-as-promised"))
  .use(require("chai-bn")(BN))
  .should();
// const truffleAssert = require("truffle-assertions");

const FreezableAssets = artifacts.require("FreezableAssets");
const PlayerStateLib = artifacts.require("PlayerState");
const AbiTesting = artifacts.require('AbiTesting');

// THE 2 MAIN API FUNCTIONS: signPutForSaleMTx & signAgreeToBuyMTx:
// - the 'rnd' number must be a random generated by the Seller's endpoint. It has 2 purposes:
// - ... i) distinguish different put-for-sale MTXs 
// - ... ii) hide the price of the sale when we communicate with the BC (only hashed-prices appear there, with 'rnd' acting as salt)
function signPutForSaleMTx(currencyId, price, rnd, validUntil, playerId, typeOfTX, sellerAccount) {
  const privHash = concatHash(
      ['uint8', 'uint256', 'uint256'],
      [currencyId, price, rnd]
  )
  const sellerTxMsg = concatHash(
      ['bytes32', 'uint256', 'uint256', 'uint8'],
      [privHash, validUntil, playerId, typeOfTX]
  )
  const sigSeller = sellerAccount.sign(sellerTxMsg);
  sigSeller.message.should.be.equal(sellerTxMsg);
  return sigSeller;
}

// Buyer explicitly agrees to all of sellers data, and only adds the 'buyerTeamId' to it.
async function signAgreeToBuyMTx(currencyId, price, rnd, validUntil, playerId, typeOfTX, buyerTeamId, buyerAccount) {
  const privHash = concatHash(
      ['uint8', 'uint256', 'uint256'],
      [currencyId, price, rnd]
  )
  const sellerTxMsg = concatHash(
      ['bytes32', 'uint256', 'uint256', 'uint8'],
      [privHash, validUntil, playerId, typeOfTX]
  )
  const sellerTxHash = getMessageHash(sellerTxMsg);
  buyerTxMsg = concatHash(
      ['bytes32', 'uint256'],
      [sellerTxHash, buyerTeamId]
  )
  const sigBuyer = await buyerAccount.sign(buyerTxMsg);
  return sigBuyer;
}

function buildOfferToBuyMsg(currencyId, price, rnd, validUntil, playerId, buyerTeamId, typeOfTX) {
  const privHash = concatHash(
      ['uint8', 'uint256', 'uint256'],
      [currencyId, price, rnd]
  )
  const buyerTxMsg = concatHash(
      ['bytes32', 'uint256', 'uint256', 'uint256', 'uint8'],
      [privHash, validUntil, playerId, buyerTeamId, typeOfTX]
  )
  return buyerTxMsg;
}

async function signOfferToBuyMTx(currencyId, price, rnd, validUntil, playerId, buyerTeamId, typeOfTX, buyerAccount) {
  const buyerTxMsg = buildOfferToBuyMsg(currencyId, price, rnd, validUntil, playerId, buyerTeamId, typeOfTX);
  const sigBuyer = await buyerAccount.sign(buyerTxMsg);
  sigBuyer.message.should.be.equal(buyerTxMsg);
  return sigBuyer;
}

// Buyer explicitly agrees to all of sellers data, and only adds the 'buyerTeamId' to it.
async function signAgreeToSellMTx(currencyId, price, rnd, validUntil, playerId, buyerTeamId, typeOfTX, sellerAccount) {
  const sellerTxMsg = buildOfferToBuyMsg(currencyId, price, rnd, validUntil, playerId, buyerTeamId, typeOfTX);
  const sigSeller = await sellerAccount.sign(sellerTxMsg);
  return sigSeller;
}

// The two needed helpers: concatHash & getMessageHash
function concatHash(types, vals) {
    assert(types.length == vals.length, "Length of inputs should be equal")
    return web3.utils.keccak256(
        web3.eth.abi.encodeParameters(types, vals)
    )
}

// this function does the crazy thing solidity does for hex...
function getMessageHash(msg)Â {
    assert(web3.utils.isHexStrict(msg), "We currently only support signing hashes, which are 0x stating hex numbers")
    message = web3.utils.hexToBytes(msg);
    var messageBuffer = Buffer.from(message);
    var preamble = "\x19Ethereum Signed Message:\n" + message.length;
    var preambleBuffer = Buffer.from(preamble);
    var ethMessage = Buffer.concat([preambleBuffer, messageBuffer]);
    return web3.utils.keccak256(ethMessage);
}

contract("FreezableAssets", accounts => {
  let playerStateLib = null;
  let verifierLib = null;
  let abiTestingLib = null;
  let PLAYERS_PER_TEAM_INIT = null;
  const ALICE = accounts[1];
  const BOB = accounts[2];



  beforeEach(async () => {
    playerStateLib = await PlayerStateLib.new().should.be.fulfilled;
    verifierLib = await FreezableAssets.new(playerStateLib.address).should.be
      .fulfilled;
    abiTestingLib = await AbiTesting.new().should.be.fulfilled;
    PLAYERS_PER_TEAM_INIT = await verifierLib.PLAYERS_PER_TEAM_INIT().should.be.fulfilled;
    PLAYERS_PER_TEAM_INIT = PLAYERS_PER_TEAM_INIT.toNumber();
  });

 
  it("completes a MAKE_AN_OFFER and AGREE_TO_SELL agreement via MTXs and checks that the BC accepts it", async () => {
    // 1. buyer's mobile app sends to Freeverse: sigBuyer AND params (currencyId, price, ....)
    // 2. Freeverse checks signature and returns to buyer: OK, failed
    // 3. Freeverse advertises to owner that there is an offer to buy his asset at price
    // 4. seller's mobile app sends to Freeverse: sigSeller and params
    // 5. Freeverse checks signature and returns to seller: OK, failed
    // 6. Freeverse FREEZES the player by sending a TX to the BLOCKCHAIN
    // 7. If freeze went OK:
    //          urges buyer to complete payment
    //    If freeze not OK (he probably sold the player in a different market)
    //          tells the buyer to forget about this player
    // 8. Freeverse receives confirmation from Paypal, Apple, GooglePay... of payment buyer -> seller
    // 9. Freeverse COMPLETES TRANSFER OF PLAYER USING BLOCKCHAIN

    const sellerAccount = await web3.eth.accounts.create("iamaseller");
    const buyerAccount = await web3.eth.accounts.create("iamabuyer");

    await verifierLib.createTeam("Barca", sellerAccount.address).should.be.fulfilled;
    await verifierLib.createTeam("Madrid", buyerAccount.address).should.be.fulfilled;

    // Define params of the seller, and sign
    let now = await verifierLib.getBlockchainNowTime();
    const validUntil = 2 * now.toNumber();
    const playerId = 10;
    const buyerTeamId = 2;
    const typeOfTX = 2;
    const currencyId = 1;
    const price = 41234;
    const rnd = 42321;

    // mobile app does this:
    sigBuyer = await signOfferToBuyMTx(currencyId, price, rnd, validUntil, playerId, buyerTeamId, typeOfTX, buyerAccount);

    // First of all, Freeverse and Seller check the signature
    // In this case, using web3:
    recoveredBuyerAddr = await web3.eth.accounts.recover(sigBuyer);
    recoveredBuyerAddr.should.be.equal(buyerAccount.address);

    // It can also be checked in the BC:
    const privHash = await verifierLib.hashPrivateMsg(currencyId, price, rnd).should.be.fulfilled;
    buyerTxMsgBC = await verifierLib.buildOfferToBuyTxMsg(privHash, validUntil, playerId, buyerTeamId, typeOfTX).should.be.fulfilled;
    buyerTxMsgBC.should.be.equal(sigBuyer.message);

    // The seller agrees, and builds and signs a message
    let isFrozen = await verifierLib.isFrozen(playerId).should.be.fulfilled;
    isFrozen.should.be.equal(false);

    let sigSeller = await signAgreeToSellMTx(currencyId, price, rnd, validUntil, playerId, buyerTeamId, typeOfTX, sellerAccount).should.be.fulfilled;

    // in this case, both the buyer and the seller sign exactly the same Tx message.
    sigSeller.messageHash.should.be.equal(sigBuyer.messageHash)

    // // Freeverse checks the signature
    recoveredSellerAddr = await web3.eth.accounts.recover(sigSeller);
    recoveredSellerAddr.should.be.equal(sellerAccount.address);

    // // and send the Freeze TX. If it finishes, it went through.
    const sigs = [
      sigSeller.messageHash,
      sigSeller.r,
      sigSeller.s,
      sigBuyer.messageHash,
      sigBuyer.r,
      sigBuyer.s
    ];
    const vs = [sigSeller.v, sigBuyer.v];
    await verifierLib.freezePlayer(
      privHash,
      validUntil,
      playerId,
      typeOfTX,
      buyerTeamId,
      sigs,
      vs
    ).should.be.fulfilled;

    isFrozen = await verifierLib.isFrozen(playerId).should.be.fulfilled;
    isFrozen.should.be.equal(true);
    
    // Freeverse waits until actual money has been transferred between users, and completes sale
    let initOwner = await verifierLib.getPlayerOwner(playerId).should.be.fulfilled;
    initOwner.should.be.equal(sellerAccount.address);
    await verifierLib.completeFreeze(playerId).should.be.fulfilled;
    let finalOwner = await verifierLib.getPlayerOwner(playerId).should.be.fulfilled;
    finalOwner.should.be.equal(buyerAccount.address);
  });

  it("player owner", async () => {
    // create a team and give it to ALICE
    await verifierLib.createTeam("Barca", ALICE).should.be.fulfilled;
    await verifierLib.getPlayerOwner(0).should.be.rejected;
    let owner = await verifierLib.getPlayerOwner(1).should.be.fulfilled;
    owner.should.be.equal(ALICE);
    owner = await verifierLib.getPlayerOwner(PLAYERS_PER_TEAM_INIT).should.be.fulfilled;
    owner.should.be.equal(ALICE);
    await verifierLib.getPlayerOwner(PLAYERS_PER_TEAM_INIT+1).should.be.rejected;
    // create a team and GIVE it to BOB
    await verifierLib.createTeam("Madrid", BOB).should.be.fulfilled;
    owner = await verifierLib.getPlayerOwner(PLAYERS_PER_TEAM_INIT+1).should.be.fulfilled;
    owner.should.not.equal(ALICE); // the player is not owned by ALICE
    owner.should.be.equal(BOB);
  });

  it('deterministic sign', async () => {
    const sellerAccount = web3.eth.accounts.privateKeyToAccount('0x3B878F7892FBBFA30C8AED1DF317C19B853685E707C2CF0EE1927DC516060A54');
    sellerAccount.address.should.be.equal('0x291081e5a1bF0b9dF6633e4868C88e1FA48900e7');

    // Define params of the seller, and sign
    const validUntil = 2;
    const playerId = 10;
    const typeOfTX = 1;
    const currencyId = 1;
    const price = 41234;
    const rnd = 42321;

    const privateHash = await verifierLib.hashPrivateMsg(currencyId, price, rnd).should.be.fulfilled;
    privateHash.should.be.equal('0x4200de738160a9e6b8f69648fbb7feb323f73fac5acff1b7bb546bb7ac3591fa');
    const message = await verifierLib.buildPutForSaleTxMsg(privateHash, validUntil, playerId, typeOfTX).should.be.fulfilled;
    message.should.be.equal('0xaadf12b0660c9a10f8e9b0baca620d55d648bcabb0718dade3b39c676f76cc4d');
    const sigSeller = sellerAccount.sign(message);
    sigSeller.messageHash.should.be.equal('0x3f6c78029ebde952d76a5b4ffe415d074eb256156d0f0b44045057e809add696');
    sigSeller.signature.should.be.equal('0xbd7b906b16bfab0ac6007bb4699e82324e89f6d9f6a0e8476cb66bcf0c6dc013650c1667574a3821d7a2681b0b68e8615eeae4d05061ce54f94dce2f1ba8f3351b');
  })

  it("completes a PUT_FOR_SALE and AGREE_TO_BUY agreement via MTXs and checks that the BC accepts it", async () => {
    // 1. seller's mobile app sends to Freeverse: sigSeller AND params (currencyId, price, ....)
    // 2. Freeverse checks signature and returns to seller: OK, failed
    // 3. Freeverse advertises to everyone that playerId is for sale at price
    // 4. buyer's mobile app sends to Freeverse: buySeller and params
    // 5. Freeverse checks signature and returns to buyer: OK, failed
    // 6. Freeverse FREEZES the player by sending a TX to the BLOCKCHAIN
    // 7. If freeze went OK:
    //          urges buyer to complete payment
    //    If freeze not OK (he probably sold the player in a different market)
    //          tells the buyer to forget about this player
    // 8. Freeverse receives confirmation from Paypal, Apple, GooglePay... of payment buyer -> seller
    // 9. Freeverse COMPLETES TRANSFER OF PLAYER USING BLOCKCHAIN

    const sellerAccount = await web3.eth.accounts.create("iamaseller");
    const buyerAccount = await web3.eth.accounts.create("iamabuyer");

    await verifierLib.createTeam("Barca", sellerAccount.address).should.be.fulfilled;
    await verifierLib.createTeam("Madrid", buyerAccount.address).should.be.fulfilled;

    // Define params of the seller, and sign
    let now = await verifierLib.getBlockchainNowTime();
    const validUntil = 2 * now.toNumber();
    const playerId = 10;
    const typeOfTX = 1;
    const currencyId = 1;
    const price = 41234;
    const rnd = 42321;

    // mobile app does this:
    sigSeller = await signPutForSaleMTx(
      currencyId,
      price,
      rnd,
      validUntil,
      playerId,
      typeOfTX,
      sellerAccount
    );

    // First of all, Freeverse and Buyer check the signature
    // In this case, using web3:
    recoveredSellerAddr = await web3.eth.accounts.recover(sigSeller);
    recoveredSellerAddr.should.be.equal(sellerAccount.address);
    recoveredSellerAddr = await web3.eth.accounts.recover(sigSeller.messageHash, sigSeller.signature, true);
    recoveredSellerAddr.should.be.equal(sellerAccount.address);
    recoveredSellerAddr = await web3.eth.accounts.recover(sigSeller.messageHash, sigSeller.v, sigSeller.r, sigSeller.s, true);
    recoveredSellerAddr.should.be.equal(sellerAccount.address);

    // recovering r,s,v from the signature
    const signature = sigSeller.signature.substr(2); //remove 0x
    const r = '0x' + signature.slice(0, 64)
    const s = '0x' + signature.slice(64, 128)
    const v = '0x' + signature.slice(128, 130)
    recoveredSellerAddr = await web3.eth.accounts.recover(sigSeller.messageHash, v, r, s, true);
    recoveredSellerAddr.should.be.equal(sellerAccount.address);

    // It can also be checked in the BC:
    const privHash = concatHash(
      ["uint8", "uint256", "uint256"],
      [currencyId, price, rnd]
    );
    sellerTxMsgBC = await verifierLib.buildPutForSaleTxMsg(
      privHash,
      validUntil,
      playerId,
      typeOfTX
    ).should.be.fulfilled;
    sellerTxMsgBC.should.be.equal(sigSeller.message);

    // Then, the buyer builds a message to sign
    const buyerTeamId = 2;

    let isFrozen = await verifierLib.isFrozen(playerId).should.be.fulfilled;
    isFrozen.should.be.equal(false);

    let sigBuyer = await signAgreeToBuyMTx(
      currencyId,
      price,
      rnd,
      validUntil,
      playerId,
      typeOfTX,
      buyerTeamId,
      buyerAccount
    ).should.be.fulfilled;

    isFrozen = await verifierLib.isFrozen(playerId).should.be.fulfilled;
    isFrozen.should.be.equal(false);

    // Freeverse checks the signature
    recoveredBuyerAddr = await web3.eth.accounts.recover(sigBuyer);
    recoveredBuyerAddr.should.be.equal(buyerAccount.address);

    // and send the Freeze TX. If it finishes, it went through.
    const sigs = [
      sigSeller.messageHash,
      sigSeller.r,
      sigSeller.s,
      sigBuyer.messageHash,
      sigBuyer.r,
      sigBuyer.s
    ];
    const vs = [sigSeller.v, sigBuyer.v];
    await verifierLib.freezePlayer(
      privHash,
      validUntil,
      playerId,
      typeOfTX,
      buyerTeamId,
      sigs,
      vs
    ).should.be.fulfilled;

    isFrozen = await verifierLib.isFrozen(playerId).should.be.fulfilled;
    isFrozen.should.be.equal(true);
    
    // Freeverse waits until actual money has been transferred between users, and completes sale
    let initOwner = await verifierLib.getPlayerOwner(playerId).should.be.fulfilled;
    initOwner.should.be.equal(sellerAccount.address);
    await verifierLib.completeFreeze(playerId).should.be.fulfilled;
    let finalOwner = await verifierLib.getPlayerOwner(playerId).should.be.fulfilled;
    finalOwner.should.be.equal(buyerAccount.address);
  });

  it("completes a PUT_FOR_SALE and AGREE_TO_BUY via MTXs but cancels because payment went wrong", async () => {
    const sellerAccount = await web3.eth.accounts.create("iamaseller");
    const buyerAccount = await web3.eth.accounts.create("iamabuyer");
    await verifierLib.createTeam("Barca", sellerAccount.address).should.be.fulfilled;
    await verifierLib.createTeam("Madrid", buyerAccount.address).should.be.fulfilled;

    // Define params of the seller, and sign
    let now = await verifierLib.getBlockchainNowTime();
    const validUntil = 2 * now.toNumber();
    const playerId = 10;
    const typeOfTX = 1;
    const currencyId = 1;
    const price = 41234;
    const rnd = 42321;

    // mobile app does this:
    sigSeller = await signPutForSaleMTx(
      currencyId,
      price,
      rnd,
      validUntil,
      playerId,
      typeOfTX,
      sellerAccount
    );

    // First of all, Freeverse and Buyer check the signature
    // In this case, using web3:
    recoveredSellerAddr = await web3.eth.accounts.recover(sigSeller);
    recoveredSellerAddr.should.be.equal(sellerAccount.address);

    // It can also be checked in the BC:
    const privHash = concatHash(
      ["uint8", "uint256", "uint256"],
      [currencyId, price, rnd]
    );
    sellerTxMsgBC = await verifierLib.buildPutForSaleTxMsg(
      privHash,
      validUntil,
      playerId,
      typeOfTX
    ).should.be.fulfilled;
    sellerTxMsgBC.should.be.equal(sigSeller.message);

    // Then, the buyer builds a message to sign
    const buyerTeamId = 2;

    let isFrozen = await verifierLib.isFrozen(playerId).should.be.fulfilled;
    isFrozen.should.be.equal(false);

    let sigBuyer = await signAgreeToBuyMTx(
      currencyId,
      price,
      rnd,
      validUntil,
      playerId,
      typeOfTX,
      buyerTeamId,
      buyerAccount
    ).should.be.fulfilled;

    isFrozen = await verifierLib.isFrozen(playerId).should.be.fulfilled;
    isFrozen.should.be.equal(false);

    // Freeverse checks the signature
    recoveredBuyerAddr = await web3.eth.accounts.recover(sigBuyer);
    recoveredBuyerAddr.should.be.equal(buyerAccount.address);

    // and send the Freeze TX. If it finishes, it went through.
    const sigs = [
      sigSeller.messageHash,
      sigSeller.r,
      sigSeller.s,
      sigBuyer.messageHash,
      sigBuyer.r,
      sigBuyer.s
    ];
    const vs = [sigSeller.v, sigBuyer.v];
    await verifierLib.freezePlayer(
      privHash,
      validUntil,
      playerId,
      typeOfTX,
      buyerTeamId,
      sigs,
      vs
    ).should.be.fulfilled;

    isFrozen = await verifierLib.isFrozen(playerId).should.be.fulfilled;
    isFrozen.should.be.equal(true);
    
    // Freeverse waits until actual money has been transferred between users, and completes sale
    let initOwner = await verifierLib.getPlayerOwner(playerId).should.be.fulfilled;
    initOwner.should.be.equal(sellerAccount.address);
    await verifierLib.cancelFreeze(playerId).should.be.fulfilled;
    let finalOwner = await verifierLib.getPlayerOwner(playerId).should.be.fulfilled;
    finalOwner.should.be.equal(initOwner);
  });
    

  it("test accounts from truffle and web3", async () => {
    accountsWeb3 = await web3.eth.getAccounts().should.be.fulfilled;
    accountsWeb3[0].should.be.equal(accounts[0]);
  });

  it("adress type: test abi encode and hash web3 vs solidity", async () => {
    val = accounts[0];
    type = "address";
    abiFromSolidity = await abiTestingLib.getAbiAddress(val).should.be.fulfilled;
    abiFromSolidity.should.be.equal(web3.eth.abi.encodeParameter(type, val));
    hashPacked = await abiTestingLib.getHashOfAddress(accounts[0]).should.be
      .fulfilled;
    hashPacked.should.be.equal(concatHash([type], [val]));
  });

  it("uint8 type: test abi encode and hash web3 vs solidity", async () => {
    val = 17;
    type = "uint8";
    abiFromSolidity = await abiTestingLib.getAbiUint8(val);
    abiFromSolidity.should.be.equal(web3.eth.abi.encodeParameter(type, val));
    hashPacked = await abiTestingLib.getHashOfUint8(val).should.be.fulfilled;
    hashPacked.should.be.equal(concatHash([type], [val]));
  });

  it("uint256 type: test abi encode and hash web3 vs solidity", async () => {
    val = 17;
    type = "uint256";
    abiFromSolidity = await abiTestingLib.getAbiUint256(val);
    abiFromSolidity.should.be.equal(web3.eth.abi.encodeParameter(type, val));
    hashPacked = await abiTestingLib.getHashOfUint256(val).should.be.fulfilled;
    hashPacked.should.be.equal(concatHash([type], [val]));
  });

  it("bytes32 type: test abi encode and hash web3 vs solidity", async () => {
    val = web3.utils.toHex(17);
    type = "bytes32";
    abiFromSolidity = await abiTestingLib.getAbiBytes32(val);
    abiFromSolidity.should.be.equal(web3.eth.abi.encodeParameter(type, val));
    hashPacked = await abiTestingLib.getHashOfBytes32(val).should.be.fulfilled;
    hashPacked.should.be.equal(concatHash([type], [val]));
  });

  it("concat: test abi encode of two args, web3 vs solidity", async () => {
    val1 = web3.utils.toHex(17);
    val2 = web3.utils.toHex(1227);
    type1 = "bytes32";
    type2 = "bytes32";
    abiFromSolidity = await abiTestingLib.getAbiBytes32AndBytes32(val1, val2);
    abiFromSolidity.should.be.equal(
      web3.eth.abi.encodeParameters([type1, type2], [val1, val2])
    );
  });

  it("signs a hex-like txt message", async () => {
    const newAccount = await web3.eth.accounts.create("entropytoni");
    let privateKey = newAccount.privateKey;
    let msg = "I really did make this message";
    msg = web3.utils.toHex(msg);
    let sig1 = await newAccount.sign(msg);
    let sig2 = await web3.eth.accounts.sign(msg, privateKey);
    console.log("We start with this msg: " + msg);
    console.log(
      "...and sign with either web3.eth.accounts.sign(msg, privKey) or simply account.sign(msg)"
    );
    console.log("...but both have the same messageHash = " + sig1.messageHash);
    sig1.messageHash.should.be.equal(sig2.messageHash);
    sig2.message.should.be.equal(sig1.message);
    console.log(
      "...so that sig1 retains the original data: sig1.message = " +
        sig1.message
    );
    sig1.message.should.be.equal(msg);
    console.log(
      "Most importantly, the msgHashes can be obtained by prepending Ethereum Signed... and then hashing"
    );
    sig1.messageHash.should.be.equal(getMessageHash(sig1.message));

    // checking signatures now:
    let isSigned = await verifierLib.isSigned(
      accounts[0],
      sig2.messageHash,
      sig2.v,
      sig2.r,
      sig2.s
    ).should.be.fulfilled;
    isSigned.should.be.equal(false);
    isSigned = await verifierLib.isSigned(
      newAccount.address,
      sig1.messageHash,
      sig1.v,
      sig1.r,
      sig1.s
    ).should.be.fulfilled;
    isSigned.should.be.equal(true);
    isSigned = await verifierLib.isSigned(
      newAccount.address,
      sig2.messageHash,
      sig2.v,
      sig2.r,
      sig2.s
    ).should.be.fulfilled;
    isSigned.should.be.equal(true);
    // We can also check the signature with web3, without passing using the BC
    recoveredAddr = await web3.eth.accounts.recover(sig1);
    recoveredAddr.should.be.equal(newAccount.address);
  });
});
