package relay

import (
	"context"
	"crypto/ecdsa"
	"database/sql"
	"encoding/hex"
	"errors"
	"math/big"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/ethclient"
	log "github.com/sirupsen/logrus"

	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/updates"
	"github.com/freeverseio/crypto-soccer/go/relay/storage"
	"github.com/freeverseio/crypto-soccer/go/useractions"
)

type Processor struct {
	client        *ethclient.Client
	privateKey    *ecdsa.PrivateKey
	publicAddress common.Address
	db            *sql.DB
	updates       *updates.Updates
	ipfsURL       string
}

// *****************************************************************************
// public
// *****************************************************************************

func NewProcessor(
	client *ethclient.Client,
	privateKey *ecdsa.PrivateKey,
	db *sql.DB,
	updates *updates.Updates,
	ipfsURL string,
) (*Processor, error) {

	publicKey := privateKey.Public()
	publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
	if !ok {
		return nil, errors.New("error obtaining publicKey")
	}

	publicAddress := crypto.PubkeyToAddress(*publicKeyECDSA)

	return &Processor{
		client,
		privateKey,
		publicAddress,
		db,
		updates,
		ipfsURL,
	}, nil
}

func (p *Processor) Process(tx *sql.Tx) error {
	return p.computeActionsRoot(tx)
}

// *****************************************************************************
// private
// *****************************************************************************
func (p *Processor) computeActionsRoot(tx *sql.Tx) error {
	nonce, err := p.client.PendingNonceAt(context.Background(), p.publicAddress)
	if err != nil {
		return err
	}

	gasPrice, err := p.client.SuggestGasPrice(context.Background())
	if err != nil {
		return err
	}

	auth := bind.NewKeyedTransactor(p.privateKey)
	auth.Nonce = big.NewInt(int64(nonce))
	auth.Value = big.NewInt(0)
	auth.GasPrice = gasPrice

	session := updates.UpdatesSession{
		p.updates,
		bind.CallOpts{},
		*auth,
	}

	if err = storage.CloseVerse(tx); err != nil {
		return err
	}
	verse, err := storage.GetLastVerse(tx)
	if err != nil {
		return err
	}
	actions := useractions.UserActions{}
	if err = actions.PullFromStorage(tx, verse.ID); err != nil {
		return err
	}
	hash, err := actions.Hash()
	if err != nil {
		return err
	}
	cid, err := actions.PushToIpfs(p.ipfsURL)
	if err != nil {
		return err
	}
	var root [32]byte
	copy(root[:], hash)

	log.Infof("[relay] submitActionsRoot root: 0x%v, cid: %v", hex.EncodeToString(root[:]), cid)
	_, err = session.SubmitActionsRoot(root, cid)
	return err
}
