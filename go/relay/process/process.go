package relay

import (
	"context"
	"crypto/ecdsa"
	"database/sql"
	"encoding/hex"
	"errors"
	"time"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/ethclient"
	log "github.com/sirupsen/logrus"

	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/updates"
	"github.com/freeverseio/crypto-soccer/go/relay/storage"
	"github.com/freeverseio/crypto-soccer/go/useractions"
)

type Processor struct {
	client          *ethclient.Client
	updatesContract *updates.Updates
	auth            *bind.TransactOpts
	ipfsURL         string
}

// *****************************************************************************
// public
// *****************************************************************************

func NewProcessor(
	client *ethclient.Client,
	privateKey *ecdsa.PrivateKey,
	db *sql.DB,
	updatesContract *updates.Updates,
	ipfsURL string,
) (*Processor, error) {
	auth := bind.NewKeyedTransactor(privateKey)

	return &Processor{
		client,
		updatesContract,
		auth,
		ipfsURL,
	}, nil
}

func (p *Processor) Process(tx *sql.Tx) error {
	currentVerse, err := p.updatesContract.CurrentVerse(&bind.CallOpts{})
	if err != nil {
		return err
	}
	nextToUpdate, err := p.updatesContract.NextTimeZoneToUpdate(&bind.CallOpts{})
	if err != nil {
		return err
	}
	log.Infof("Staring process of verse %v, timezone %v", currentVerse, nextToUpdate.TimeZone)
	upcomingUserActions, err := useractions.NewFromStorage(tx, storage.UpcomingVerse, int(nextToUpdate.TimeZone))
	if err != nil {
		return err
	}
	upcomingUserActions.UpdateVerse(currentVerse.Uint64())
	hash, err := upcomingUserActions.Hash()
	if err != nil {
		return err
	}
	cid, err := upcomingUserActions.ToIpfs(p.ipfsURL)
	if err != nil {
		return err
	}
	var root [32]byte
	copy(root[:], hash)
	log.Infof("[relay] submitActionsRoot root: 0x%v, cid: %v", hex.EncodeToString(root[:]), cid)
	transaction, err := p.updatesContract.SubmitActionsRoot(p.auth, root, cid)
	if err != nil {
		return err
	}
	_, err = WaitReceipt(p.client, transaction, 10)
	if err != nil {
		return err
	}
	return nil
}

func WaitReceipt(client *ethclient.Client, tx *types.Transaction, timeoutSec uint8) (*types.Receipt, error) {
	receiptTimeout := time.Second * time.Duration(timeoutSec)
	start := time.Now()
	ctx := context.TODO()
	var receipt *types.Receipt

	for receipt == nil && time.Now().Sub(start) < receiptTimeout {
		receipt, err := client.TransactionReceipt(ctx, tx.Hash())
		if err == nil && receipt != nil {
			return receipt, nil
		}
		time.Sleep(200 * time.Millisecond)
	}
	return nil, errors.New("Timeout waiting for receipt")
}
