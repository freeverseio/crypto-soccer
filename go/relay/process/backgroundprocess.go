package relay

import (
	"crypto/ecdsa"
	"time"

	"github.com/ethereum/go-ethereum/ethclient"

	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/updates"
	"github.com/freeverseio/crypto-soccer/go/relay/storage"
)

type BackgroundProcess struct {
	relay     *Processor
	queryStop chan (bool)
	stopped   chan (bool)
	delay     time.Duration
}

func BackgroundProcessNew(
	client *ethclient.Client,
	privateKey *ecdsa.PrivateKey,
	storage *storage.Storage,
	updatesContract *updates.Updates,
	delay time.Duration,
) (*BackgroundProcess, error) {
	processor, err := NewProcessor(client, privateKey, storage, updatesContract)
	if err != nil {
		return nil, err
	}
	return &BackgroundProcess{
		relay:     processor,
		queryStop: make(chan (bool)),
		stopped:   make(chan (bool)),
		delay:     delay,
	}, nil
}

func (b *BackgroundProcess) Process() error {
	err := b.relay.db.Begin()
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			b.relay.db.Rollback()
			return
		}
		b.relay.db.Commit()
	}()
	err = b.relay.Process()
	if err != nil {
		return err
	}
	return nil
}

func (b *BackgroundProcess) Start() {
	go func() {
	L:
		for {
			select {
			case <-b.queryStop:
				break L
			default:
				err := b.Process()
				if err != nil {
					panic(err)
				}
				time.Sleep(b.delay)
			}
		}
		b.stopped <- true
	}()
}

func (b *BackgroundProcess) StopAndJoin() {
	b.queryStop <- true
	<-b.stopped
}
