package consumer

import (
	"database/sql"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/freeverseio/crypto-soccer/go/complementarydata"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/assets"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/updates"
	"github.com/freeverseio/crypto-soccer/go/relay/producer"
	"github.com/freeverseio/crypto-soccer/go/relay/producer/gql"
	"github.com/freeverseio/crypto-soccer/go/relay/producer/gql/input"
	"github.com/freeverseio/crypto-soccer/go/storage/postgres"
	"github.com/freeverseio/crypto-soccer/go/useractions"
	log "github.com/sirupsen/logrus"
)

type Consumer struct {
	ch                        chan interface{}
	client                    *ethclient.Client
	auth                      *bind.TransactOpts
	updatesContract           *updates.Updates
	assetsContract            *assets.Assets
	useractionsPublishService useractions.UserActionsPublishService
	db                        *sql.DB
	complementaryData         complementarydata.ComplementaryData
}

func NewConsumer(
	ch chan interface{},
	client *ethclient.Client,
	auth *bind.TransactOpts,
	updatesContract *updates.Updates,
	assetsContract *assets.Assets,
	useractionsPublishService useractions.UserActionsPublishService,
	db *sql.DB,
) *Consumer {
	return &Consumer{
		ch,
		client,
		auth,
		updatesContract,
		assetsContract,
		useractionsPublishService,
		db,
		complementarydata.ComplementaryData{},
	}
}

func (b *Consumer) Start() {
	firstBotTransfer := NewFirstBotTransfer(b.client, b.auth, b.assetsContract)
	actionsSubmitter := NewActionsSubmitter(b.client, b.auth, b.updatesContract, b.useractionsPublishService)
	for {
		event := <-b.ch
		switch ev := event.(type) {
		case gql.TransferFirstBotToAddrInput:
			log.Infof("[relay|consumer] Trasfer First Bot TX: %v Country: %v to %v", ev.Timezone, ev.CountryIdxInTimezone, ev.Address)
			if err := firstBotTransfer.Process(ev); err != nil {
				log.Error(err)
			}
		case producer.SubmitActionsEvent:
			log.Debug("Relay sumbit action event")
			tx, err := b.db.Begin()
			if err != nil {
				log.Error(err)
				break
			}
			if err = actionsSubmitter.Process(tx); err != nil {
				tx.Rollback()
				log.Error(err)
				break
			}
			if err = tx.Commit(); err != nil {
				log.Error(err)
			}
		case input.SetTeamNameInput:
			log.Infof("[relay|consumer] Set Team %v Name %v", ev.TeamId, ev.Name)
			tx, err := b.db.Begin()
			if err != nil {
				log.Error(err)
				break
			}
			teamStorageService := postgres.NewTeamStorageService(tx)
			if err := SetTeamName(teamStorageService, ev); err != nil {
				tx.Rollback()
				log.Error(err)
				break
			}
			if err := tx.Commit(); err != nil {
				log.Error(err)
			}

		case input.SetTeamManagerNameInput:
			log.Infof("[relay|consumer] Set Team %v Managet Name %v", ev.TeamId, ev.Name)
			tx, err := b.db.Begin()
			if err != nil {
				log.Error(err)
				break
			}
			teamStorageService := postgres.NewTeamStorageService(tx)
			if err := SetTeamManagerName(teamStorageService, ev); err != nil {
				tx.Rollback()
				log.Error(err)
				break
			}
			if err := tx.Commit(); err != nil {
				log.Error(err)
			}
		default:
			log.Errorf("unknown event: %v", event)
		}
	}
}
