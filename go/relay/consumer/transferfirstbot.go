package consumer

import (
	"fmt"
	"math/big"

	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/assets"
	"github.com/freeverseio/crypto-soccer/go/relay/producer/gql"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/ethclient"
)

type TransferFirstBot struct {
	client         *ethclient.Client
	assetsContract *assets.Assets
	auth           *bind.TransactOpts
}

func NewTransferFirstBot(
	client *ethclient.Client,
	auth *bind.TransactOpts,
	assetsContract *assets.Assets,
) *TransferFirstBot {
	return &TransferFirstBot{
		client,
		assetsContract,
		auth,
	}
}

func (b TransferFirstBot) Process(event gql.TransferFirstBotToAddrInput) error {
	timezone := uint8(event.Timezone)
	countryIdxInTimezone, _ := new(big.Int).SetString(event.CountryIdxInTimezone, 10)
	if countryIdxInTimezone == nil {
		return fmt.Errorf("Invalid countryIdxInTimezone %v", event.CountryIdxInTimezone)
	}
	address := common.HexToAddress(event.Address)
	if _, err := b.assetsContract.TransferFirstBotToAddr(b.auth, timezone, countryIdxInTimezone, address); err != nil {
		return err
	}
	return nil
}
