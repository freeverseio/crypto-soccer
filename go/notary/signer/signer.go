package signer

import (
	"crypto/ecdsa"
	"encoding/hex"
	"errors"
	"math/big"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/freeverseio/crypto-soccer/go/contracts"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/market"
	"golang.org/x/crypto/sha3"
)

type Signer struct {
	contracts *contracts.Contracts
	pvr       *ecdsa.PrivateKey
}

func NewSigner(contracts *contracts.Contracts, pvr *ecdsa.PrivateKey) *Signer {
	return &Signer{contracts, pvr}
}

func RSV(signature string) (r [32]byte, s [32]byte, v uint8, err error) {
	if len(signature) != 132 {
		return r, s, v, errors.New("wrong signature length")
	}
	signature = signature[2:] // remove 0x
	vect, err := hex.DecodeString(signature[0:64])
	if err != nil {
		return r, s, v, err
	}
	copy(r[:], vect)
	vect, err = hex.DecodeString(signature[64:128])
	if err != nil {
		return r, s, v, err
	}
	copy(s[:], vect)
	vect, err = hex.DecodeString(signature[128:130])
	v = vect[0]
	return r, s, v, err
}

func (b *Signer) HashPrivateMsg(currencyId uint8, price *big.Int, rnd *big.Int) ([32]byte, error) {
	privateHash, err := b.contracts.Market.HashPrivateMsg(
		&bind.CallOpts{},
		currencyId,
		price,
		rnd,
	)

	return privateHash, err
}

func HashSellMessage(
	market *market.Market,
	currencyId uint8,
	price *big.Int,
	rnd *big.Int,
	validUntil int64,
	playerId *big.Int,
) ([32]byte, error) {
	var hash [32]byte
	hashPrivateMessage, err := market.HashPrivateMsg(
		&bind.CallOpts{},
		currencyId,
		price,
		rnd,
	)
	if err != nil {
		return hash, err
	}
	hash, err = market.BuildPutAssetForSaleTxMsg(
		&bind.CallOpts{},
		hashPrivateMessage,
		big.NewInt(validUntil),
		playerId,
	)
	if err != nil {
		return hash, err
	}
	hash, err = market.Prefixed(&bind.CallOpts{}, hash)
	return hash, err
}

func (b *Signer) HashBidMessage(
	market *market.Market,
	currencyID uint8,
	price *big.Int,
	auctionRnd *big.Int,
	validUntil int64,
	playerID *big.Int,
	extraPrice *big.Int,
	bidRnd *big.Int,
	teamID *big.Int,
	isOffer2StartAuction bool,
) ([32]byte, error) {
	var hash [32]byte
	auctionHashMsg, err := HashSellMessage(
		market,
		currencyID,
		price,
		auctionRnd,
		validUntil,
		playerID,
	)
	if err != nil {
		return hash, err
	}
	bidHiddenPrice, err := market.HashBidHiddenPrice(
		&bind.CallOpts{},
		extraPrice,
		bidRnd,
	)
	if err != nil {
		return hash, err
	}
	hash, err = b.contracts.Market.BuildAgreeToBuyPlayerTxMsg(
		&bind.CallOpts{},
		auctionHashMsg,
		bidHiddenPrice,
		teamID,
		isOffer2StartAuction,
	)
	if err != nil {
		return hash, err
	}
	hash, err = b.contracts.Market.Prefixed(&bind.CallOpts{}, hash)
	return hash, err
}

func (b *Signer) Sign(hash [32]byte, pvr *ecdsa.PrivateKey) ([]byte, error) {
	sig, err := crypto.Sign(hash[:], pvr)
	last := len(sig) - 1
	if sig[last] == 0x00 {
		sig[last] = 0x1B
	} else {
		sig[last] = 0x1C
	}
	return sig, err
}

func (b *Signer) BidHiddenPrice(extraPrice *big.Int, rnd *big.Int) ([32]byte, error) {
	return b.contracts.Market.HashBidHiddenPrice(
		&bind.CallOpts{},
		extraPrice,
		rnd,
	)
}

func PublicKeyBytesToAddress(publicKey []byte) common.Address {
	var buf []byte

	hash := sha3.NewLegacyKeccak256()
	hash.Write(publicKey[1:]) // remove EC prefix 04
	buf = hash.Sum(nil)
	address := buf[12:]

	return common.HexToAddress(hex.EncodeToString(address))
}

func VerifySignature(hash []byte, signature []byte) (bool, error) {
	sigPublicKey, err := crypto.Ecrecover(hash, signature)
	if err != nil {
		return false, err
	}
	signatureNoRecoverID := signature[:len(signature)-1] // remove recovery id
	return crypto.VerifySignature(sigPublicKey, hash[:], signatureNoRecoverID), nil
}

func AddressFromSignature(hash, signature []byte) (common.Address, error) {
	sigPublicKey, err := crypto.Ecrecover(hash, signature)
	if err != nil {
		return common.Address{}, err
	}
	return PublicKeyBytesToAddress(sigPublicKey), nil
}

// func (b *Signer) HashBuyMessage(currencyId uint8, price *big.Int, rnd *big.Int, validUntil *big.Int, playerId *big.Int, teamId *big.Int) ([32]byte, error) {
// 	var hash [32]byte
// 	hashPrivateMessage, err := b.contracts.Market.HashPrivateMsg(
// 		&bind.CallOpts{},
// 		currencyId,
// 		price,
// 		rnd,
// 	)
// 	if err != nil {
// 		return hash, err
// 	}
// 	sellMsgHash, err := b.assets.BuildPutForSaleTxMsg(
// 		&bind.CallOpts{},
// 		hashPrivateMessage,
// 		validUntil,
// 		playerId,
// 	)
// 	if err != nil {
// 		return hash, err
// 	}
// 	prefixedHash, err := b.assets.Prefixed(&bind.CallOpts{}, sellMsgHash)
// 	if err != nil {
// 		return hash, err
// 	}
// 	hash, err = b.assets.BuildAgreeToBuyTxMsg(
// 		&bind.CallOpts{},
// 		prefixedHash,
// 		teamId,
// 	)
// 	if err != nil {
// 		return hash, err
// 	}
// 	hash, err = b.assets.Prefixed(&bind.CallOpts{}, hash)
// 	return hash, err
// }
