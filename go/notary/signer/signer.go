package signer

import (
	"crypto/ecdsa"
	"encoding/hex"
	"fmt"
	"math/big"

	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/market"
	"golang.org/x/crypto/sha3"
)

func RSV(signature string) (r [32]byte, s [32]byte, v uint8, err error) {
	if len(signature) != 132 && len(signature) != 130 {
		return r, s, v, fmt.Errorf("wrong signature length %v", len(signature))
	}
	if len(signature) == 132 {
		signature = signature[2:] // remove 0x
	}
	vect, err := hex.DecodeString(signature[0:64])
	if err != nil {
		return r, s, v, err
	}
	copy(r[:], vect)
	vect, err = hex.DecodeString(signature[64:128])
	if err != nil {
		return r, s, v, err
	}
	copy(s[:], vect)
	vect, err = hex.DecodeString(signature[128:130])
	v = vect[0]
	return r, s, v, err
}

func HidePrice(currencyId uint8, price *big.Int, rnd *big.Int) (common.Hash, error) {
	uint8Ty, _ := abi.NewType("uint8", "uint8", nil)
	uint256Ty, _ := abi.NewType("uint256", "uint256", nil)
	arguments := abi.Arguments{
		{
			Type: uint8Ty,
		},
		{
			Type: uint256Ty,
		},
		{
			Type: uint256Ty,
		},
	}

	bytes, err := arguments.Pack(
		currencyId,
		price,
		rnd,
	)
	if err != nil {
		return common.Hash{}, err
	}

	return crypto.Keccak256Hash(bytes), nil
}

func ComputePutAssetForSaleDigest(
	currencyId uint8,
	price *big.Int,
	rnd *big.Int,
	validUntil int64,
	offerValidUntil int64,
	assetId *big.Int,
) (common.Hash, error) {
	var hash [32]byte
	sellerHiddenPrice, err := HidePrice(
		currencyId,
		price,
		rnd,
	)
	if err != nil {
		return [32]byte{}, err
	}

	bytes32Ty, _ := abi.NewType("bytes32", "bytes32", nil)
	uint256Ty, _ := abi.NewType("uint256", "uint256", nil)
	uint32Ty, _ := abi.NewType("uint32", "uint32", nil)
	arguments := abi.Arguments{
		{
			Type: bytes32Ty,
		},
		{
			Type: uint256Ty,
		},
		{
			Type: uint32Ty,
		},
		{
			Type: uint32Ty,
		},
	}

	bytes, err := arguments.Pack(
		sellerHiddenPrice,
		assetId,
		uint32(validUntil),
		uint32(offerValidUntil),
	)
	if err != nil {
		return [32]byte{}, err
	}
	copy(hash[:], crypto.Keccak256Hash(bytes).Bytes())

	ss := fmt.Sprintf("\x19Ethereum Signed Message:\n%d%s", len(hash), hash)
	return crypto.Keccak256Hash([]byte(ss)), nil
}

func ComputeAuctionId(
	currencyId uint8,
	price *big.Int,
	rnd *big.Int,
	validUntil int64,
	offerValidUntil int64,
	assetId *big.Int,
) (common.Hash, error) {
	var hash [32]byte
	sellerHiddenPrice, err := HidePrice(
		currencyId,
		price,
		rnd,
	)
	if err != nil {
		return [32]byte{}, err
	}
	bytes32Ty, _ := abi.NewType("bytes32", "bytes32", nil)
	uint256Ty, _ := abi.NewType("uint256", "uint256", nil)
	uint32Ty, _ := abi.NewType("uint32", "uint32", nil)
	arguments := abi.Arguments{
		{
			Type: bytes32Ty,
		},
		{
			Type: uint256Ty,
		},
		{
			Type: uint32Ty,
		},
	}
	var timeUntil uint32
	if offerValidUntil > 0 {
		timeUntil = uint32(offerValidUntil)
	} else {
		timeUntil = uint32(validUntil)
	}

	bytes, err := arguments.Pack(
		sellerHiddenPrice,
		assetId,
		timeUntil,
	)
	if err != nil {
		return [32]byte{}, err
	}
	copy(hash[:], crypto.Keccak256Hash(bytes).Bytes())
	return hash, nil
}

func HasBidFromAuctionId(
	market *market.Market,
	auctionId [32]byte,
	extraPrice *big.Int,
	bidRnd *big.Int,
	teamID *big.Int,
) (common.Hash, error) {
	var hash [32]byte
	bidHiddenPrice, err := market.HashBidHiddenPrice(
		&bind.CallOpts{},
		extraPrice,
		bidRnd,
	)
	if err != nil {
		return hash, err
	}
	hash, err = market.BuildAgreeToBuyPlayerTxMsg(
		&bind.CallOpts{},
		auctionId,
		bidHiddenPrice,
		teamID,
	)
	if err != nil {
		return hash, err
	}
	hash, err = market.Prefixed(&bind.CallOpts{}, hash)
	return hash, err
}

func HashBidMessage(
	market *market.Market,
	currencyID uint8,
	price *big.Int,
	auctionRnd *big.Int,
	validUntil int64,
	offerValidUntil int64,
	playerID *big.Int,
	extraPrice *big.Int,
	bidRnd *big.Int,
	teamID *big.Int,
) (common.Hash, error) {
	if offerValidUntil > 0 && extraPrice.Cmp(big.NewInt(0)) != 0 {
		return [32]byte{}, fmt.Errorf("offers must have zero extraPrice")
	}
	if offerValidUntil > 0 && bidRnd.Cmp(big.NewInt(0)) != 0 {
		return [32]byte{}, fmt.Errorf("offers must have zero bidRnd")
	}
	var hash [32]byte
	auctionId, err := ComputeAuctionId(
		currencyID,
		price,
		auctionRnd,
		validUntil,
		offerValidUntil,
		playerID,
	)
	if err != nil {
		return [32]byte{}, err
	}
	bidHiddenPrice, err := market.HashBidHiddenPrice(
		&bind.CallOpts{},
		extraPrice,
		bidRnd,
	)
	if err != nil {
		return hash, err
	}
	hash, err = market.BuildAgreeToBuyPlayerTxMsg(
		&bind.CallOpts{},
		auctionId,
		bidHiddenPrice,
		teamID,
	)
	if err != nil {
		return hash, err
	}
	hash, err = market.Prefixed(&bind.CallOpts{}, hash)
	return hash, err
}

func Sign(hash []byte, pvr *ecdsa.PrivateKey) ([]byte, error) {
	sig, err := crypto.Sign(hash, pvr)
	if len(sig) != 65 {
		return []byte{}, fmt.Errorf("signature must be 65 bytes long")
	}
	if sig[64] != 0 && sig[64] != 1 {
		return []byte{}, fmt.Errorf("invalid Ethereum signature (V is not 0 or 1)")
	}
	sig[64] += 27
	return sig, err
}

func BidHiddenPrice(
	market *market.Market,
	extraPrice *big.Int,
	rnd *big.Int,
) ([32]byte, error) {
	return market.HashBidHiddenPrice(
		&bind.CallOpts{},
		extraPrice,
		rnd,
	)
}

func PublicKeyBytesToAddress(publicKey []byte) common.Address {
	var buf []byte

	hash := sha3.NewLegacyKeccak256()
	hash.Write(publicKey[1:]) // remove EC prefix 04
	buf = hash.Sum(nil)
	address := buf[12:]

	return common.HexToAddress(hex.EncodeToString(address))
}

func VerifySignature(hash []byte, signature []byte) (bool, error) {
	sigPublicKey, err := crypto.Ecrecover(hash, signature)
	if err != nil {
		return false, err
	}
	signatureNoRecoverID := signature[:len(signature)-1] // remove recovery id
	return crypto.VerifySignature(sigPublicKey, hash[:], signatureNoRecoverID), nil
}

func AddressFromSignature(hash, signature []byte) (common.Address, error) {
	sigPublicKey, err := crypto.Ecrecover(hash, signature)
	if err != nil {
		return common.Address{}, err
	}
	return PublicKeyBytesToAddress(sigPublicKey), nil
}
