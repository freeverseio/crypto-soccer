package testutils

import (
	"crypto/ecdsa"
	"log"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/ethclient"

	"github.com/freeverseio/crypto-soccer/go/contracts"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/assets"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/engine"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/engineprecomp"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/evolution"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/leagues"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/market"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/playandevolve"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/trainingpoints"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/updates"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/utilsmatchlog"
	"github.com/freeverseio/crypto-soccer/go/helper"
)

type BlockchainNode struct {
	Client    *ethclient.Client
	Owner     *ecdsa.PrivateKey
	Contracts *contracts.Contracts
}

// AssertNoErr - log fatal and panic on error and print params
func AssertNoErr(err error, params ...interface{}) {
	if err != nil {
		log.Fatal(err, params)
	}
}

func NewBlockchainNodeDeployAndInitAt(address string) (*BlockchainNode, error) {
	node, err := NewBlockchainNodeAt(address)
	if err != nil {
		return nil, err
	}
	err = node.DeployContracts(node.Owner)
	if err != nil {
		return nil, err
	}
	err = node.InitOneTimezone(1)
	if err != nil {
		return nil, err
	}
	return node, nil
}

func NewBlockchainNodeAt(address string) (*BlockchainNode, error) {
	client, err := ethclient.Dial(address)
	if err != nil {
		return nil, err
	}
	creatorPrivateKey, err := crypto.HexToECDSA("FE058D4CE3446218A7B4E522D9666DF5042CF582A44A9ED64A531A81E7494A85")
	if err != nil {
		return nil, err
	}

	return &BlockchainNode{
		client,
		creatorPrivateKey,
		nil,
	}, nil
}

func NewBlockchainNodeDeployAndInit() (*BlockchainNode, error) {
	return NewBlockchainNodeDeployAndInitAt("http://localhost:8545")
}

func NewBlockchainNode() (*BlockchainNode, error) {
	return NewBlockchainNodeAt("http://localhost:8545")
}

func (b *BlockchainNode) DeployContracts(owner *ecdsa.PrivateKey) error {
	auth := bind.NewKeyedTransactor(owner)
	var txs []*types.Transaction
	assetsAddress, tx, _, err := assets.DeployAssets(auth, b.Client)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	leaguesAddress, tx, leaguesContract, err := leagues.DeployLeagues(auth, b.Client)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	updatesAddress, tx, updatesContract, err := updates.DeployUpdates(auth, b.Client)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	engineAddress, tx, engineContract, err := engine.DeployEngine(auth, b.Client)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	marketAddress, tx, marketContract, err := market.DeployMarket(auth, b.Client)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	evolutionAddress, tx, _, err := evolution.DeployEvolution(auth, b.Client)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	engineprecompAddress, tx, _, err := engineprecomp.DeployEngineprecomp(auth, b.Client)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	utilsmatchlogAddress, tx, _, err := utilsmatchlog.DeployUtilsmatchlog(auth, b.Client)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	playandevolveAddress, tx, playandevolveContract, err := playandevolve.DeployPlayandevolve(auth, b.Client)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	trainingpointsAddress, tx, trainingpointsContract, err := trainingpoints.DeployTrainingpoints(auth, b.Client)
	if err != nil {
		return err
	}
	txs = append(txs, tx)

	if err = helper.WaitReceipts(b.Client, txs, 10); err != nil {
		return err
	}

	// setup
	tx, err = leaguesContract.SetEngineAdress(auth, engineAddress)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	tx, err = leaguesContract.SetAssetsAdress(auth, assetsAddress)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	tx, err = marketContract.SetAssetsAddress(auth, assetsAddress)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	tx, err = updatesContract.InitUpdates(auth, assetsAddress)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	if tx, err = trainingpointsContract.SetAssetsAddress(auth, assetsAddress); err != nil {
		return err
	}
	txs = append(txs, tx)
	if tx, err = playandevolveContract.SetEngineAddress(auth, engineAddress); err != nil {
		return err
	}
	txs = append(txs, tx)
	tx, err = engineContract.SetPreCompAddr(auth, engineprecompAddress)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	if tx, err = playandevolveContract.SetTrainingAddress(auth, trainingpointsAddress); err != nil {
		return err
	}
	txs = append(txs, tx)

	if err = helper.WaitReceipts(b.Client, txs, 10); err != nil {
		return err
	}

	b.Contracts, _ = contracts.New(
		b.Client,
		leaguesAddress.String(),
		assetsAddress.String(),
		evolutionAddress.String(),
		engineAddress.String(),
		engineprecompAddress.String(),
		updatesAddress.String(),
		marketAddress.String(),
		utilsmatchlogAddress.String(),
		playandevolveAddress.String(),
		trainingpointsAddress.String(),
	)
	return nil
}

func (b *BlockchainNode) Init() error {
	// Initing
	tx, err := b.Contracts.Assets.Init(bind.NewKeyedTransactor(b.Owner))
	if err != nil {
		return err
	}
	_, err = helper.WaitReceipt(b.Client, tx, 10)
	if err != nil {
		return err
	}
	return nil
}

func (b *BlockchainNode) InitOneTimezone(timezoneIdx uint8) error {
	// Initing
	tx, err := b.Contracts.Assets.InitSingleTZ(bind.NewKeyedTransactor(b.Owner), timezoneIdx)
	if err != nil {
		return err
	}
	_, err = helper.WaitReceipt(b.Client, tx, 10)
	if err != nil {
		return err
	}
	return nil
}
