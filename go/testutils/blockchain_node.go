package testutils

import (
	"crypto/ecdsa"
	"fmt"
	"log"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/ethclient"

	"github.com/freeverseio/crypto-soccer/go/contracts"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/assets"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/engine"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/engineprecomp"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/evolution"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/leagues"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/market"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/matchevents"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/updates"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/utilsmatchlog"
	"github.com/freeverseio/crypto-soccer/go/helper"
)

type ContractAddresses struct {
	Leagues       string
	Assets        string
	Evolution     string
	Engine        string
	Engineprecomp string
	Updates       string
	Market        string
	Matchevents   string
	Utilsmatchlog string
}

type BlockchainNode struct {
	Client    *ethclient.Client
	Owner     *ecdsa.PrivateKey
	Contracts *contracts.Contracts
	Addresses ContractAddresses
}

// AssertNoErr - log fatal and panic on error and print params
func AssertNoErr(err error, params ...interface{}) {
	if err != nil {
		log.Fatal(err, params)
	}
}

func NewBlockchainNodeDeployAndInitAt(address string) (*BlockchainNode, error) {
	node, err := NewBlockchainNodeAt(address)
	if err != nil {
		return nil, err
	}
	err = node.DeployContracts(node.Owner)
	if err != nil {
		return nil, err
	}
	err = node.InitOneTimezone(1)
	if err != nil {
		return nil, err
	}
	return node, nil
}

func NewBlockchainNodeAt(address string) (*BlockchainNode, error) {
	client, err := ethclient.Dial(address)
	if err != nil {
		return nil, err
	}
	creatorPrivateKey, err := crypto.HexToECDSA("FE058D4CE3446218A7B4E522D9666DF5042CF582A44A9ED64A531A81E7494A85")
	if err != nil {
		return nil, err
	}

	return &BlockchainNode{
		client,
		creatorPrivateKey,
		nil,
		ContractAddresses{},
	}, nil
}

func NewBlockchainNodeDeployAndInit() (*BlockchainNode, error) {
	return NewBlockchainNodeDeployAndInitAt("http://localhost:8545")
}

func NewBlockchainNode() (*BlockchainNode, error) {
	return NewBlockchainNodeAt("http://localhost:8545")
}

func (b *BlockchainNode) DeployContracts(owner *ecdsa.PrivateKey) error {
	b.Addresses = ContractAddresses{}
	assetsAddress, tx10, assetsContract, err := assets.DeployAssets(
		bind.NewKeyedTransactor(owner),
		b.Client,
	)
	AssertNoErr(err, "DeployAssets failed")
	fmt.Println("Assets deployed at:", assetsAddress.Hex())
	b.Addresses.Assets = assetsAddress.Hex()
	if err != nil {
		return err
	}

	leaguesAddress, tx0, leaguesContract, err := leagues.DeployLeagues(
		bind.NewKeyedTransactor(owner),
		b.Client,
	)
	AssertNoErr(err, "DeployLeagues failed")
	fmt.Println("Leagues deployed at:", leaguesAddress.Hex())
	b.Addresses.Leagues = leaguesAddress.Hex()
	if err != nil {
		return err
	}

	updatesAddress, tx1, updatesContract, err := updates.DeployUpdates(
		bind.NewKeyedTransactor(owner),
		b.Client,
	)
	AssertNoErr(err, "DeployUpdates failed")
	fmt.Println("Updates deployed at:", updatesAddress.Hex())
	b.Addresses.Updates = updatesAddress.Hex()
	if err != nil {
		return err
	}

	engineAddress, tx2, engineContract, err := engine.DeployEngine(
		bind.NewKeyedTransactor(owner),
		b.Client,
	)
	AssertNoErr(err, "DeployEngine failed")
	fmt.Println("Engine deployed at:", engineAddress.Hex())
	b.Addresses.Engine = engineAddress.Hex()
	if err != nil {
		return err
	}

	marketAddress, tx3, marketContract, err := market.DeployMarket(
		bind.NewKeyedTransactor(owner),
		b.Client,
	)
	AssertNoErr(err, "DeployMarket failed")
	fmt.Println("Market deployed at:", marketAddress.Hex())
	b.Addresses.Market = marketAddress.Hex()
	if err != nil {
		return err
	}

	evolutionAddress, tx30, evolutionContract, err := evolution.DeployEvolution(
		bind.NewKeyedTransactor(owner),
		b.Client,
	)
	AssertNoErr(err, "DeployEvolution failed")
	fmt.Println("Evolution deployed at:", evolutionAddress.Hex())
	b.Addresses.Evolution = evolutionAddress.Hex()
	if err != nil {
		return err
	}

	engineprecompAddress, tx31, enginePreComp, err := engineprecomp.DeployEngineprecomp(
		bind.NewKeyedTransactor(owner),
		b.Client,
	)
	AssertNoErr(err, "DeployEngineprecomp failed")
	fmt.Println("Engineprecomp deployed at:", engineprecompAddress.Hex())
	b.Addresses.Engineprecomp = engineprecompAddress.Hex()
	if err != nil {
		return err
	}

	matcheventsAddress, tx32, matcheventsContract, err := matchevents.DeployMatchevents(
		bind.NewKeyedTransactor(owner),
		b.Client,
	)
	AssertNoErr(err, "DeployMatchevents failed")
	fmt.Println("Matchevents deployed at:", matcheventsAddress.Hex())
	b.Addresses.Matchevents = matcheventsAddress.Hex()
	if err != nil {
		return err
	}

	utilsmatchlogAddress, tx33, utilsmatchlogContract, err := utilsmatchlog.DeployUtilsmatchlog(
		bind.NewKeyedTransactor(owner),
		b.Client,
	)
	AssertNoErr(err, "DeployUtilsmatchlog failed")
	fmt.Println("Utilsmatchlog deployed at:", utilsmatchlogAddress.Hex())
	b.Addresses.Utilsmatchlog = utilsmatchlogAddress.Hex()
	if err != nil {
		return err
	}

	_, err = helper.WaitReceipt(b.Client, tx10, 10)
	if err != nil {
		return err
	}
	_, err = helper.WaitReceipt(b.Client, tx0, 10)
	if err != nil {
		return err
	}
	_, err = helper.WaitReceipt(b.Client, tx1, 10)
	if err != nil {
		return err
	}
	_, err = helper.WaitReceipt(b.Client, tx2, 10)
	if err != nil {
		return err
	}
	_, err = helper.WaitReceipt(b.Client, tx3, 10)
	if err != nil {
		return err
	}
	_, err = helper.WaitReceipt(b.Client, tx30, 10)
	if err != nil {
		return err
	}
	_, err = helper.WaitReceipt(b.Client, tx31, 10)
	if err != nil {
		return err
	}
	_, err = helper.WaitReceipt(b.Client, tx32, 10)
	if err != nil {
		return err
	}
	_, err = helper.WaitReceipt(b.Client, tx33, 10)
	if err != nil {
		return err
	}
	// setup
	tx0, err = leaguesContract.SetEngineAdress(bind.NewKeyedTransactor(owner), engineAddress)
	AssertNoErr(err, "Error setting engine contract in league contract")
	tx31, err = leaguesContract.SetAssetsAdress(bind.NewKeyedTransactor(owner), assetsAddress)
	AssertNoErr(err, "Error setting assets contract in league contract")
	tx2, err = marketContract.SetAssetsAddress(bind.NewKeyedTransactor(owner), assetsAddress)
	AssertNoErr(err, "Error setting Assets address to market")
	tx1, err = updatesContract.InitUpdates(bind.NewKeyedTransactor(owner), assetsAddress)
	AssertNoErr(err, "Updates::InitUpdates(leagues) failed")
	tx31, err = evolutionContract.SetAssetsAddress(bind.NewKeyedTransactor(owner), assetsAddress)
	AssertNoErr(err, "Error setting engine contract in evolution contract")
	tx3, err = evolutionContract.SetEngine(bind.NewKeyedTransactor(owner), engineAddress)
	AssertNoErr(err, "Error setting engine contract in evolution contract")
	tx30, err = engineContract.SetPreCompAddr(bind.NewKeyedTransactor(owner), engineprecompAddress)
	AssertNoErr(err, "Error setting engineprecomp contract in engine contract")
	tx31, err = matcheventsContract.SetPreCompAddr(bind.NewKeyedTransactor(owner), engineprecompAddress)
	AssertNoErr(err, "Error setting engineprecomp contract in engine contract")

	_, err = helper.WaitReceipt(b.Client, tx0, 10)
	if err != nil {
		return err
	}
	_, err = helper.WaitReceipt(b.Client, tx1, 10)
	if err != nil {
		return err
	}
	_, err = helper.WaitReceipt(b.Client, tx2, 10)
	if err != nil {
		return err
	}
	_, err = helper.WaitReceipt(b.Client, tx3, 10)
	if err != nil {
		return err
	}
	_, err = helper.WaitReceipt(b.Client, tx30, 10)
	if err != nil {
		return err
	}
	_, err = helper.WaitReceipt(b.Client, tx31, 10)
	if err != nil {
		return err
	}
	_, err = helper.WaitReceipt(b.Client, tx32, 10)
	if err != nil {
		return err
	}

	b.Contracts = &contracts.Contracts{
		b.Client,
		leaguesContract,
		assetsContract,
		evolutionContract,
		engineContract,
		enginePreComp,
		updatesContract,
		marketContract,
		matcheventsContract,
		utilsmatchlogContract,
	}
	return nil
}

func (b *BlockchainNode) Init() error {
	// Initing
	tx, err := b.Contracts.Assets.Init(bind.NewKeyedTransactor(b.Owner))
	if err != nil {
		return err
	}
	_, err = helper.WaitReceipt(b.Client, tx, 10)
	if err != nil {
		return err
	}
	return nil
}

func (b *BlockchainNode) InitOneTimezone(timezoneIdx uint8) error {
	// Initing
	tx, err := b.Contracts.Assets.InitSingleTZ(bind.NewKeyedTransactor(b.Owner), timezoneIdx)
	if err != nil {
		return err
	}
	_, err = helper.WaitReceipt(b.Client, tx, 10)
	if err != nil {
		return err
	}
	return nil
}
