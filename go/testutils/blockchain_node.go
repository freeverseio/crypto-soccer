package testutils

import (
	"crypto/ecdsa"
	"os"
	"os/exec"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/ethclient"

	"github.com/freeverseio/crypto-soccer/go/contracts"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/assets"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/engine"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/engineapplyboosters"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/engineprecomp"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/evolution"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/leagues"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/market"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/playandevolve"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/shop"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/trainingpoints"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/updates"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/utils"
	"github.com/freeverseio/crypto-soccer/go/helper"

	log "github.com/sirupsen/logrus"
)

type ContractAddresses struct {
	Leagues        string
	Assets         string
	Evolution      string
	Engine         string
	Engineprecomp  string
	Updates        string
	Market         string
	Utils          string
	Playandevolve  string
	Shop           string
	Trainingpoints string
}

type BlockchainNode struct {
	Client    *ethclient.Client
	Owner     *ecdsa.PrivateKey
	Contracts *contracts.Contracts
	Addresses ContractAddresses
}

// AssertNoErr - log fatal and panic on error and print params
func AssertNoErr(err error, params ...interface{}) {
	if err != nil {
		log.Fatal(err, params)
	}
}

func NewBlockchainNodeDeployAndInitAt(address string) (*BlockchainNode, error) {
	node, err := NewBlockchainNodeAt(address)
	if err != nil {
		return nil, err
	}
	err = node.DeployContracts(node.Owner)
	if err != nil {
		return nil, err
	}
	err = node.InitOneTimezone(1)
	if err != nil {
		return nil, err
	}
	return node, nil
}

func NewBlockchainNodeAt(address string) (*BlockchainNode, error) {
	client, err := ethclient.Dial(address)
	if err != nil {
		return nil, err
	}
	creatorPrivateKey, err := crypto.HexToECDSA("FE058D4CE3446218A7B4E522D9666DF5042CF582A44A9ED64A531A81E7494A85")
	if err != nil {
		return nil, err
	}

	return &BlockchainNode{
		client,
		creatorPrivateKey,
		nil,
		ContractAddresses{},
	}, nil
}

func NewBlockchainNodeDeployAndInit() (*BlockchainNode, error) {
	return NewBlockchainNodeDeployAndInitAt("http://localhost:8545")
}

func NewBlockchainNode() (*BlockchainNode, error) {
	return NewBlockchainNodeAt("http://localhost:8545")
}

func (b *BlockchainNode) DeployContracts(owner *ecdsa.PrivateKey) error {
	cryptoRoot, err := exec.Command("/usr/bin/git", "rev-parse", "--show-toplevel").Output()
	if err != nil {
		log.Fatal(err)
	}
	log.Infof("Cryptosoccer root at: %s", cryptoRoot)
	workingDir, err := os.Getwd()
	if err != nil {
		return err
	}
	if err = os.Chdir(string(cryptoRoot[:len(cryptoRoot)-1]) + "/truffle-core"); err != nil {
		return err
	}
	cmd := exec.Command("./node_modules/.bin/truffle", "migrate", "--network", "local", "--reset")
	log.Infof("Deploy by truffle: %v", cmd.String())
	err = cmd.Run()
	if err != nil {
		return err
	}
	if err = os.Chdir(workingDir); err != nil {
		return err
	}
	auth := bind.NewKeyedTransactor(owner)
	var txs []*types.Transaction
	assetsAddress, tx, _, err := assets.DeployAssets(auth, b.Client)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	leaguesAddress, tx, leaguesContract, err := leagues.DeployLeagues(auth, b.Client)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	updatesAddress, tx, updatesContract, err := updates.DeployUpdates(auth, b.Client)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	engineAddress, tx, engineContract, err := engine.DeployEngine(auth, b.Client)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	marketAddress, tx, marketContract, err := market.DeployMarket(auth, b.Client)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	evolutionAddress, tx, _, err := evolution.DeployEvolution(auth, b.Client)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	engineprecompAddress, tx, _, err := engineprecomp.DeployEngineprecomp(auth, b.Client)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	engineapplyboostersAddress, tx, _, err := engineapplyboosters.DeployEngineapplyboosters(auth, b.Client)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	utilsAddress, tx, _, err := utils.DeployUtils(auth, b.Client)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	playandevolveAddress, tx, playandevolveContract, err := playandevolve.DeployPlayandevolve(auth, b.Client)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	shopAddress, tx, _, err := shop.DeployShop(auth, b.Client)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	trainingpointsAddress, tx, trainingpointsContract, err := trainingpoints.DeployTrainingpoints(auth, b.Client)
	if err != nil {
		return err
	}
	txs = append(txs, tx)

	if err = helper.WaitReceipts(b.Client, txs, 10); err != nil {
		return err
	}

	// setup
	tx, err = leaguesContract.SetEngineAdress(auth, engineAddress)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	tx, err = leaguesContract.SetAssetsAdress(auth, assetsAddress)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	tx, err = marketContract.SetAssetsAddress(auth, assetsAddress)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	tx, err = updatesContract.InitUpdates(auth, assetsAddress)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	if tx, err = trainingpointsContract.SetAssetsAddress(auth, assetsAddress); err != nil {
		return err
	}
	txs = append(txs, tx)

	tx, err = engineContract.SetPreCompAddr(auth, engineprecompAddress)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	tx, err = engineContract.SetApplyBoostersAddr(auth, engineapplyboostersAddress)
	if err != nil {
		return err
	}
	txs = append(txs, tx)
	if tx, err = playandevolveContract.SetTrainingAddress(auth, trainingpointsAddress); err != nil {
		return err
	}
	txs = append(txs, tx)
	if tx, err = playandevolveContract.SetEngineAddress(auth, engineAddress); err != nil {
		return err
	}
	txs = append(txs, tx)
	if tx, err = playandevolveContract.SetEvolutionAddress(auth, evolutionAddress); err != nil {
		return err
	}
	txs = append(txs, tx)
	if tx, err = playandevolveContract.SetShopAddress(auth, shopAddress); err != nil {
		return err
	}
	txs = append(txs, tx)

	if err = helper.WaitReceipts(b.Client, txs, 10); err != nil {
		return err
	}

	b.Contracts, _ = contracts.New(
		b.Client,
		leaguesAddress.String(),
		assetsAddress.String(),
		evolutionAddress.String(),
		engineAddress.String(),
		engineprecompAddress.String(),
		updatesAddress.String(),
		marketAddress.String(),
		utilsAddress.String(),
		playandevolveAddress.String(),
		shopAddress.String(),
		trainingpointsAddress.String(),
	)

	b.Addresses = ContractAddresses{
		leaguesAddress.String(),
		assetsAddress.String(),
		evolutionAddress.String(),
		engineAddress.String(),
		engineprecompAddress.String(),
		updatesAddress.String(),
		marketAddress.String(),
		utilsAddress.String(),
		playandevolveAddress.String(),
		shopAddress.String(),
		trainingpointsAddress.String(),
	}
	return nil
}

func (b *BlockchainNode) Init() error {
	// Initing
	tx, err := b.Contracts.Assets.Init(bind.NewKeyedTransactor(b.Owner))
	if err != nil {
		return err
	}
	_, err = helper.WaitReceipt(b.Client, tx, 10)
	if err != nil {
		return err
	}
	return nil
}

func (b *BlockchainNode) InitOneTimezone(timezoneIdx uint8) error {
	// Initing
	tx, err := b.Contracts.Assets.InitSingleTZ(bind.NewKeyedTransactor(b.Owner), timezoneIdx)
	if err != nil {
		return err
	}
	_, err = helper.WaitReceipt(b.Client, tx, 10)
	if err != nil {
		return err
	}
	return nil
}
