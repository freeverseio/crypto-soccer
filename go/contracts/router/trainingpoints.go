package router

import (
	"errors"
	"math/big"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/trainingpoints"
)

type Trainingpoints struct {
	trainingpoints.Trainingpoints
}

// NewTrainingpoints creates a new instance of Trainingpoints, bound to a specific deployed contract.
func NewTrainingpoints(address common.Address, backend bind.ContractBackend) (*Trainingpoints, error) {
	c, err := trainingpoints.NewTrainingpoints(address, backend)
	if err != nil {
		return nil, err
	}
	return &Trainingpoints{*c}, nil
}

func (b *Trainingpoints) EncodeTP(opts *bind.CallOpts, TP uint16, TPperSkill [25]uint16, specialPlayer uint8) (*big.Int, error) {
	MAX_PERCENT := int64(60)
	PLAYERS_PER_TEAM_MAX := uint8(25)
	NO_PLAYER := uint8(25)

	if !(specialPlayer <= PLAYERS_PER_TEAM_MAX) {
		return big.NewInt(0), errors.New("specialPlayer value too large")
	}

	TP64 := int64(TP)
	encoded := left(big.NewInt(TP64), 225)
	encoded = orBN(encoded, left(big.NewInt(int64(specialPlayer)), 234))
	maxRHS := getMaxRHS(TP64, MAX_PERCENT)

	var lastBucket uint8
	if specialPlayer == NO_PLAYER {
		lastBucket = 4
	} else {
		lastBucket = 5
	}

	for bucket := uint8(0); bucket < lastBucket; bucket++ {
		if bucket == 4 {
			TP64 = (TP64 * 11) / 10
			maxRHS = getMaxRHS(TP64, MAX_PERCENT)
		}
		sum := int64(0)
		for sk := 5 * bucket; sk < 5*(bucket+1); sk++ {
			skill := int64(TPperSkill[sk])
			if !(100*skill <= maxRHS) {
				return encoded, errors.New("one of the assigned TPs is too large")
			}
			sum += skill
			encoded = orBN(encoded, left(big.NewInt(skill), 9*uint(sk)))
		}
		if !(sum <= TP64) {
			return encoded, errors.New("sum of Traning Points is too large")
		}
	}
	return encoded, nil
}

func getMaxRHS(TP int64, MAX_PERCENT int64) int64 {
	if TP < 4 {
		return 100 * TP
	}
	return MAX_PERCENT * TP
}
