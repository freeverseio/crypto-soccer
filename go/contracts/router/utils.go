package router

import (
	"math/big"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/utils"
)

type Utils struct {
	utils.Utils
}

// NewUtils creates a new instance of Utils, bound to a specific deployed contract.
func NewUtils(address common.Address, backend bind.ContractBackend) (*Utils, error) {
	c, err := utils.NewUtils(address, backend)
	if err != nil {
		return nil, err
	}
	return &Utils{*c}, nil
}

func (b *Utils) FullDecodeSkills(opts *bind.CallOpts, encodedSkills *big.Int) (struct {
	Skills                                                 [5]uint32
	DayOfBirth                                             uint16
	BirthTraits                                            [4]uint8
	PlayerId                                               *big.Int
	Aligned1stSubst1stRedCardLastGameOutOfGame1stYellow1st [5]bool
	GenerationGamesNonStopInjuryWeeks                      [3]uint8
}, error) {

	result := struct {
		Skills                                                 [5]uint32
		DayOfBirth                                             uint16
		BirthTraits                                            [4]uint8
		PlayerId                                               *big.Int
		Aligned1stSubst1stRedCardLastGameOutOfGame1stYellow1st [5]bool
		GenerationGamesNonStopInjuryWeeks                      [3]uint8
	}{}

	N_SKILLS := uint8(5)
	for sk := uint8(0); sk < N_SKILLS; sk++ {
		result.Skills[sk] = uint32(getSkillGo(encodedSkills, sk).Uint64())
	}
	result.DayOfBirth = uint16(getBirthDayGo(encodedSkills).Uint64())

	result.BirthTraits[0] = uint8(getPotentialGo(encodedSkills).Uint64())
	result.BirthTraits[1] = uint8(getForwardnessGo(encodedSkills).Uint64())
	result.BirthTraits[2] = uint8(getLeftishnessGo(encodedSkills).Uint64())
	result.BirthTraits[3] = uint8(getAggressivenessGo(encodedSkills).Uint64())

	result.PlayerId = getPlayerIdFromSkillsGo(encodedSkills)

	result.Aligned1stSubst1stRedCardLastGameOutOfGame1stYellow1st[0] = getAlignedEndOfFirstHalfGo(encodedSkills)
	result.Aligned1stSubst1stRedCardLastGameOutOfGame1stYellow1st[1] = getSubstitutedFirstHalfGo(encodedSkills)
	result.Aligned1stSubst1stRedCardLastGameOutOfGame1stYellow1st[2] = getRedCardLastGameGo(encodedSkills)
	result.Aligned1stSubst1stRedCardLastGameOutOfGame1stYellow1st[3] = getOutOfGameFirstHalfGo(encodedSkills)
	result.Aligned1stSubst1stRedCardLastGameOutOfGame1stYellow1st[4] = getYellowCardFirstHalfGo(encodedSkills)

	result.GenerationGamesNonStopInjuryWeeks[0] = uint8(getGenerationGo(encodedSkills).Uint64())
	result.GenerationGamesNonStopInjuryWeeks[1] = getGamesNonStoppingGo(encodedSkills)
	result.GenerationGamesNonStopInjuryWeeks[2] = getInjuryWeeksLeftGo(encodedSkills)
	return result, nil
}

func (b *Utils) FullDecodeMatchLog(opts *bind.CallOpts, log *big.Int, is2ndHalf bool) ([15]uint32, error) {
	var (
		decodedLog = new([15]uint32)
	)
	decodedLog[0] = uint32(getTeamSumSkillsGo(log).Uint64())
	decodedLog[1] = uint32(getWinnerGo(log))
	decodedLog[2] = uint32(getNGoalsGo(log))
	if is2ndHalf {
		decodedLog[3] = uint32(getTrainingPointsGo(log))
	} else {
		decodedLog[3] = 0
	}

	decodedLog[4] = uint32(getOutOfGamePlayerGo(log, is2ndHalf).Uint64())
	decodedLog[5] = uint32(getOutOfGameTypeGo(log, is2ndHalf).Uint64())
	decodedLog[6] = uint32(getOutOfGameRoundGo(log, is2ndHalf).Uint64())

	decodedLog[7] = uint32(getYellowCardGo(log, 0, is2ndHalf))
	decodedLog[8] = uint32(getYellowCardGo(log, 1, is2ndHalf))

	decodedLog[9] = uint32(getInGameSubsHappenedGo(log, 0, is2ndHalf))
	decodedLog[10] = uint32(getInGameSubsHappenedGo(log, 1, is2ndHalf))
	decodedLog[11] = uint32(getInGameSubsHappenedGo(log, 2, is2ndHalf))

	/// getHalfTimeSubs: recall that 0 means no subs, and we store here p+1 (where p = player in the starting 11 that was substituted)
	if is2ndHalf {
		decodedLog[12] = uint32(getHalfTimeSubsGo(log, 0))
		decodedLog[13] = uint32(getHalfTimeSubsGo(log, 1))
		decodedLog[14] = uint32(getHalfTimeSubsGo(log, 2))
	}
	return *decodedLog, nil
}

func (b *Utils) DecodeTactics(opts *bind.CallOpts, tactics *big.Int) (struct {
	Substitutions [3]uint8
	SubsRounds    [3]uint8
	Lineup        [14]uint8
	ExtraAttack   [10]bool
	TacticsId     uint8
}, error) {
	result := struct {
		Substitutions [3]uint8
		SubsRounds    [3]uint8
		Lineup        [14]uint8
		ExtraAttack   [10]bool
		TacticsId     uint8
	}{}
	result.TacticsId = getTacticsIdGo(tactics)
	result.ExtraAttack = getFullExtraAttackGo(tactics)
	for p := uint8(0); p < 3; p++ {
		result.Substitutions[p] = getSubstitutionGo(tactics, p)
	}
	result.Lineup = getFullLineUpGo(tactics)
	for p := uint8(0); p < 3; p++ {
		result.SubsRounds[p] = getSubsRoundGo(tactics, p)
	}
	return result, nil
}
