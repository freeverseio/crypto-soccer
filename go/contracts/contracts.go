package contracts

import (
	"bytes"
	"os"
	"os/exec"
	"strings"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/assets"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/constantsgetters"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/directory"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/engine"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/engineprecomp"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/evolution"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/leagues"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/market"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/playandevolve"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/privileged"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/shop"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/stakers"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/trainingpoints"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/updates"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/utils"
	log "github.com/sirupsen/logrus"
)

type Contracts struct {
	Client                  *ethclient.Client
	Leagues                 *leagues.Leagues
	Assets                  *assets.Assets
	Evolution               *evolution.Evolution
	Engine                  *engine.Engine
	Engineprecomp           *engineprecomp.Engineprecomp
	Updates                 *updates.Updates
	Market                  *market.Market
	Utils                   *utils.Utils
	PlayAndEvolve           *playandevolve.Playandevolve
	Shop                    *shop.Shop
	TrainingPoints          *trainingpoints.Trainingpoints
	ConstantsGetters        *constantsgetters.Constantsgetters
	Privileged              *privileged.Privileged
	Stakers                 *stakers.Stakers
	Directory               *directory.Directory
	leaguesAddress          string
	AssetsAddress           string
	evolutionAddress        string
	engineAddress           string
	engineprecompAddress    string
	updatesAddress          string
	marketAddress           string
	utilsAddress            string
	playandevolveAddress    string
	shopAddress             string
	trainingpointsAddress   string
	constantsgettersAddress string
	privilegedAddress       string
	stakersAddress          string
	directoryAddress        string
}

func (b Contracts) Clone() (*Contracts, error) {
	return New(
		b.Client,
		b.leaguesAddress,
		b.AssetsAddress,
		b.evolutionAddress,
		b.engineAddress,
		b.engineprecompAddress,
		b.updatesAddress,
		b.marketAddress,
		b.utilsAddress,
		b.playandevolveAddress,
		b.shopAddress,
		b.trainingpointsAddress,
		b.constantsgettersAddress,
		b.privilegedAddress,
		b.stakersAddress,
		b.directoryAddress,
	)
}

func New(
	client *ethclient.Client,
	leaguesAddress string,
	assetsAddress string,
	evolutionAddress string,
	engineAddress string,
	engineprecompAddress string,
	updatesAddress string,
	marketAddress string,
	utilsAddress string,
	playandevolveAddress string,
	shopAddress string,
	trainingpointsAddress string,
	constantsgettersAddress string,
	privilegedAddress string,
	stakersAddress string,
	directoryAddress string,
) (*Contracts, error) {
	var err error
	contracts := Contracts{}
	contracts.leaguesAddress = leaguesAddress
	contracts.AssetsAddress = assetsAddress
	contracts.evolutionAddress = evolutionAddress
	contracts.engineAddress = engineAddress
	contracts.engineprecompAddress = engineprecompAddress
	contracts.updatesAddress = updatesAddress
	contracts.marketAddress = marketAddress
	contracts.utilsAddress = utilsAddress
	contracts.playandevolveAddress = playandevolveAddress
	contracts.shopAddress = shopAddress
	contracts.trainingpointsAddress = trainingpointsAddress
	contracts.constantsgettersAddress = constantsgettersAddress
	contracts.privilegedAddress = constantsgettersAddress
	contracts.stakersAddress = stakersAddress
	contracts.directoryAddress = directoryAddress
	contracts.Client = client

	log.Debug("creating leagues bindings to: ", leaguesAddress)
	contracts.Leagues, err = leagues.NewLeagues(common.HexToAddress(leaguesAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Debug("creating assets bindings to: ", assetsAddress)
	contracts.Assets, err = assets.NewAssets(common.HexToAddress(assetsAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Debug("creating evolution bindings to: ", evolutionAddress)
	contracts.Evolution, err = evolution.NewEvolution(common.HexToAddress(evolutionAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Debug("creating engine bindings to: ", engineAddress)
	contracts.Engine, err = engine.NewEngine(common.HexToAddress(engineAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Debug("creating engineprecomp bindings to: ", engineprecompAddress)
	contracts.Engineprecomp, err = engineprecomp.NewEngineprecomp(common.HexToAddress(engineprecompAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Debug("creating updates bindings to: ", updatesAddress)
	contracts.Updates, err = updates.NewUpdates(common.HexToAddress(updatesAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Debug("Creating Market bindings to: ", marketAddress)
	contracts.Market, err = market.NewMarket(common.HexToAddress(marketAddress), contracts.Client)
	if err != nil {
		log.Fatalf("Failed to connect to the Ethereum client: %v", err)
	}
	log.Debug("Creating Utils bindings to: ", utilsAddress)
	contracts.Utils, err = utils.NewUtils(common.HexToAddress(utilsAddress), contracts.Client)
	if err != nil {
		log.Fatalf("Failed to connect to the Ethereum client: %v", err)
	}
	if contracts.PlayAndEvolve, err = playandevolve.NewPlayandevolve(common.HexToAddress(playandevolveAddress), contracts.Client); err != nil {
		return nil, err
	}
	if contracts.Shop, err = shop.NewShop(common.HexToAddress(shopAddress), contracts.Client); err != nil {
		return nil, err
	}
	if contracts.TrainingPoints, err = trainingpoints.NewTrainingpoints(common.HexToAddress(trainingpointsAddress), contracts.Client); err != nil {
		return nil, err
	}
	if contracts.ConstantsGetters, err = constantsgetters.NewConstantsgetters(common.HexToAddress(constantsgettersAddress), contracts.Client); err != nil {
		return nil, err
	}
	if contracts.Privileged, err = privileged.NewPrivileged(common.HexToAddress(privilegedAddress), contracts.Client); err != nil {
		return nil, err
	}
	if contracts.Stakers, err = stakers.NewStakers(common.HexToAddress(stakersAddress), contracts.Client); err != nil {
		return nil, err
	}
	if contracts.Directory, err = directory.NewDirectory(common.HexToAddress(directoryAddress), contracts.Client); err != nil {
		return nil, err
	}

	return &contracts, nil
}

func NewFromDeployedDirectory(client *ethclient.Client, event directory.DirectoryDeployedDirectory) (*Contracts, error) {
	contractMap := make(map[string]string)
	for i := range event.Names {
		name := event.Names[i]
		n := bytes.Index(name[:], []byte{0})
		address := event.Adresseses[i]
		contractMap[string(name[:n])] = address.String()
	}
	return New(
		client,
		contractMap["LEAGUES"],
		contractMap["ASSETS"],
		contractMap["EVOLUTION"],
		contractMap["ENGINE"],
		contractMap["ENGINEPRECOMP"],
		contractMap["UPDATES"],
		contractMap["MARKET"],
		contractMap["UTILS"],
		contractMap["PLAYANDEVOLVE"],
		contractMap["SHOP"],
		contractMap["TRAININGPOINTS"],
		contractMap["CONSTANTSGETTERS"],
		contractMap["PRIVILEGED"],
		contractMap["STAKERS"],
		contractMap["DIRECTORY"],
	)
}

func GetContractAddress(directory *directory.Directory, name string) (common.Address, error) {
	var name32 [32]byte
	copy(name32[:], name)
	address, err := directory.GetAddress(&bind.CallOpts{}, name32)
	if err != nil {
		return common.Address{}, err
	}
	return address, nil
}

func DeplyByTruffle() (map[string]string, error) {
	cryptoRoot, err := exec.Command("/usr/bin/git", "rev-parse", "--show-toplevel").Output()
	if err != nil {
		log.Fatal(err)
	}
	log.Infof("Repo root at: %s", cryptoRoot)
	workingDir, err := os.Getwd()
	if err != nil {
		return nil, err
	}
	if err = os.Chdir(string(cryptoRoot[:len(cryptoRoot)-1]) + "/truffle-core"); err != nil {
		return nil, err
	}
	cmd := exec.Command("./node_modules/.bin/truffle", "migrate", "--network", "local", "--reset")
	log.Infof("Deploy by truffle: %v", cmd.String())
	o, err := cmd.Output()
	if err != nil {
		return nil, err
	}
	// log.Infof("%s", o)
	output := string(o)
	startIdx := strings.Index(output, "-----------AddressesStart-----------") + len("-----------AddressesStart-----------")
	endIdx := strings.Index(output, "-----------AddressesEnd-----------")
	var contracts map[string]string
	contracts = make(map[string]string)
	addresses := strings.Split(output[startIdx+1:endIdx-1], "\n")
	for _, address := range addresses {
		log.Info(address)
		pair := strings.SplitN(address, "=", 2)
		contracts[pair[0]] = pair[1]
	}
	if err = os.Chdir(workingDir); err != nil {
		return nil, err
	}
	return contracts, nil
}
