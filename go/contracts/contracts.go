package contracts

import (
	"bytes"
	"errors"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/assets"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/constantsgetters"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/directory"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/engine"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/engineprecomp"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/evolution"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/leagues"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/market"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/playandevolve"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/privileged"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/proxy"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/shop"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/stakers"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/trainingpoints"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/updates"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/utils"
	log "github.com/sirupsen/logrus"
)

type Contracts struct {
	Client                  *ethclient.Client
	Leagues                 *leagues.Leagues
	Assets                  *assets.Assets
	Evolution               *evolution.Evolution
	Engine                  *engine.Engine
	Engineprecomp           *engineprecomp.Engineprecomp
	Updates                 *updates.Updates
	Market                  *market.Market
	Utils                   *utils.Utils
	PlayAndEvolve           *playandevolve.Playandevolve
	Shop                    *shop.Shop
	TrainingPoints          *trainingpoints.Trainingpoints
	ConstantsGetters        *constantsgetters.Constantsgetters
	Privileged              *privileged.Privileged
	Stakers                 *stakers.Stakers
	Directory               *directory.Directory
	Proxy                   *proxy.Proxy
	LeaguesAddress          string
	AssetsAddress           string
	EvolutionAddress        string
	EngineAddress           string
	EngineprecompAddress    string
	UpdatesAddress          string
	MarketAddress           string
	UtilsAddress            string
	PlayandevolveAddress    string
	ShopAddress             string
	TrainingpointsAddress   string
	ConstantsgettersAddress string
	PrivilegedAddress       string
	StakersAddress          string
	DirectoryAddress        string
	ProxyAddress            string
}

func NewByProxyAddress(client *ethclient.Client, address string) (*Contracts, error) {
	proxyContract, err := proxy.NewProxy(common.HexToAddress(address), client)
	if err != nil {
		return nil, err
	}
	directoryAddress, err := proxyContract.Directory(&bind.CallOpts{})
	if err != nil {
		return nil, err
	}
	directoryContract, err := directory.NewDirectory(directoryAddress, client)
	if err != nil {
		return nil, err
	}
	names, addresses, err := directoryContract.GetDirectory(&bind.CallOpts{})
	if err != nil {
		return nil, err
	}
	return newByNamesAndAddresses(
		client,
		address,
		directoryAddress.String(),
		names,
		addresses,
	)
}

func NewByNewDirectoryEvent(client *ethclient.Client, event proxy.ProxyNewDirectory) (*Contracts, error) {
	directoryAddress := event.Addr
	directoryContract, err := directory.NewDirectory(directoryAddress, client)
	if err != nil {
		return nil, err
	}
	names, addresses, err := directoryContract.GetDirectory(&bind.CallOpts{})
	if err != nil {
		return nil, err
	}
	return newByNamesAndAddresses(
		client,
		event.Raw.Address.String(),
		directoryAddress.String(),
		names,
		addresses,
	)
}

func (b Contracts) Clone() (*Contracts, error) {
	return New(
		b.Client,
		b.LeaguesAddress,
		b.AssetsAddress,
		b.EvolutionAddress,
		b.EngineAddress,
		b.EngineprecompAddress,
		b.UpdatesAddress,
		b.MarketAddress,
		b.UtilsAddress,
		b.PlayandevolveAddress,
		b.ShopAddress,
		b.TrainingpointsAddress,
		b.ConstantsgettersAddress,
		b.PrivilegedAddress,
		b.StakersAddress,
		b.DirectoryAddress,
		b.ProxyAddress,
	)
}

func New(
	client *ethclient.Client,
	leaguesAddress string,
	assetsAddress string,
	evolutionAddress string,
	engineAddress string,
	engineprecompAddress string,
	updatesAddress string,
	marketAddress string,
	utilsAddress string,
	playandevolveAddress string,
	shopAddress string,
	trainingpointsAddress string,
	constantsgettersAddress string,
	privilegedAddress string,
	stakersAddress string,
	directoryAddress string,
	proxyAddress string,
) (*Contracts, error) {
	var err error
	if leaguesAddress == "" {
		return nil, errors.New("leaguesAddress empty address")
	}
	if assetsAddress == "" {
		return nil, errors.New("assetsAddress empty address")
	}
	if evolutionAddress == "" {
		return nil, errors.New("evolutionAddress empty address")
	}
	if engineAddress == "" {
		return nil, errors.New("engineAddress empty address")
	}
	if engineprecompAddress == "" {
		return nil, errors.New("engineprecompAddress empty address")
	}
	if updatesAddress == "" {
		return nil, errors.New("updatesAddress empty address")
	}
	if marketAddress == "" {
		return nil, errors.New("marketAddress empty address")
	}
	if utilsAddress == "" {
		return nil, errors.New("utilsAddress empty address")
	}
	if playandevolveAddress == "" {
		return nil, errors.New("playandevolveAddress empty address")
	}
	if shopAddress == "" {
		return nil, errors.New("shopAddress empty address")
	}
	if trainingpointsAddress == "" {
		return nil, errors.New("trainingpointsAddress empty address")
	}
	if constantsgettersAddress == "" {
		return nil, errors.New("constantsgettersAddress empty address")
	}
	if privilegedAddress == "" {
		return nil, errors.New("privilegedAddress empty address")
	}
	if stakersAddress == "" {
		return nil, errors.New("stakersAddress empty address")
	}
	if directoryAddress == "" {
		return nil, errors.New("directoryAddress empty address")
	}
	if proxyAddress == "" {
		return nil, errors.New("proxyAddress empty address")
	}

	contracts := Contracts{}
	contracts.LeaguesAddress = leaguesAddress
	contracts.AssetsAddress = assetsAddress
	contracts.EvolutionAddress = evolutionAddress
	contracts.EngineAddress = engineAddress
	contracts.EngineprecompAddress = engineprecompAddress
	contracts.UpdatesAddress = updatesAddress
	contracts.MarketAddress = marketAddress
	contracts.UtilsAddress = utilsAddress
	contracts.PlayandevolveAddress = playandevolveAddress
	contracts.ShopAddress = shopAddress
	contracts.TrainingpointsAddress = trainingpointsAddress
	contracts.ConstantsgettersAddress = constantsgettersAddress
	contracts.PrivilegedAddress = constantsgettersAddress
	contracts.StakersAddress = stakersAddress
	contracts.DirectoryAddress = directoryAddress
	contracts.ProxyAddress = proxyAddress
	contracts.Client = client

	log.Debug("creating leagues bindings to: ", leaguesAddress)
	contracts.Leagues, err = leagues.NewLeagues(common.HexToAddress(leaguesAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Debug("creating assets bindings to: ", assetsAddress)
	contracts.Assets, err = assets.NewAssets(common.HexToAddress(assetsAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Debug("creating evolution bindings to: ", evolutionAddress)
	contracts.Evolution, err = evolution.NewEvolution(common.HexToAddress(evolutionAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Debug("creating engine bindings to: ", engineAddress)
	contracts.Engine, err = engine.NewEngine(common.HexToAddress(engineAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Debug("creating engineprecomp bindings to: ", engineprecompAddress)
	contracts.Engineprecomp, err = engineprecomp.NewEngineprecomp(common.HexToAddress(engineprecompAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Debug("creating updates bindings to: ", updatesAddress)
	contracts.Updates, err = updates.NewUpdates(common.HexToAddress(updatesAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Debug("Creating Market bindings to: ", marketAddress)
	contracts.Market, err = market.NewMarket(common.HexToAddress(marketAddress), contracts.Client)
	if err != nil {
		log.Fatalf("Failed to connect to the Ethereum client: %v", err)
	}
	log.Debug("Creating Utils bindings to: ", utilsAddress)
	contracts.Utils, err = utils.NewUtils(common.HexToAddress(utilsAddress), contracts.Client)
	if err != nil {
		log.Fatalf("Failed to connect to the Ethereum client: %v", err)
	}
	if contracts.PlayAndEvolve, err = playandevolve.NewPlayandevolve(common.HexToAddress(playandevolveAddress), contracts.Client); err != nil {
		return nil, err
	}
	if contracts.Shop, err = shop.NewShop(common.HexToAddress(shopAddress), contracts.Client); err != nil {
		return nil, err
	}
	if contracts.TrainingPoints, err = trainingpoints.NewTrainingpoints(common.HexToAddress(trainingpointsAddress), contracts.Client); err != nil {
		return nil, err
	}
	if contracts.ConstantsGetters, err = constantsgetters.NewConstantsgetters(common.HexToAddress(constantsgettersAddress), contracts.Client); err != nil {
		return nil, err
	}
	if contracts.Privileged, err = privileged.NewPrivileged(common.HexToAddress(privilegedAddress), contracts.Client); err != nil {
		return nil, err
	}
	if contracts.Stakers, err = stakers.NewStakers(common.HexToAddress(stakersAddress), contracts.Client); err != nil {
		return nil, err
	}
	if contracts.Directory, err = directory.NewDirectory(common.HexToAddress(directoryAddress), contracts.Client); err != nil {
		return nil, err
	}
	if contracts.Proxy, err = proxy.NewProxy(common.HexToAddress(proxyAddress), contracts.Client); err != nil {
		return nil, err
	}

	return &contracts, nil
}

func newByNamesAndAddresses(
	client *ethclient.Client,
	proxyAddress string,
	directoryAddress string,
	names [][32]byte,
	addresses []common.Address,
) (*Contracts, error) {
	if len(names) != len(addresses) {
		return nil, errors.New("names and addresses len mismatch")
	}

	contractMap := make(map[string]string)
	for i := range names {
		name := names[i]
		n := bytes.Index(name[:], []byte{0})
		address := addresses[i]
		contractMap[string(name[:n])] = address.String()
	}

	return New(
		client,
		contractMap[LeaguesName],
		contractMap[AssetsName],
		contractMap[EvolutionName],
		contractMap[EngineName],
		contractMap[EnginePreCompName],
		contractMap[UpdatesName],
		contractMap[MarketName],
		contractMap[UtilsName],
		contractMap[PlayAndEvolveName],
		contractMap[ShopName],
		contractMap[TrainingPointsName],
		contractMap[ConstantsGettersName],
		contractMap[PrivilegedName],
		contractMap[StakersName],
		directoryAddress,
		proxyAddress,
	)
}
