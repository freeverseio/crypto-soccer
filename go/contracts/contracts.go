package contracts

import (
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/assets"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/engine"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/engineprecomp"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/evolution"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/leagues"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/market"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/matchevents"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/updates"
	log "github.com/sirupsen/logrus"
)

type Contracts struct {
	Client        *ethclient.Client
	Leagues       *leagues.Leagues
	Assets        *assets.Assets
	Evolution     *evolution.Evolution
	Engine        *engine.Engine
	Engineprecomp *engineprecomp.Engineprecomp
	Updates       *updates.Updates
	Market        *market.Market
	Matchevents   *matchevents.Matchevents
}

func New(
	client *ethclient.Client,
	leaguesAddress string,
	assetsAddress string,
	evolutionAddress string,
	engineAddress string,
	engineprecompAddress string,
	updatesAddress string,
	marketAddress string,
	matcheventsAddress string,
) (*Contracts, error) {
	var err error
	contracts := Contracts{}
	contracts.Client = client

	log.Info("creating leagues bindings to: ", leaguesAddress)
	contracts.Leagues, err = leagues.NewLeagues(common.HexToAddress(leaguesAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Info("creating assets bindings to: ", assetsAddress)
	contracts.Assets, err = assets.NewAssets(common.HexToAddress(assetsAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Info("creating evolution bindings to: ", evolutionAddress)
	contracts.Evolution, err = evolution.NewEvolution(common.HexToAddress(evolutionAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Info("creating engine bindings to: ", engineAddress)
	contracts.Engine, err = engine.NewEngine(common.HexToAddress(engineAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Info("creating engineprecomp bindings to: ", engineprecompAddress)
	contracts.Engineprecomp, err = engineprecomp.NewEngineprecomp(common.HexToAddress(engineprecompAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Info("creating updates bindings to: ", updatesAddress)
	contracts.Updates, err = updates.NewUpdates(common.HexToAddress(updatesAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Info("Creating Market bindings to: ", marketAddress)
	contracts.Market, err = market.NewMarket(common.HexToAddress(marketAddress), contracts.Client)
	if err != nil {
		log.Fatalf("Failed to connect to the Ethereum client: %v", err)
	}
	log.Info("Creating Matchevents bindings to: ", matcheventsAddress)
	contracts.Matchevents, err = matchevents.NewMatchevents(common.HexToAddress(matcheventsAddress), contracts.Client)
	if err != nil {
		log.Fatalf("Failed to connect to the Ethereum client: %v", err)
	}

	return &contracts, nil
}
