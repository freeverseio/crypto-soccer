package contracts

import (
	"math/big"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/assets"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/constantsgetters"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/engine"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/engineprecomp"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/evolution"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/leagues"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/market"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/playandevolve"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/privileged"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/shop"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/trainingpoints"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/updates"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/utils"
	log "github.com/sirupsen/logrus"
)

type Contracts struct {
	Client                  *ethclient.Client
	Leagues                 *leagues.Leagues
	Assets                  *assets.Assets
	Evolution               *evolution.Evolution
	Engine                  *engine.Engine
	Engineprecomp           *engineprecomp.Engineprecomp
	Updates                 *updates.Updates
	Market                  *market.Market
	Utils                   *utils.Utils
	PlayAndEvolve           *playandevolve.Playandevolve
	Shop                    *shop.Shop
	TrainingPoints          *trainingpoints.Trainingpoints
	ConstantsGetters        *constantsgetters.Constantsgetters
	Privileged              *privileged.Privileged
	leaguesAddress          string
	AssetsAddress           string
	evolutionAddress        string
	engineAddress           string
	engineprecompAddress    string
	updatesAddress          string
	marketAddress           string
	utilsAddress            string
	playandevolveAddress    string
	shopAddress             string
	trainingpointsAddress   string
	constantsgettersAddress string
	privilegedAddress       string
}

func (b Contracts) Clone() (*Contracts, error) {
	return New(
		b.Client,
		b.leaguesAddress,
		b.AssetsAddress,
		b.evolutionAddress,
		b.engineAddress,
		b.engineprecompAddress,
		b.updatesAddress,
		b.marketAddress,
		b.utilsAddress,
		b.playandevolveAddress,
		b.shopAddress,
		b.trainingpointsAddress,
		b.constantsgettersAddress,
		b.privilegedAddress,
	)
}

func New(
	client *ethclient.Client,
	leaguesAddress string,
	assetsAddress string,
	evolutionAddress string,
	engineAddress string,
	engineprecompAddress string,
	updatesAddress string,
	marketAddress string,
	utilsAddress string,
	playandevolveAddress string,
	shopAddress string,
	trainingpointsAddress string,
	constantsgettersAddress string,
	privilegedAddress string,
) (*Contracts, error) {
	var err error
	contracts := Contracts{}
	contracts.leaguesAddress = leaguesAddress
	contracts.AssetsAddress = assetsAddress
	contracts.evolutionAddress = evolutionAddress
	contracts.engineAddress = engineAddress
	contracts.engineprecompAddress = engineprecompAddress
	contracts.updatesAddress = updatesAddress
	contracts.marketAddress = marketAddress
	contracts.utilsAddress = utilsAddress
	contracts.playandevolveAddress = playandevolveAddress
	contracts.shopAddress = shopAddress
	contracts.trainingpointsAddress = trainingpointsAddress
	contracts.constantsgettersAddress = constantsgettersAddress
	contracts.privilegedAddress = constantsgettersAddress
	contracts.Client = client

	log.Debug("creating leagues bindings to: ", leaguesAddress)
	contracts.Leagues, err = leagues.NewLeagues(common.HexToAddress(leaguesAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Debug("creating assets bindings to: ", assetsAddress)
	contracts.Assets, err = assets.NewAssets(common.HexToAddress(assetsAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Debug("creating evolution bindings to: ", evolutionAddress)
	contracts.Evolution, err = evolution.NewEvolution(common.HexToAddress(evolutionAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Debug("creating engine bindings to: ", engineAddress)
	contracts.Engine, err = engine.NewEngine(common.HexToAddress(engineAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Debug("creating engineprecomp bindings to: ", engineprecompAddress)
	contracts.Engineprecomp, err = engineprecomp.NewEngineprecomp(common.HexToAddress(engineprecompAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Debug("creating updates bindings to: ", updatesAddress)
	contracts.Updates, err = updates.NewUpdates(common.HexToAddress(updatesAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Debug("Creating Market bindings to: ", marketAddress)
	contracts.Market, err = market.NewMarket(common.HexToAddress(marketAddress), contracts.Client)
	if err != nil {
		log.Fatalf("Failed to connect to the Ethereum client: %v", err)
	}
	log.Debug("Creating Utils bindings to: ", utilsAddress)
	contracts.Utils, err = utils.NewUtils(common.HexToAddress(utilsAddress), contracts.Client)
	if err != nil {
		log.Fatalf("Failed to connect to the Ethereum client: %v", err)
	}
	if contracts.PlayAndEvolve, err = playandevolve.NewPlayandevolve(common.HexToAddress(playandevolveAddress), contracts.Client); err != nil {
		return nil, err
	}
	if contracts.Shop, err = shop.NewShop(common.HexToAddress(shopAddress), contracts.Client); err != nil {
		return nil, err
	}
	if contracts.TrainingPoints, err = trainingpoints.NewTrainingpoints(common.HexToAddress(trainingpointsAddress), contracts.Client); err != nil {
		return nil, err
	}
	if contracts.ConstantsGetters, err = constantsgetters.NewConstantsgetters(common.HexToAddress(constantsgettersAddress), contracts.Client); err != nil {
		return nil, err
	}
	if contracts.Privileged, err = privileged.NewPrivileged(common.HexToAddress(privilegedAddress), contracts.Client); err != nil {
		return nil, err
	}

	return &contracts, nil
}

func (b Contracts) DecodeSkills(encodedSkills *big.Int) (
	defence *big.Int,
	speed *big.Int,
	pass *big.Int,
	shoot *big.Int,
	endurance *big.Int,
	potencial *big.Int,
	dayOfBirth *big.Int,
	err error,
) {
	// Skills: shoot, speed, pass, defence, endurance
	SK_SHO := uint8(0)
	SK_SPE := uint8(1)
	SK_PAS := uint8(2)
	SK_DEF := uint8(3)
	SK_END := uint8(4)
	opts := &bind.CallOpts{}
	if defence, err = b.Assets.GetSkill(opts, encodedSkills, SK_DEF); err != nil {
		return defence, speed, pass, shoot, endurance, potencial, dayOfBirth, err
	} else if speed, err = b.Assets.GetSkill(opts, encodedSkills, SK_SPE); err != nil {
		return defence, speed, pass, shoot, endurance, potencial, dayOfBirth, err
	} else if pass, err = b.Assets.GetSkill(opts, encodedSkills, SK_PAS); err != nil {
		return defence, speed, pass, shoot, endurance, potencial, dayOfBirth, err
	} else if shoot, err = b.Assets.GetSkill(opts, encodedSkills, SK_SHO); err != nil {
		return defence, speed, pass, shoot, endurance, potencial, dayOfBirth, err
	} else if endurance, err = b.Assets.GetSkill(opts, encodedSkills, SK_END); err != nil {
		return defence, speed, pass, shoot, endurance, potencial, dayOfBirth, err
	} else if potencial, err = b.Assets.GetPotential(opts, encodedSkills); err != nil {
		return defence, speed, pass, shoot, endurance, potencial, dayOfBirth, err
	} else if dayOfBirth, err = b.Assets.GetBirthDay(opts, encodedSkills); err != nil {
		return defence, speed, pass, shoot, endurance, potencial, dayOfBirth, err
	}
	return defence, speed, pass, shoot, endurance, potencial, dayOfBirth, err
}
