package contracts

import (
	"math/big"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/assets"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/engine"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/engineprecomp"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/evolution"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/leagues"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/market"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/matchevents"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/updates"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/utilsmatchlog"
	log "github.com/sirupsen/logrus"
)

type Contracts struct {
	Client               *ethclient.Client
	Leagues              *leagues.Leagues
	Assets               *assets.Assets
	Evolution            *evolution.Evolution
	Engine               *engine.Engine
	Engineprecomp        *engineprecomp.Engineprecomp
	Updates              *updates.Updates
	Market               *market.Market
	Matchevents          *matchevents.Matchevents
	Utilsmatchlog        *utilsmatchlog.Utilsmatchlog
	leaguesAddress       string
	assetsAddress        string
	evolutionAddress     string
	engineAddress        string
	engineprecompAddress string
	updatesAddress       string
	marketAddress        string
	matcheventsAddress   string
	utilsmatchlogAddress string
}

func (b Contracts) Duplicate() (*Contracts, error) {
	return New(
		b.Client,
		b.leaguesAddress,
		b.assetsAddress,
		b.evolutionAddress,
		b.engineAddress,
		b.engineprecompAddress,
		b.updatesAddress,
		b.marketAddress,
		b.matcheventsAddress,
		b.utilsmatchlogAddress,
	)
}

func New(
	client *ethclient.Client,
	leaguesAddress string,
	assetsAddress string,
	evolutionAddress string,
	engineAddress string,
	engineprecompAddress string,
	updatesAddress string,
	marketAddress string,
	matcheventsAddress string,
	utilsmatchlogAddress string,
) (*Contracts, error) {
	var err error
	contracts := Contracts{}
	contracts.leaguesAddress = leaguesAddress
	contracts.assetsAddress = assetsAddress
	contracts.evolutionAddress = evolutionAddress
	contracts.engineAddress = engineAddress
	contracts.engineprecompAddress = engineprecompAddress
	contracts.updatesAddress = updatesAddress
	contracts.marketAddress = marketAddress
	contracts.matcheventsAddress = matcheventsAddress
	contracts.utilsmatchlogAddress = utilsmatchlogAddress

	contracts.Client = client

	log.Debug("creating leagues bindings to: ", leaguesAddress)
	contracts.Leagues, err = leagues.NewLeagues(common.HexToAddress(leaguesAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Debug("creating assets bindings to: ", assetsAddress)
	contracts.Assets, err = assets.NewAssets(common.HexToAddress(assetsAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Debug("creating evolution bindings to: ", evolutionAddress)
	contracts.Evolution, err = evolution.NewEvolution(common.HexToAddress(evolutionAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Debug("creating engine bindings to: ", engineAddress)
	contracts.Engine, err = engine.NewEngine(common.HexToAddress(engineAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Debug("creating engineprecomp bindings to: ", engineprecompAddress)
	contracts.Engineprecomp, err = engineprecomp.NewEngineprecomp(common.HexToAddress(engineprecompAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Debug("creating updates bindings to: ", updatesAddress)
	contracts.Updates, err = updates.NewUpdates(common.HexToAddress(updatesAddress), contracts.Client)
	if err != nil {
		log.Fatalf("failed to connect to the ethereum client: %v", err)
	}
	log.Debug("Creating Market bindings to: ", marketAddress)
	contracts.Market, err = market.NewMarket(common.HexToAddress(marketAddress), contracts.Client)
	if err != nil {
		log.Fatalf("Failed to connect to the Ethereum client: %v", err)
	}
	log.Debug("Creating Matchevents bindings to: ", matcheventsAddress)
	contracts.Matchevents, err = matchevents.NewMatchevents(common.HexToAddress(matcheventsAddress), contracts.Client)
	if err != nil {
		log.Fatalf("Failed to connect to the Ethereum client: %v", err)
	}
	log.Debug("Creating Utilsmatchlog bindings to: ", utilsmatchlogAddress)
	contracts.Utilsmatchlog, err = utilsmatchlog.NewUtilsmatchlog(common.HexToAddress(utilsmatchlogAddress), contracts.Client)
	if err != nil {
		log.Fatalf("Failed to connect to the Ethereum client: %v", err)
	}

	return &contracts, nil
}

func (b Contracts) DecodeSkills(encodedSkills *big.Int) (
	defence *big.Int,
	speed *big.Int,
	pass *big.Int,
	shoot *big.Int,
	endurance *big.Int,
	potencial *big.Int,
	dayOfBirth *big.Int,
	err error,
) {
	opts := &bind.CallOpts{}
	if defence, err = b.Assets.GetDefence(opts, encodedSkills); err != nil {
		return defence, speed, pass, shoot, endurance, potencial, dayOfBirth, err
	} else if speed, err = b.Assets.GetSpeed(opts, encodedSkills); err != nil {
		return defence, speed, pass, shoot, endurance, potencial, dayOfBirth, err
	} else if pass, err = b.Assets.GetPass(opts, encodedSkills); err != nil {
		return defence, speed, pass, shoot, endurance, potencial, dayOfBirth, err
	} else if shoot, err = b.Assets.GetShoot(opts, encodedSkills); err != nil {
		return defence, speed, pass, shoot, endurance, potencial, dayOfBirth, err
	} else if endurance, err = b.Assets.GetEndurance(opts, encodedSkills); err != nil {
		return defence, speed, pass, shoot, endurance, potencial, dayOfBirth, err
	} else if potencial, err = b.Assets.GetPotential(opts, encodedSkills); err != nil {
		return defence, speed, pass, shoot, endurance, potencial, dayOfBirth, err
	} else if dayOfBirth, err = b.Assets.GetBirthDay(opts, encodedSkills); err != nil {
		return defence, speed, pass, shoot, endurance, potencial, dayOfBirth, err
	}
	return defence, speed, pass, shoot, endurance, potencial, dayOfBirth, err
}
