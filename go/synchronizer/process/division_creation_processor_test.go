package process_test

import (
	"math/big"
	"testing"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/assets"
	"github.com/freeverseio/crypto-soccer/go/names"
	"github.com/freeverseio/crypto-soccer/go/storage"
	"github.com/freeverseio/crypto-soccer/go/synchronizer/process"
	"gotest.tools/assert"
	"gotest.tools/golden"
)

func TestDivisionCreationProcessConstants(t *testing.T) {
	SK_SHO, err := bc.Contracts.ConstantsGetters.GetSKSHO(&bind.CallOpts{})
	assert.NilError(t, err)
	assert.Equal(t, SK_SHO, process.SK_SHO)
	SK_SPE, err := bc.Contracts.ConstantsGetters.GetSKSPE(&bind.CallOpts{})
	assert.NilError(t, err)
	assert.Equal(t, SK_SPE, process.SK_SPE)
	SK_PAS, err := bc.Contracts.ConstantsGetters.GetSKPAS(&bind.CallOpts{})
	assert.NilError(t, err)
	assert.Equal(t, SK_PAS, process.SK_PAS)
	SK_DEF, err := bc.Contracts.ConstantsGetters.GetSKDEF(&bind.CallOpts{})
	assert.NilError(t, err)
	assert.Equal(t, SK_DEF, process.SK_DEF)
	SK_END, err := bc.Contracts.ConstantsGetters.GetSKEND(&bind.CallOpts{})
	assert.NilError(t, err)
	assert.Equal(t, SK_END, process.SK_END)
	LEAGUES_PER_DIV, err := bc.Contracts.ConstantsGetters.GetLEAGUESPERDIV(&bind.CallOpts{})
	assert.NilError(t, err)
	assert.Equal(t, LEAGUES_PER_DIV, process.LEAGUES_PER_DIV)
	TEAMS_PER_LEAGUE, err := bc.Contracts.ConstantsGetters.GetTEAMSPERLEAGUE(&bind.CallOpts{})
	assert.NilError(t, err)
	assert.Equal(t, TEAMS_PER_LEAGUE, process.TEAMS_PER_LEAGUE)
	PLAYERS_PER_TEAM_INIT, err := bc.Contracts.ConstantsGetters.GetPLAYERSPERTEAMINIT(&bind.CallOpts{})
	assert.NilError(t, err)
	assert.Equal(t, PLAYERS_PER_TEAM_INIT, process.PLAYERS_PER_TEAM_INIT)
}

func TestDivisionCreationProcess(t *testing.T) {
	t.Parallel()
	tx, err := universedb.Begin()
	if err != nil {
		t.Fatal(err)
	}
	defer tx.Rollback()

	namesdb, err := names.New("../../names/sql/names.db")
	if err != nil {
		t.Fatal(err)
	}
	process, err := process.NewDivisionCreationProcessor(bc.Contracts, namesdb)
	if err != nil {
		t.Fatal(err)
	}

	timezone := uint8(1)
	event := assets.AssetsDivisionCreation{
		Timezone:             timezone,
		CountryIdxInTZ:       big.NewInt(0),
		DivisionIdxInCountry: big.NewInt(0),
	}
	err = process.Process(tx, event)
	if err != nil {
		t.Fatal(err)
	}

	matches, err := storage.MatchesByTimezoneIdxCountryIdxLeagueIdxMatchdayIdx(tx, 1, 0, 0, 0)
	if err != nil {
		t.Fatal(err)
	}
	golden.Assert(t, dump.Sdump(matches), t.Name()+".matches.1.golden")
	matches, err = storage.MatchesByTimezoneIdxCountryIdxLeagueIdx(tx, 1, 0, 0)
	if err != nil {
		t.Fatal(err)
	}
	golden.Assert(t, dump.Sdump(matches), t.Name()+".matches.2.golden")

	// check for trainings
	trainings, err := storage.TrainingsByTimezone(tx, int(timezone))
	assert.NilError(t, err)
	assert.Equal(t, len(trainings), 128)
}
