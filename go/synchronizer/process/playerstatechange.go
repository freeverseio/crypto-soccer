package process

import (
	"database/sql"
	"errors"
	"math/big"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/freeverseio/crypto-soccer/go/contracts"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/assets"
	"github.com/freeverseio/crypto-soccer/go/synchronizer/storage"
	"github.com/freeverseio/crypto-soccer/go/synchronizer/utils"
	log "github.com/sirupsen/logrus"
)

func PlayerStateChangeProcess(
	tx *sql.Tx,
	contracts *contracts.Contracts,
	event assets.AssetsPlayerStateChange,
) error {
	playerID := event.PlayerId
	state := event.State
	player, err := storage.PlayerByPlayerId(tx, playerID)
	if err != nil {
		return err
	}
	if player == nil {
		log.Infof("BIRTH ... player ID %v state %v", playerID, state)
		if player, err = GeneratePlayerByPlayerIdAndState(contracts, playerID, state); err != nil {
			return err
		}
		return player.Insert(tx)
	}
	shirtNumber, err := contracts.Assets.GetCurrentShirtNum(&bind.CallOpts{}, state)
	if err != nil {
		return err
	}
	teamID, err := contracts.Assets.GetCurrentTeamId(&bind.CallOpts{}, state)
	if err != nil {
		return err
	}
	player.State.TeamId = teamID
	player.State.ShirtNumber = uint8(shirtNumber.Uint64())
	return player.Update(tx, playerID, player.State)
}

func GeneratePlayerByPlayerIdAndState(
	contracts *contracts.Contracts,
	playerId *big.Int,
	encodedState *big.Int,
) (*storage.Player, error) {
	opts := &bind.CallOpts{}
	if encodedSkills, err := contracts.Assets.GetPlayerSkillsAtBirth(opts, playerId); err != nil {
		return nil, err
	} else if defence, speed, pass, shoot, endurance, potential, dayOfBirth, err := utils.DecodeSkills(contracts.Assets, encodedSkills); err != nil {
		return nil, err
	} else if preferredPosition, err := GetPlayerPreferredPosition(contracts, encodedSkills); err != nil {
		return nil, err
	} else if shirtNumber, err := contracts.Assets.GetCurrentShirtNum(opts, encodedState); err != nil {
		return nil, err
		// } else if name, err := namesGenerator.GeneratePlayerFullName(playerId, generation, timezone, countryIdx.Uint64()); err != nil {
		// 	return err
	} else {
		name := "Awesome"
		teamId, err := contracts.Assets.GetCurrentTeamId(&bind.CallOpts{}, encodedState)
		if err != nil {
			return nil, err
		}
		player := storage.Player{
			PlayerId:          playerId,
			PreferredPosition: preferredPosition,
			Potential:         potential.Uint64(),
			DayOfBirth:        dayOfBirth.Uint64(),
			State: storage.PlayerState{ // TODO: storage should use same skill ordering as BC
				TeamId:        teamId,
				Name:          name,
				Defence:       defence.Uint64(), // TODO: type should be uint16
				Speed:         speed.Uint64(),
				Pass:          pass.Uint64(),
				Shoot:         shoot.Uint64(),
				Endurance:     endurance.Uint64(),
				ShirtNumber:   uint8(shirtNumber.Uint64()),
				EncodedSkills: encodedSkills,
				EncodedState:  encodedState,
				Frozen:        false,
			},
		}
		return &player, nil
	}
}

func GetPlayerPreferredPosition(contracts *contracts.Contracts, encodedSkills *big.Int) (string, error) {
	opts := &bind.CallOpts{}
	if forwardness, err := contracts.Assets.GetForwardness(opts, encodedSkills); err != nil {
		return "", err
	} else if leftishness, err := contracts.Assets.GetLeftishness(opts, encodedSkills); err != nil {
		return "", err
	} else {
		if forwardness.Uint64() > 255 {
			return "", errors.New("Cannot cast forwardness to uint8: value too large")
		} else if leftishness.Uint64() > 255 {
			return "", errors.New("Cannot cast leftishness to uint8: value too large")
		}
		return utils.PreferredPosition(uint8(forwardness.Uint64()), uint8(leftishness.Uint64()))
	}
}
