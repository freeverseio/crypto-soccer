package process

import (
	"context"
	"errors"
	"fmt"
	"math"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/core/types"

	"github.com/freeverseio/crypto-soccer/go/contracts"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/assets"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/market"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/updates"
	"github.com/freeverseio/crypto-soccer/go/names"
	relay "github.com/freeverseio/crypto-soccer/go/relay/storage"
	"github.com/freeverseio/crypto-soccer/go/synchronizer/storage"
	log "github.com/sirupsen/logrus"
)

type EventProcessor struct {
	contracts                 *contracts.Contracts
	universedb                *storage.Storage
	relaydb                   *relay.Storage
	assetsInitProcessor       *AssetsInitProcessor
	divisionCreationProcessor *DivisionCreationProcessor
	leagueProcessor           *LeagueProcessor
}

// *****************************************************************************
// public
// *****************************************************************************

// NewEventProcessor creates a new struct for scanning and storing crypto soccer events
func NewEventProcessor(
	contracts *contracts.Contracts,
	universedb *storage.Storage,
	relaydb *relay.Storage,
	namesdb *names.Generator,
) (*EventProcessor, error) {
	assetsInitProcessor, err := NewAssetsInitProcessor(
		contracts,
		universedb,
		relaydb,
	)
	if err != nil {
		return nil, err
	}
	divisionCreationProcessor, err := NewDivisionCreationProcessor(
		contracts,
		universedb,
		relaydb,
		namesdb,
	)
	if err != nil {
		return nil, err
	}
	leagueProcessor, err := NewLeagueProcessor(
		contracts,
		universedb,
		relaydb,
		namesdb,
	)
	if err != nil {
		return nil, err
	}
	return &EventProcessor{
		contracts,
		universedb,
		relaydb,
		assetsInitProcessor,
		divisionCreationProcessor,
		leagueProcessor,
	}, nil
}

// Process processes all scanned events and stores them into the database db
func (p *EventProcessor) Process(delta uint64) (uint64, error) {
	opts, err := p.nextRange(delta)
	if err != nil {
		return 0, err
	}

	if opts == nil {
		log.Info("No new blocks to scan.")
		return 0, nil
	}

	log.WithFields(log.Fields{
		"start": opts.Start,
		"end":   *opts.End,
	}).Info("Syncing ...")

	scanner := NewEventScanner(p.contracts)
	if scanner == nil {
		return opts.Start, errors.New("Unable to create scanner")
	}
	if err := scanner.Process(opts); err != nil {
		return 0, err
	} else {
		for _, v := range scanner.Events {
			if err := p.dispatch(v); err != nil {
				return 0, err
			}
		}
	}

	deltaBlock := *opts.End - opts.Start

	// store the last block that was scanned
	return deltaBlock, p.universedb.SetBlockNumber(*opts.End)
}

func (p *EventProcessor) ProcessTeamTransfer(v assets.AssetsTeamTransfer) error {
	teamID := v.TeamId
	newOwner := v.To.String()
	team, err := p.universedb.GetTeam(teamID)
	if err != nil {
		return err
	}
	// team.State.BlockNumber = blockNumber
	team.State.Owner = newOwner
	return p.universedb.TeamUpdate(teamID, team.State)
}

// *****************************************************************************
// private
// *****************************************************************************
func (p *EventProcessor) dispatch(e *AbstractEvent) error {
	log.Debugf("[process] dispach event block %v inBlockIndex %v", e.BlockNumber, e.TxIndexInBlock)

	switch v := e.Value.(type) {
	case assets.AssetsAssetsInit:
		log.Infof("[processor] Dispatching AssetsInit event from account %v", v.CreatorAddr)
		return p.assetsInitProcessor.Process(v)
	case assets.AssetsDivisionCreation:
		log.Infof("[processor] Dispatching LeaguesDivisionCreation event Timezone %v, CountryIdxInTZ: %v, DivisionIdxInCountry %v", v.Timezone, v.CountryIdxInTZ, v.DivisionIdxInCountry)
		return p.divisionCreationProcessor.Process(v)
	case assets.AssetsTeamTransfer:
		log.Infof("[processor] dispatching LeaguesTeamTransfer event TeamID: %v, To: %v", v.TeamId, v.To)
		return p.ProcessTeamTransfer(v)
	case assets.AssetsPlayerStateChange:
		log.Infof("[processor] dispatching LeaguesPlayerStateChange event PlayerID %v", v.PlayerId)
		playerID := v.PlayerId
		state := v.State
		shirtNumber, err := p.contracts.Assets.GetCurrentShirtNum(&bind.CallOpts{}, state)
		if err != nil {
			return err
		}
		teamID, err := p.contracts.Assets.GetCurrentTeamId(&bind.CallOpts{}, state)
		if err != nil {
			return err
		}
		player, err := p.universedb.GetPlayer(playerID)
		if err != nil {
			return err
		}
		player.State.TeamId = teamID
		player.State.ShirtNumber = uint8(shirtNumber.Uint64())
		return p.universedb.PlayerUpdate(playerID, player.State)
	case updates.UpdatesActionsSubmission:
		log.Infof("[processor] Dispatching UpdatesActionsSubmission event Timezone: %v, Day: %v, TurnInDay: %v", v.TimeZone, v.Day, v.TurnInDay)
		return p.leagueProcessor.Process(v)
	case market.MarketPlayerFreeze:
		log.Infof("[processor] Dispatching MarketPlayerFreeze event PlayerID: %v Frozen: %v", v.PlayerId, v.Frozen)
		playerID := v.PlayerId
		player, err := p.universedb.GetPlayer(playerID)
		if err != nil {
			return err
		}
		player.State.Frozen = v.Frozen
		return p.universedb.PlayerUpdate(playerID, player.State)
	}
	return fmt.Errorf("[processor] Error dispatching unknown event type: %s", e.Name)
}
func (p *EventProcessor) nextRange(delta uint64) (*bind.FilterOpts, error) {
	start, err := p.dbLastBlockNumber()
	if err != nil {
		return nil, err
	}
	if start != 0 {
		// unless this is the very first execution,
		// the block number that is stored in the db
		// was already scanned. We are interested in
		// the next block
		if start < math.MaxUint64 {
			start += 1
		} else {
			return nil, errors.New("Block range overflow")
		}
	}
	end := p.clientLastBlockNumber()
	if delta != 0 {
		end = uint64(math.Min(float64(start+delta), float64(end)))
	}
	if start > end {
		return nil, nil
	}
	return &bind.FilterOpts{
		Start:   start,
		End:     &end,
		Context: context.Background(),
	}, nil
}

func (p *EventProcessor) clientLastBlockNumber() uint64 {
	if p.contracts.Client == nil {
		log.Warn("Client is nil. Returning 0 as last block.")
		return 0
	}
	header, err := p.contracts.Client.HeaderByNumber(context.Background(), nil)
	if err != nil {
		log.Warn("Could not get blockchain last block")
		return 0
	}
	return header.Number.Uint64()
}
func (p *EventProcessor) dbLastBlockNumber() (uint64, error) {
	storedLastBlockNumber, err := p.universedb.GetBlockNumber()
	if err != nil {
		return 0, err
	}
	return storedLastBlockNumber, err
}
func (p *EventProcessor) getTimeOfEvent(eventRaw types.Log) (uint64, uint64, error) {
	block, err := p.contracts.Client.BlockByHash(context.Background(), eventRaw.BlockHash)
	if err != nil {
		return 0, 0, err
	}
	return block.Time(), eventRaw.BlockNumber, nil
}
