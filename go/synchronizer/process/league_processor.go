package process

import (
	"context"
	"database/sql"
	"encoding/hex"
	"fmt"
	"math/big"
	"sort"

	"github.com/spf13/viper"

	"github.com/freeverseio/crypto-soccer/go/synchronizer/leaderboard"
	"github.com/pkg/errors"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/freeverseio/crypto-soccer/go/contracts"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/updates"
	"github.com/freeverseio/crypto-soccer/go/storage"
	storagepostgres "github.com/freeverseio/crypto-soccer/go/storage/postgres"
	"github.com/freeverseio/crypto-soccer/go/useractions"
	"github.com/freeverseio/crypto-soccer/go/useractions/postgres"

	log "github.com/sirupsen/logrus"
)

type LeagueProcessor struct {
	contracts            *contracts.Contracts
	calendarProcessor    *Calendar
	useractionsPublisher useractions.UserActionsPublishService
}

type TeamWithState struct {
	Team      storage.Team
	TeamState [25]*big.Int
}

type TeamsWithStateInLeague struct {
	TeamsWithState [8]TeamWithState
}

func NewLeagueProcessor(
	contracts *contracts.Contracts,
	useractionsPublisher useractions.UserActionsPublishService,
) *LeagueProcessor {
	calendarProcessor := NewCalendar(contracts)
	return &LeagueProcessor{
		contracts,
		calendarProcessor,
		useractionsPublisher,
	}
}

func (b *LeagueProcessor) resetTimezone(tx *sql.Tx, timezoneIdx uint8, verse *big.Int) error {
	log.Infof("[processor|consume] shuffling timezone %v and create calendars", timezoneIdx)
	countryCount, err := storage.CountryInTimezoneCount(tx, timezoneIdx)
	if err != nil {
		return err
	}

	verseNumber := verse.Uint64()
	zombieVerse := viper.GetUint64("patch.use_zombies")

	for countryIdx := uint32(0); countryIdx < countryCount; countryIdx++ {
		// if a new league is starting shuffle the teams
		if verseNumber >= zombieVerse {
			if verseNumber == zombieVerse {
				log.Infof("[%v] Start detecting zombies and shuffling them after bots", zombieVerse)
			}
			err = b.UpdatePrevPerfPointsAndShuffleTeamsInCountryWithZombies(tx, timezoneIdx, countryIdx)
			if err != nil {
				return err
			}
		} else {
			err = b.UpdatePrevPerfPointsAndShuffleTeamsInCountry(tx, timezoneIdx, countryIdx)
			if err != nil {
				return err
			}
		}
		leagueCount, err := storage.LeagueCountByTimezoneIdxCountryIdx(tx, timezoneIdx, countryIdx)
		if err != nil {
			return err
		}
		for leagueIdx := uint32(0); leagueIdx < leagueCount; leagueIdx++ {
			if err = b.resetLeague(tx, timezoneIdx, countryIdx, leagueIdx, verse); err != nil {
				return err
			}
			if err = storage.DeleteAllMatchEvents(tx, int(timezoneIdx), int(countryIdx), int(leagueIdx)); err != nil {
				return err
			}
		}
	}
	return nil
}

func (b *LeagueProcessor) Process(tx *sql.Tx, event updates.UpdatesActionsSubmission) error {
	day := event.Day
	turnInDay := event.TurnInDay
	timezoneIdx := event.TimeZone

	if timezoneIdx == 0 {
		return nil
	}

	if timezoneIdx < 1 || timezoneIdx > 24 {
		return fmt.Errorf("Unexistent timezone %v", timezoneIdx)
	}
	if turnInDay == 2 || turnInDay == 3 {
		return nil
	}

	log.Infof("[processor|timezone %v] start process matches ...", timezoneIdx)

	verse := event.Verse.Uint64()

	verseResetTimezone24 := viper.GetUint64("patch.reset_timezone_24")
	verseResetTimezone1 := viper.GetUint64("patch.reset_timezone_1")

	if verseResetTimezone24 != 0 && verse == verseResetTimezone24 {
		log.Infof("[%v|BUG] forcing reset timezone 24", verseResetTimezone24)
		if err := b.resetTimezone(tx, 24, event.Verse); err != nil {
			return err
		}
	} else if verseResetTimezone1 != 0 && verse == verseResetTimezone1 {
		log.Infof("[%v|BUG] forcing reset timezone 1", verseResetTimezone1)
		if err := b.resetTimezone(tx, 1, event.Verse); err != nil {
			return err
		}
	} else {
		var timezoneToReshuffle uint8
		var err error
		transitionVerse := uint64(910)
		if event.Verse.Uint64() < transitionVerse {
			timezoneToReshuffle, err = TimezoneToReshuffleOld(timezoneIdx, day, turnInDay)
		} else {
			if event.Verse.Uint64() == transitionVerse {
				log.Infof("[%v|BUG] transitioning to new TimezoneToReshuffle function", transitionVerse)
			}
			timezoneToReshuffle, err = TimezoneToReshuffle(timezoneIdx, day, turnInDay)
		}
		if err != nil {
			return err
		}
		if timezoneToReshuffle != 0 {
			if err := b.resetTimezone(tx, timezoneToReshuffle, event.Verse); err != nil {
				return err
			}
		}
	}

	log.Infof("[processor|timezone %v] Retriving user actions %v", timezoneIdx, event.IpfsCid)
	userActions, err := b.useractionsPublisher.Retrive(event.IpfsCid)
	if err != nil {
		return err
	}
	root, err := userActions.Root()
	if err != nil {
		return err
	}
	if root != event.Root {
		return fmt.Errorf("UserActions Root mismatch bc: %v ipfs: %v", hex.EncodeToString(event.Root[:]), hex.EncodeToString(root[:]))
	}

	log.Infof("[processor|timezone %v] loading matches from storage", timezoneIdx)
	matches, err := NewMatchesFromTimezoneIdxMatchdayIdx(tx, timezoneIdx, day)
	if err != nil {
		return err
	}
	matches.SetSeed(event.Seed)
	matches.SetStartTime(event.SubmissionTime)
	if err := matches.SetTactics(*b.contracts, userActions.Tactics); err != nil {
		return err
	}
	if err := matches.SetTrainings(*b.contracts, userActions.Trainings); err != nil {
		return err
	}
	switch turnInDay {
	case 0:
		log.Infof("[processor|timezone %v] reset trainings", timezoneIdx)
		if err = storage.ResetTrainingsByTimezone(tx, timezoneIdx); err != nil {
			return err
		}
		log.Infof("[processor|timezone %v] processing 1st half of %v matches", timezoneIdx, len(*matches))
		if err = matches.Play1stHalfParallel(context.TODO(), *b.contracts); err != nil {
			return err
		}
	case 1:
		log.Infof("[processor|timezone %v] processing 2nd half of %v matches", timezoneIdx, len(*matches))
		if err = matches.Play2ndHalfParallel(context.TODO(), *b.contracts); err != nil {
			return err
		}
	default:
		return fmt.Errorf("Unknown turn in day %v", turnInDay)
	}
	log.Infof("[processor|timezone %v] save user action in history", timezoneIdx)
	useractionsHistoryService := postgres.NewUserActionsStorageService(tx)
	if err := useractionsHistoryService.InsertHistory(event.Raw.BlockNumber, *userActions); err != nil {
		return err
	}
	log.Infof("[processor|timezone %v] save matches to storage", timezoneIdx)
	if err = matches.ToStorage(*b.contracts, tx, event.Raw.BlockNumber); err != nil {
		return err
	}

	verse12290SkipUpdateLeaderboardFix := viper.GetBool("patch.verse_12290_skip_update_leaderboard_fix")
	if !(verse12290SkipUpdateLeaderboardFix && verse == 12290) {
		if turnInDay == 1 {
			log.Infof("[processor|timezone %v] update leaderboard", timezoneIdx)
			leaderboardService := leaderboard.NewLeaderboardService(storagepostgres.NewStorageService(tx))

			verseCalculateLeaderboardFix := viper.GetUint64("patch.calculate_leaderboard_fix")

			if verse < verseCalculateLeaderboardFix {
				if err := leaderboardService.UpdateTimezoneLeaderboards(*b.contracts, int(timezoneIdx), int(day)); err != nil {
					return errors.Wrap(err, "failed updating timezone leaderboard")
				}
			} else {
				if verse == verseCalculateLeaderboardFix {
					log.Infof("[%v|BUG] switching to new calculate leaderboard function", verseCalculateLeaderboardFix)
				}
				if err := leaderboardService.UpdateTimezoneLeaderboardsNew(*b.contracts, int(timezoneIdx), int(day)); err != nil {
					return errors.Wrap(err, "failed updating timezone leaderboard")
				}
			}
		}
	}

	log.Infof("[processor|timezone %v] ... end", timezoneIdx)

	return nil
}

func (b *LeagueProcessor) UpdatePrevPerfPointsAndShuffleTeamsInCountry(tx *sql.Tx, timezoneIdx uint8, countryIdx uint32) error {
	log.Debugf("Shuffling timezone %v, country %v", timezoneIdx, countryIdx)
	var orgMap OrgMap
	leagueCount, err := storage.LeagueCountByTimezoneIdxCountryIdx(tx, timezoneIdx, countryIdx)
	if err != nil {
		return err
	}
	for leagueIdx := uint32(0); leagueIdx < leagueCount; leagueIdx++ {
		teams, err := storage.TeamsByTimezoneIdxCountryIdxLeagueIdx(tx, timezoneIdx, countryIdx, leagueIdx)
		if err != nil {
			return err
		}
		// ordening by points
		sort.Slice(teams[:], func(i, j int) bool {
			return teams[i].LeaderboardPosition < teams[j].LeaderboardPosition
		})
		for position, team := range teams {
			teamState, err := b.GetTeamState(tx, team.TeamID)
			if err != nil {
				return err
			}
			if !team.IsBot() {
				log.Debugf("[LeagueProcessor] Compute team ranking points team %v, teamState %v", team, teamState)
				teamID, _ := new(big.Int).SetString(team.TeamID, 10)
				team.RankingPoints, team.PrevPerfPoints, err = b.contracts.Leagues.ComputeTeamRankingPoints(
					&bind.CallOpts{},
					teamState,
					uint8(position),
					team.PrevPerfPoints,
					teamID,
					team.IsBot(),
				)
				if err != nil {
					return err
				}
			}
			log.Debugf("New ranking team %v points %v ranking %v", team.TeamID, team.Points, team.RankingPoints)
			if err := orgMap.Append(team); err != nil {
				return err
			}
		}
	}

	orgMap.Sort()

	// create the new leagues
	for i := 0; i < orgMap.Size(); i++ {
		team := orgMap.At(i)
		team.LeagueIdx = uint32(i / 8)
		team.TeamIdxInLeague = uint32(i % 8)
		// calculate the real Ranking points
		// the blockchain returns R * A, where:
		// - R is the real Ranking points, normalized so that an average team starts with 40 points
		// - A is denominator, not applied to avoid losing precision in division, A = 10*(5*18*1000)*2^28 = 241591910400000
		// previously we divided by a factor that incorrectly missed the "5" accounting for the 5 skills
		// instead of fixing it here, we leave the factor as it was, and tell the frontend to divide by an extra 5.
		team.RankingPoints = team.RankingPoints / uint64(48318382080000) // 48318382080000 * 5 = 241591910400000
		if err := team.Update(tx); err != nil {
			return err
		}
	}
	return nil
}

func (b *LeagueProcessor) TeamsWithStateByTimezoneIdxCountryIdxLeagueIdx(tx *sql.Tx, timezoneIdx uint8, countryIdx uint32, leagueIdx uint32) (TeamsWithStateInLeague, error) {
	var teamsWithState TeamsWithStateInLeague
	teamIds, err := storage.TeamIdsByTimezoneIdxCountryIdxLeagueIdx(tx, timezoneIdx, countryIdx, leagueIdx)
	if err != nil {
		return teamsWithState, err
	}
	if len(teamIds) != 8 {
		return teamsWithState, errors.New("league does not have 8 teams")
	}
	for i := 0; i < len(teamIds); i++ {
		teamID := teamIds[i]
		var team storage.Team
		team, err = storage.TeamByTeamId(tx, teamID)
		teamState, err := b.GetTeamState(tx, team.TeamID)
		if err != nil {
			return teamsWithState, err
		}
		var teamWithState = TeamWithState{team, teamState}
		if err != nil {
			return teamsWithState, err
		}
		teamsWithState.TeamsWithState[i] = teamWithState
	}
	return teamsWithState, nil
}

func (b *LeagueProcessor) ComputeRankingPoints(t TeamsWithStateInLeague) (TeamsWithStateInLeague, error) {
	var err error
	var out_t TeamsWithStateInLeague

	for i, teamWithState := range t.TeamsWithState {
		team := teamWithState.Team
		state := teamWithState.TeamState
		if !team.IsBot() {
			log.Debugf("[LeagueProcessor] Compute team ranking points team %v, teamState %v", team, state)
			teamID, _ := new(big.Int).SetString(team.TeamID, 10)
			team.RankingPoints, team.PrevPerfPoints, err = b.contracts.Leagues.ComputeTeamRankingPoints(
				&bind.CallOpts{},
				state,
				uint8(team.LeaderboardPosition),
				team.PrevPerfPoints,
				teamID,
				team.IsBot(),
			)
			if err != nil {
				return t, err
			}
		}
		out_t.TeamsWithState[i] = TeamWithState{Team: team, TeamState: state}
		log.Debugf("New ranking team %v points %v ranking %v leadPos %v", team.TeamID, team.Points, team.RankingPoints, team.LeaderboardPosition)
	}

	return out_t, nil
}

func (b *LeagueProcessor) SplitZombiesFromHumans(t TeamsWithStateInLeague) (OrgMap, OrgMap, error) {
	var orgMap OrgMap
	var zombieOrgMap OrgMap

	for _, teamWithState := range t.TeamsWithState {
		team := teamWithState.Team
		if team.IsZombie {
			if err := zombieOrgMap.Append(team); err != nil {
				return orgMap, zombieOrgMap, err
			}
		} else {
			if err := orgMap.Append(team); err != nil {
				return orgMap, zombieOrgMap, err
			}
		}
	}
	return orgMap, zombieOrgMap, nil
}

func (b *LeagueProcessor) UpdatePrevPerfPointsAndShuffleTeamsInCountryWithZombies(tx *sql.Tx, timezoneIdx uint8, countryIdx uint32) error {
	log.Debugf("Shuffling timezone %v, country %v", timezoneIdx, countryIdx)

	leagueCount, err := storage.LeagueCountByTimezoneIdxCountryIdx(tx, timezoneIdx, countryIdx)
	if err != nil {
		return err
	}
	if err != nil {
		return err
	}
	// Suggest to make Clean set ALL = false
	err = storage.TeamCleanZombies(tx)
	if err != nil {
		return err
	}
	err = storage.TeamUpdateZombies(tx)
	if err != nil {
		return err
	}

	var teamStatesPerLeague []TeamsWithStateInLeague
	for leagueIdx := uint32(0); leagueIdx < leagueCount; leagueIdx++ {
		teamsWithStateInLeague, err := b.TeamsWithStateByTimezoneIdxCountryIdxLeagueIdx(tx, timezoneIdx, countryIdx, leagueIdx)
		if err != nil {
			return err
		}
		teamStatesPerLeague = append(teamStatesPerLeague, teamsWithStateInLeague)
	}

	orgMap, err := b.GenerateOrgMap(teamStatesPerLeague)
	if err != nil {
		return err
	}

	// create the new leagues
	for i := 0; i < orgMap.Size(); i++ {
		team := orgMap.At(i)
		team.LeagueIdx = uint32(i / 8)
		team.TeamIdxInLeague = uint32(i % 8)
		// calculate the real Ranking points
		// the blockchain returns R * A, where:
		// - R is the real Ranking points, normalized so that an average team starts with 40 points
		// - A is denominator, not applied to avoid losing precision in division, A = 10*(5*18*1000)*2^28 = 241591910400000
		// previously we divided by a factor that incorrectly missed the "5" accounting for the 5 skills
		// instead of fixing it here, we leave the factor as it was, and tell the frontend to divide by an extra 5.
		team.RankingPoints = team.RankingPoints / uint64(48318382080000) // 48318382080000 * 5 = 241591910400000
		if err := team.Update(tx); err != nil {
			return err
		}
	}
	return nil
}

func (b *LeagueProcessor) GenerateOrgMap(teamStatesPerLeague []TeamsWithStateInLeague) (OrgMap, error) {
	var orgMap OrgMap
	var zombieOrgMap OrgMap

	for leagueIdx := uint32(0); leagueIdx < uint32(len(teamStatesPerLeague)); leagueIdx++ {
		teamsWithUpdatedRankingPoints, err := b.ComputeRankingPoints(teamStatesPerLeague[leagueIdx])
		if err != nil {
			return orgMap, err
		}
		leagueOrgMap, leagueZombieOrgMap, err := b.SplitZombiesFromHumans(teamsWithUpdatedRankingPoints)

		orgMap.AppendOrgMap(leagueOrgMap)
		zombieOrgMap.AppendOrgMap(leagueZombieOrgMap)
		if err != nil {
			return orgMap, err
		}
	}
	orgMap.Sort()
	zombieOrgMap.Sort()
	orgMap.AppendOrgMap(zombieOrgMap)
	return orgMap, nil
}

func (b *LeagueProcessor) GetTeamState(tx *sql.Tx, teamID string) ([25]*big.Int, error) {
	var state [25]*big.Int
	for i := 0; i < 25; i++ {
		state[i] = big.NewInt(0)
	}
	players, err := storage.ActivePlayersByTeamId(tx, teamID)
	if err != nil {
		return state, err
	}
	for i := 0; i < len(players); i++ {
		player := players[i]
		playerSkills := player.EncodedSkills
		shirtNumber := player.ShirtNumber
		state[shirtNumber] = playerSkills
	}
	return state, nil
}

func (b *LeagueProcessor) resetLeague(tx *sql.Tx, timezoneIdx uint8, countryIdx uint32, leagueIdx uint32, verse *big.Int) error {
	teams, err := storage.TeamsByTimezoneIdxCountryIdxLeagueIdx(tx, timezoneIdx, countryIdx, leagueIdx)
	if err != nil {
		return err
	}
	for i := 0; i < len(teams); i++ {
		team := teams[i]
		team.D = 0
		team.W = 0
		team.L = 0
		team.GoalsAgainst = 0
		team.GoalsForward = 0
		team.Points = 0
		err = team.Update(tx)
		if err != nil {
			return err
		}
	}
	err = b.calendarProcessor.Reset(tx, timezoneIdx, countryIdx, leagueIdx)
	if err != nil {
		return err
	}
	matchesStart, err := b.calendarProcessor.GetAllMatchdaysUTCInNextRound(timezoneIdx, verse)
	if err != nil {
		return err
	}
	err = b.calendarProcessor.Populate(tx, timezoneIdx, countryIdx, leagueIdx, matchesStart)
	if err != nil {
		return err
	}
	return nil
}
