package process

import (
	"context"
	"database/sql"
	"encoding/hex"
	"fmt"
	"math/big"
	"sort"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/freeverseio/crypto-soccer/go/contracts"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/updates"
	"github.com/freeverseio/crypto-soccer/go/names"
	"github.com/freeverseio/crypto-soccer/go/synchronizer/engine"
	"github.com/freeverseio/crypto-soccer/go/synchronizer/storage"
	"github.com/freeverseio/crypto-soccer/go/useractions"

	log "github.com/sirupsen/logrus"
)

type LeagueProcessor struct {
	contracts         *contracts.Contracts
	calendarProcessor *Calendar
	ipfsURL           string
}

func NewLeagueProcessor(
	contracts *contracts.Contracts,
	namesdb *names.Generator,
	ipfsURL string,
) (*LeagueProcessor, error) {
	calendarProcessor, err := NewCalendar(contracts)
	if err != nil {
		return nil, err
	}
	return &LeagueProcessor{
		contracts,
		calendarProcessor,
		ipfsURL,
	}, nil
}

func (b *LeagueProcessor) Process(tx *sql.Tx, event updates.UpdatesActionsSubmission) error {
	day := event.Day
	turnInDay := event.TurnInDay
	timezoneIdx := event.TimeZone

	if timezoneIdx < 1 || timezoneIdx > 24 {
		return fmt.Errorf("Unexistent timezone %v", timezoneIdx)
	}
	if turnInDay == 2 || turnInDay == 3 {
		return nil
	}

	if turnInDay < 2 {
		log.Infof("Timezone %v ... prepare to process the matches ..... ", timezoneIdx)
		countryCount, err := storage.CountryInTimezoneCount(tx, timezoneIdx)
		if err != nil {
			return err
		}
		for countryIdx := uint32(0); countryIdx < countryCount; countryIdx++ {
			// if a new league is starting shuffle the teams
			if (day == 0) && (turnInDay == 0) {
				err = b.UpdatePrevPerfPointsAndShuffleTeamsInCountry(tx, timezoneIdx, countryIdx)
				if err != nil {
					return err
				}
			}
			leagueCount, err := storage.LeagueByTeimezoneIdxCountryIdx(tx, timezoneIdx, countryIdx)
			if err != nil {
				return err
			}
			for leagueIdx := uint32(0); leagueIdx < leagueCount; leagueIdx++ {
				if day == 0 {
					if err = b.resetLeague(tx, timezoneIdx, countryIdx, leagueIdx); err != nil {
						return err
					}
					if err = storage.DeleteAllMatchEvents(tx, int(timezoneIdx), int(countryIdx), int(leagueIdx)); err != nil {
						return err
					}
				}

			}
		}
	}
	if err := b.applyTactics(tx, event); err != nil {
		return err
	}

	log.Infof("Timezone %v loading matches from storage", timezoneIdx)
	matches, err := engine.NewMatchesFromTimezoneIdxMatchdayIdx(tx, timezoneIdx, day)
	if err != nil {
		return err
	}
	switch turnInDay {
	case 0:
		log.Infof("Timezone %v processing 1st half of %v matches", timezoneIdx, len(*matches))
		if err = matches.Play1stHalfParallel(context.TODO(), *b.contracts); err != nil {
			return err
		}
	case 1:
		log.Infof("Timezone %v processing 2nd half of %v matches", timezoneIdx, len(*matches))
		if err = matches.Play2ndHalfParallel(context.TODO(), *b.contracts); err != nil {
			return err
		}
	default:
		return fmt.Errorf("Unknown turn in day %v", turnInDay)
	}
	log.Infof("Timezone %v save matches to storage", timezoneIdx)
	if err = matches.ToStorage(*b.contracts, tx); err != nil {
		return err
	}
	return nil
}

func (b LeagueProcessor) applyTactics(tx *sql.Tx, event updates.UpdatesActionsSubmission) error {
	log.Infof("Retriving user actions %v from ipfs node %v", event.Cid, b.ipfsURL)
	userActions, err := useractions.NewFromIpfs(b.ipfsURL, event.Cid)
	if err != nil {
		return err
	}
	root, err := userActions.Root()
	if err != nil {
		return err
	}
	if root != event.Root {
		return fmt.Errorf("UserActions Root mismatch bc: %v ipfs: %v", hex.EncodeToString(event.Root[:]), hex.EncodeToString(root[:]))
	}
	log.Info("Applying tactics ...")
	for _, tactic := range userActions.Tactics {
		substitutions := [3]uint8{11, 11, 11}
		substitutionsMinute := [3]uint8{2, 3, 4}
		formation := [14]uint8{
			uint8(tactic.Shirt0),
			uint8(tactic.Shirt1),
			uint8(tactic.Shirt2),
			uint8(tactic.Shirt3),
			uint8(tactic.Shirt4),
			uint8(tactic.Shirt5),
			uint8(tactic.Shirt6),
			uint8(tactic.Shirt7),
			uint8(tactic.Shirt8),
			uint8(tactic.Shirt9),
			uint8(tactic.Shirt10),
			uint8(tactic.Shirt11),
			uint8(tactic.Shirt12),
			uint8(tactic.Shirt13),
		}
		extraAttack := [10]bool{
			tactic.ExtraAttack1,
			tactic.ExtraAttack2,
			tactic.ExtraAttack3,
			tactic.ExtraAttack4,
			tactic.ExtraAttack5,
			tactic.ExtraAttack6,
			tactic.ExtraAttack7,
			tactic.ExtraAttack8,
			tactic.ExtraAttack9,
			tactic.ExtraAttack10,
		}
		tacticID := uint8(tactic.TacticID)
		encodedTactic, err := b.contracts.Engine.EncodeTactics(
			&bind.CallOpts{},
			substitutions,
			substitutionsMinute,
			formation,
			extraAttack,
			tacticID,
		)
		if err != nil {
			log.Errorf("%v: %+v", err.Error(), tactic)
			continue
		}
		if err = storage.TeamSetTactic(tx, tactic.TeamID, encodedTactic.String()); err != nil {
			return err
		}
	}
	return nil
}

func (b *LeagueProcessor) UpdatePrevPerfPointsAndShuffleTeamsInCountry(tx *sql.Tx, timezoneIdx uint8, countryIdx uint32) error {
	log.Infof("[LeagueProcessor] Shuffling timezone %v, country %v", timezoneIdx, countryIdx)
	var orgMap []storage.Team
	leagueCount, err := storage.LeagueByTeimezoneIdxCountryIdx(tx, timezoneIdx, countryIdx)
	if err != nil {
		return err
	}
	for leagueIdx := uint32(0); leagueIdx < leagueCount; leagueIdx++ {
		teams, err := storage.TeamsByTimezoneIdxCountryIdxLeagueIdx(tx, timezoneIdx, countryIdx, leagueIdx)
		if err != nil {
			return err
		}
		// ordening by points
		sort.Slice(teams[:], func(i, j int) bool {
			return teams[i].Points > teams[j].Points
		})
		for position, team := range teams {
			teamState, err := b.GetTeamState(tx, team.TeamID)
			if err != nil {
				return err
			}
			if !storage.IsBotTeam(team) {
				log.Debugf("[LeagueProcessor] Compute team ranking points team %v, teamState %v", team, teamState)
				teamID, _ := new(big.Int).SetString(team.TeamID, 10)
				team.RankingPoints, team.PrevPerfPoints, err = b.contracts.Leagues.ComputeTeamRankingPoints(
					&bind.CallOpts{},
					teamState,
					uint8(position),
					team.PrevPerfPoints,
					teamID,
				)
				if err != nil {
					return err
				}
			}
			log.Debugf("New ranking team %v points %v ranking %v", team.TeamID, team.Points, team.RankingPoints)
			orgMap = append(orgMap, team)
		}
	}
	// ordening all the teams by ranking points
	sort.Slice(orgMap[:], func(i, j int) bool {
		return orgMap[i].RankingPoints > orgMap[j].RankingPoints
	})
	// create the new leagues
	for i, team := range orgMap {
		team.LeagueIdx = uint32(i / 8)
		team.TeamIdxInLeague = uint32(i % 8)
		err = team.Update(tx)
		if err != nil {
			return err
		}
	}
	return nil
}

func (b *LeagueProcessor) GetTeamState(tx *sql.Tx, teamID string) ([25]*big.Int, error) {
	var state [25]*big.Int
	for i := 0; i < 25; i++ {
		state[i] = big.NewInt(0)
	}
	players, err := storage.PlayersByTeamId(tx, teamID)
	if err != nil {
		return state, err
	}
	for i := 0; i < len(players); i++ {
		player := players[i]
		playerSkills := player.EncodedSkills
		shirtNumber := player.ShirtNumber
		state[shirtNumber] = playerSkills
	}
	return state, nil
}

func (b *LeagueProcessor) resetLeague(tx *sql.Tx, timezoneIdx uint8, countryIdx uint32, leagueIdx uint32) error {
	teams, err := storage.TeamsByTimezoneIdxCountryIdxLeagueIdx(tx, timezoneIdx, countryIdx, leagueIdx)
	if err != nil {
		return err
	}
	for i := 0; i < len(teams); i++ {
		team := teams[i]
		team.D = 0
		team.W = 0
		team.L = 0
		team.GoalsAgainst = 0
		team.GoalsForward = 0
		team.Points = 0
		err = team.Update(tx)
		if err != nil {
			return err
		}
	}
	err = b.calendarProcessor.Reset(tx, timezoneIdx, countryIdx, leagueIdx)
	if err != nil {
		return err
	}
	err = b.calendarProcessor.Populate(tx, timezoneIdx, countryIdx, leagueIdx)
	if err != nil {
		return err
	}
	return nil
}
