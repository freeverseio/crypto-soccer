package process

import (
	"database/sql"
	"errors"
	"fmt"
	"math/big"

	"github.com/freeverseio/crypto-soccer/go/names"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/freeverseio/crypto-soccer/go/contracts"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/assets"
	"github.com/freeverseio/crypto-soccer/go/storage"
	log "github.com/sirupsen/logrus"
)

const SK_SHO = uint8(0)
const SK_SPE = uint8(1)
const SK_PAS = uint8(2)
const SK_DEF = uint8(3)
const SK_END = uint8(4)
const LEAGUES_PER_DIV = uint8(16)
const TEAMS_PER_LEAGUE = uint8(8)
const PLAYERS_PER_TEAM_INIT = uint8(18)

type DivisionCreationProcessor struct {
	contracts         *contracts.Contracts
	calendarProcessor *Calendar
	namesGenerator    *names.Generator
}

func NewDivisionCreationProcessor(
	contracts *contracts.Contracts,
	namesdb *names.Generator,
) *DivisionCreationProcessor {
	calendarProcessor := NewCalendar(contracts)
	return &DivisionCreationProcessor{
		contracts,
		calendarProcessor,
		namesdb,
	}
}

func (b *DivisionCreationProcessor) Process(tx *sql.Tx, event assets.AssetsDivisionCreation) error {
	log.Infof("[processor|consume] LeaguesDivisionCreation tx %v, country %v, division %v", event.Timezone, event.CountryIdxInTZ, event.DivisionIdxInCountry)

	if event.CountryIdxInTZ.Uint64() == 0 && event.DivisionIdxInCountry.Uint64() == 0 {
		timezone := storage.Timezone{event.Timezone}
		if err := timezone.Insert(tx); err != nil {
			return err
		}
	}
	if event.DivisionIdxInCountry.Uint64() == 0 {
		countryIdx := event.CountryIdxInTZ.Uint64()
		if countryIdx > 65535 {
			return errors.New("Cannot cast country idx to uint16: value too large")
		}
		country := storage.Country{event.Timezone, uint32(countryIdx)}
		if err := country.Insert(tx); err != nil {
			return err
		}
	}
	if err := b.storeTeamsForNewDivision(tx, event.Raw.BlockNumber, event.Timezone, event.CountryIdxInTZ, event.DivisionIdxInCountry); err != nil {
		return err
	}
	return nil
}
func (b *DivisionCreationProcessor) storeTeamsForNewDivision(tx *sql.Tx, blockNumber uint64, timezone uint8, countryIdx *big.Int, divisionIdxInCountry *big.Int) error {
	opts := &bind.CallOpts{}

	leagueIdxBegin := divisionIdxInCountry.Int64() * int64(LEAGUES_PER_DIV)
	leagueIdxEnd := leagueIdxBegin + int64(LEAGUES_PER_DIV)

	for leagueIdx := leagueIdxBegin; leagueIdx < leagueIdxEnd; leagueIdx++ {
		league := storage.League{timezone, uint32(countryIdx.Uint64()), uint32(leagueIdx)}
		if err := league.Insert(tx); err != nil {
			return err
		}
		teamIdxBegin := leagueIdx * int64(TEAMS_PER_LEAGUE)
		teamIdxEnd := teamIdxBegin + int64(TEAMS_PER_LEAGUE)
		for teamIdxInLeague, teamIdx := uint32(0), teamIdxBegin; teamIdx < teamIdxEnd; teamIdx, teamIdxInLeague = teamIdx+1, teamIdxInLeague+1 {
			if teamId, err := b.contracts.Assets.EncodeTZCountryAndVal(opts, timezone, countryIdx, big.NewInt(teamIdx)); err != nil {
				return err
			} else {
				teamName, errname := b.namesGenerator.GenerateTeamName(teamId, timezone, countryIdx.Uint64())
				if errname != nil {
					return errname
				}
				team := storage.NewTeam()
				team.TeamID = teamId.String()
				team.TimezoneIdx = timezone
				team.CountryIdx = uint32(countryIdx.Uint64())
				team.Name = teamName
				team.Owner = storage.BotOwner
				team.LeagueIdx = uint32(leagueIdx)
				team.TeamIdxInLeague = teamIdxInLeague
				team.RankingPoints = 10
				if err := team.Insert(tx); err != nil {
					return err
				}
				if err := b.storeVirtualPlayersForTeam(tx, opts, blockNumber, teamId, timezone, countryIdx, teamIdx); err != nil {
					return err
				}
				if err := b.createInitialTactics(tx, timezone, teamId); err != nil {
					return err
				}
				training := storage.NewTraining()
				training.TeamID = teamId.String()
				if err := training.Insert(tx); err != nil {
					return err
				}
				teamHistory := storage.NewTeamHistory(blockNumber, *team)
				if err := teamHistory.Insert(tx); err != nil {
					return err
				}
			}
		}
		if err := b.calendarProcessor.Generate(tx, timezone, uint32(countryIdx.Uint64()), uint32(leagueIdx)); err != nil {
			return err
		}
		if err := b.calendarProcessor.Populate(tx, timezone, uint32(countryIdx.Uint64()), uint32(leagueIdx)); err != nil {
			return err
		}
	}
	return nil
}

func (b *DivisionCreationProcessor) storeVirtualPlayersForTeam(tx *sql.Tx, opts *bind.CallOpts, blockNumber uint64, teamId *big.Int, timezone uint8, countryIdx *big.Int, teamIdxInCountry int64) error {
	begin := teamIdxInCountry * int64(PLAYERS_PER_TEAM_INIT)
	end := begin + int64(PLAYERS_PER_TEAM_INIT)

	generation := uint8(0)
	for i := begin; i < end; i++ {
		playerId, err := b.contracts.Assets.EncodeTZCountryAndVal(opts, timezone, countryIdx, big.NewInt(i))
		if err != nil {
			log.Warning(err)
		}
		encodedSkills, err := b.contracts.Assets.GetPlayerSkillsAtBirth(opts, playerId)
		if err != nil {
			log.Warning(err)
		}
		encodedState, err := b.contracts.Market.GetPlayerStateAtBirth(opts, playerId)
		if err != nil {
			log.Warning(err)
		}
		decodedSkills, err := b.contracts.Utils.FullDecodeSkills(opts, encodedSkills)
		if err != nil {
			return err
		}
		preferredPosition, err := GetPlayerPreferredPosition(b.contracts, encodedSkills)
		if err != nil {
			log.Warning(err)
		}
		shirtNumber, err := b.contracts.Assets.GetCurrentShirtNum(opts, encodedState)
		if err != nil {
			log.Warning(err)
		}
		name, countryOfBirth, race, err := b.namesGenerator.GeneratePlayerFullName(playerId, generation, timezone, countryIdx.Uint64())
		if err != nil {
			return fmt.Errorf("%s playerId: %v, generation: %v, timezone: %v, countryIdx %v", err.Error(), playerId, generation, timezone, countryIdx.Uint64())
		}
		player := storage.Player{
			PlayerId:          playerId,
			PreferredPosition: preferredPosition,
			Potential:         uint64(decodedSkills.BirthTraits[0]),
			DayOfBirth:        uint64(decodedSkills.DayOfBirth),
			TeamId:            teamId.String(),
			Name:              name,
			Defence:           uint64(decodedSkills.Skills[3]),
			Speed:             uint64(decodedSkills.Skills[1]),
			Pass:              uint64(decodedSkills.Skills[2]),
			Shoot:             uint64(decodedSkills.Skills[0]),
			Endurance:         uint64(decodedSkills.Skills[4]),
			ShirtNumber:       uint8(shirtNumber.Uint64()),
			EncodedSkills:     encodedSkills,
			EncodedState:      encodedState,
			Tiredness:         int(decodedSkills.GenerationGamesNonStopInjuryWeeks[1]),
			CountryOfBirth:    countryOfBirth,
			Race:              race,
		}
		if err := player.Insert(tx, blockNumber); err != nil {
			return err
		}
	}
	return nil
}

func (b *DivisionCreationProcessor) createInitialTactics(tx *sql.Tx, timezone uint8, teamID *big.Int) error {
	tacticId := 1
	tactic := &storage.Tactic{
		teamID.String(),
		tacticId,
		0,
		3,
		4,
		5,
		6,
		7,
		8,
		9,
		10,
		11,
		12,
		25,
		storage.NoSubstitution,
		0,
		25,
		storage.NoSubstitution,
		0,
		25,
		storage.NoSubstitution,
		0,
		false,
		false,
		false,
		false,
		false,
		false,
		false,
		false,
		false,
		false,
	}
	return tactic.Insert(tx)
}
