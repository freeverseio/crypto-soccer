package process_test

import (
	"math/big"
	"testing"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/core/types"

	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/assets"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/updates"
	"github.com/freeverseio/crypto-soccer/go/names"
	"github.com/freeverseio/crypto-soccer/go/synchronizer/process"
)

func TestProcessInvalidTimezone(t *testing.T) {
	t.Parallel()
	tx, err := universedb.Begin()
	if err != nil {
		t.Fatal(err)
	}
	defer tx.Rollback()

	namesdb, err := names.New("../../names/sql/names.db")
	if err != nil {
		t.Fatal(err)
	}
	processor, err := process.NewLeagueProcessor(
		bc.Contracts,
		namesdb,
	)
	if err != nil {
		t.Fatal(err)
	}
	var event updates.UpdatesActionsSubmission
	event.TimeZone = 25
	err = processor.Process(tx, event)
	if err != nil {
		t.Fatal(err)
	}
}

// func TestMatchesToStorage(t *testing.T) {
// 	tx, err := s.Begin()
// 	if err != nil {
// 		t.Fatal(err)
// 	}
// 	defer tx.Rollback()
// 	createMatches(t, tx)
// 	timezoneIdx := uint8(1)
// 	day := uint8(0)
// 	matches, err := engine.FromStorage(tx, timezoneIdx, day)
// 	assert.NilError(t, err)

// }

func TestLeagueProcessMatch(t *testing.T) {
	t.Parallel()
	tx, err := universedb.Begin()
	if err != nil {
		t.Fatal(err)
	}
	defer tx.Rollback()
	relaytx, err := relaydb.Begin()
	if err != nil {
		t.Fatal(err)
	}
	defer relaytx.Rollback()

	if err != nil {
		t.Fatal(err)
	}
	timezoneIdx := uint8(1)
	err = bc.InitOneTimezone(timezoneIdx)
	if err != nil {
		t.Fatal(err)
	}
	namesdb, err := names.New("../../names/sql/names.db")
	if err != nil {
		t.Fatal(err)
	}
	divisionCreationProcessor, err := process.NewDivisionCreationProcessor(
		bc.Contracts,
		namesdb,
	)
	if err != nil {
		t.Fatal(err)
	}
	countryIdx := big.NewInt(0)
	divisionIdx := big.NewInt(0)
	err = divisionCreationProcessor.Process(tx, relaytx, assets.AssetsDivisionCreation{timezoneIdx, countryIdx, divisionIdx, types.Log{}})
	if err != nil {
		t.Fatal(err)
	}

	processor, err := process.NewLeagueProcessor(
		bc.Contracts,
		namesdb,
	)
	if err != nil {
		t.Fatal(err)
	}
	day := uint8(0)
	turnInDay := uint8(0)
	seed := [32]byte{}
	gameDeployDay, err := bc.Contracts.Assets.GameDeployDay(&bind.CallOpts{})
	if err != nil {
		t.Fatal(err)
	}
	actionsSubmissionTime := gameDeployDay.Int64() * 24 * 3600
	err = processor.Process(tx, updates.UpdatesActionsSubmission{
		big.NewInt(0),
		timezoneIdx,
		day,
		turnInDay,
		seed,
		big.NewInt(actionsSubmissionTime),
		"cid",
		types.Log{},
	})
	if err != nil {
		t.Fatal(err)
	}
	turnInDay = 1
	err = processor.Process(tx, updates.UpdatesActionsSubmission{
		big.NewInt(1),
		timezoneIdx,
		day,
		turnInDay,
		seed,
		big.NewInt(actionsSubmissionTime),
		"cid",
		types.Log{},
	})
	if err != nil {
		t.Fatal(err)
	}
}

// func TestLeagueShuffling(t *testing.T) {
// 	tx, err := universedb.Begin()
// 	if err != nil {
// 		t.Fatal(err)
// 	}
// 	defer tx.Rollback()
// 	relaytx, err := relaydb.Begin()
// 	if err != nil {
// 		t.Fatal(err)
// 	}
// 	defer relaytx.Rollback()

// 	bc, err := testutils.NewBlockchainNodeDeployAndInit()
// 	if err != nil {
// 		t.Fatal(err)
// 	}
// 	namesdb, err := names.New("../../names/sql/names.db")
// 	if err != nil {
// 		t.Fatal(err)
// 	}
// 	timezoneIdx := uint8(1)
// 	countryIdx := big.NewInt(0)
// 	leagueIdx := uint32(0)
// 	proc, err := process.NewEventProcessor(bc.Contracts, namesdb)
// 	if err != nil {
// 		t.Fatal(err)
// 	}
// 	if _, err = proc.Process(tx, relaytx, 0); err != nil {
// 		t.Fatal(err)
// 	}
// 	// teamId := big.NewInt(274877906944)

// 	tx0, err := bc.Contracts.Assets.TransferFirstBotToAddr(
// 		bind.NewKeyedTransactor(bc.Owner),
// 		timezoneIdx,
// 		countryIdx,
// 		common.HexToAddress("0x8724aC60ac290837a1fe2d441279413d5B058E5F"),
// 	)
// 	_, err = helper.WaitReceipt(bc.Client, tx0, 10)
// 	if err != nil {
// 		t.Fatal(err)
// 	}
// 	if _, err = proc.Process(tx, relaytx, 0); err != nil {
// 		t.Fatal(err)
// 	}
// 	processor, err := process.NewLeagueProcessor(
// 		bc.Contracts,
// 		namesdb,
// 	)
// 	if err != nil {
// 		t.Fatal(err)
// 	}

// 	err = processor.UpdatePrevPerfPointsAndShuffleTeamsInCountry(tx, timezoneIdx, uint32(countryIdx.Uint64()))
// 	if err != nil {
// 		t.Fatal(err)
// 	}
// 	teams, err := storage.TeamsByTimezoneIdxCountryIdxLeagueIdx(tx, timezoneIdx, uint32(countryIdx.Uint64()), leagueIdx)
// 	if err != nil {
// 		t.Fatal(err)
// 	}
// 	for _, team := range teams {
// 		t.Logf("Check team %v", team)
// 		if team.Owner == "0x0000000000000000000000000000000000000000" {
// 			// BOT team
// 			if team.RankingPoints != 0 {
// 				t.Fatalf("bot team %v has ranking points %v", team.TeamID, team.RankingPoints)
// 			}
// 			if team.PrevPerfPoints != 0 {
// 				t.Fatalf("bot team %v has prev perf points points %v", team.TeamID, team.PrevPerfPoints)
// 			}
// 		} else {
// 			if team.RankingPoints == 0 {
// 				t.Fatal("Owned team has ranking point 0")
// 			}
// 			if team.TeamIdxInLeague != 0 {
// 				t.Fatalf("Only owned team is not in position in league 0 but %v", team.TeamIdxInLeague)
// 			}
// 		}

// 		// log.Infof("team %v, league %v, ranking points %v, idx in league %v, perf points points %v", team.TeamID, team.LeagueIdx, team.RankingPoints, team.TeamIdxInLeague, team.PrevPerfPoints)
// 	}
// }
