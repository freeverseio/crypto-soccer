package process_test

import (
	"math/big"
	"testing"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/core/types"
	"gotest.tools/assert"

	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/assets"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/updates"
	"github.com/freeverseio/crypto-soccer/go/storage"
	"github.com/freeverseio/crypto-soccer/go/synchronizer/process"
	"github.com/freeverseio/crypto-soccer/go/useractions"
)

func TestProcessInvalidTimezone(t *testing.T) {
	t.Parallel()
	tx, err := universedb.Begin()
	if err != nil {
		t.Fatal(err)
	}
	defer tx.Rollback()

	processor := process.NewLeagueProcessor(
		bc.Contracts,
		useractionsPublishService,
	)
	var event updates.UpdatesActionsSubmission
	event.TimeZone = 25
	err = processor.Process(tx, event)
	assert.Error(t, err, "Unexistent timezone 25")
}

// func TestMatchesToStorage(t *testing.T) {
// 	tx, err := s.Begin()
// 	if err != nil {
// 		t.Fatal(err)
// 	}
// 	defer tx.Rollback()
// 	createMatches(t, tx)
// 	timezoneIdx := uint8(1)
// 	day := uint8(0)
// 	matches, err := engine.FromStorage(tx, timezoneIdx, day)
// 	assert.NilError(t, err)

// }

func TestLeagueProcessMatch(t *testing.T) {
	t.Parallel()
	tx, err := universedb.Begin()
	if err != nil {
		t.Fatal(err)
	}
	defer tx.Rollback()

	timezoneIdx := uint8(1)
	countryIdx := big.NewInt(0)
	divisionIdx := big.NewInt(0)

	divisionCreationProcessor := process.NewDivisionCreationProcessor(bc.Contracts, namesdb)
	assert.NilError(t, divisionCreationProcessor.Process(tx, assets.AssetsDivisionCreation{timezoneIdx, countryIdx, divisionIdx, types.Log{}}))
	processor := process.NewLeagueProcessor(bc.Contracts, useractionsPublishService)
	day := uint8(0)
	seed := [32]byte{0x2}
	turnInDay := uint8(0)
	gameDeployDay, err := bc.Contracts.Assets.GameDeployDay(&bind.CallOpts{})
	assert.NilError(t, err)
	actionsSubmissionTime := gameDeployDay.Int64() * 24 * 3600
	ua := useractions.UserActions{}
	cid, err := useractionsPublishService.Publish(ua)
	assert.NilError(t, err)
	root, err := ua.Root()
	assert.NilError(t, err)
	err = processor.Process(tx, updates.UpdatesActionsSubmission{
		big.NewInt(0),
		timezoneIdx,
		day,
		turnInDay,
		seed,
		big.NewInt(actionsSubmissionTime),
		root,
		cid,
		types.Log{BlockNumber: 1000},
	})
	assert.NilError(t, err)
	turnInDay = 1
	err = processor.Process(tx, updates.UpdatesActionsSubmission{
		big.NewInt(1),
		timezoneIdx,
		day,
		turnInDay,
		seed,
		big.NewInt(actionsSubmissionTime),
		root,
		cid,
		types.Log{BlockNumber: 1001},
	})
	assert.NilError(t, err)
}

func TestEntireLeagueEvolution(t *testing.T) {
	t.Parallel()
	tx, err := universedb.Begin()
	if err != nil {
		t.Fatal(err)
	}
	defer tx.Rollback()

	countryIdx := big.NewInt(0)
	divisionIdx := big.NewInt(0)

	divisionCreationProcessor := process.NewDivisionCreationProcessor(bc.Contracts, namesdb)
	tzs := []uint8{1, 24}
	for _, tz := range tzs {
		assert.NilError(t, divisionCreationProcessor.Process(tx, assets.AssetsDivisionCreation{tz, countryIdx, divisionIdx, types.Log{}}))
	}
	processor := process.NewLeagueProcessor(bc.Contracts, useractionsPublishService)
	seed := [32]byte{0x2}
	gameDeployDay, err := bc.Contracts.Assets.GameDeployDay(&bind.CallOpts{})
	assert.NilError(t, err)
	actionsSubmissionTime := gameDeployDay.Int64() * 24 * 3600
	ua := useractions.UserActions{}
	cid, err := useractionsPublishService.Publish(ua)
	assert.NilError(t, err)
	root, err := ua.Root()
	assert.NilError(t, err)
	block := uint64(1000)
	verse := int64(0)

	testTimezone := uint8(1)
	testCountryIdx := uint32(0)
	testLeagueIdx := uint32(0)
	teams, err := storage.TeamsByTimezoneIdxCountryIdxLeagueIdx(tx, testTimezone, testCountryIdx, testLeagueIdx)
	teamId := teams[0].TeamID
	testTeam, err := storage.TeamByTeamId(tx, teamId)
	assert.NilError(t, err)
	assert.Equal(t, testTeam.TeamIdxInLeague, uint32(0))
	t.Log(testTeam.RankingPoints)

	for day := uint8(0); day < 16; day++ {
		actualDay := day
		if day == 14 {
			actualDay = uint8(0)
		}
		for turnInDay := uint8(0); turnInDay < 2; turnInDay++ {
			block++
			verse++
			for _, tz := range tzs {
				t.Log("day: ", day, " | actualDay", actualDay, " | turnInDay", turnInDay, " | tz", tz)
				err = processor.Process(tx, updates.UpdatesActionsSubmission{
					big.NewInt(verse),
					tz,
					actualDay,
					turnInDay,
					seed,
					big.NewInt(actionsSubmissionTime),
					root,
					cid,
					types.Log{BlockNumber: block},
				})
				assert.NilError(t, err)
				testTeam, err := storage.TeamByTeamId(tx, teamId)
				assert.NilError(t, err)
				assert.Equal(t, testTeam.TeamIdxInLeague, uint32(0))
				t.Log(testTeam.RankingPoints)
			}
		}
	}
	assert.NilError(t, err)
	testTeam, err = storage.TeamByTeamId(tx, teamId)
	assert.NilError(t, err)
	assert.Equal(t, testTeam.TeamIdxInLeague, uint32(0))
	t.Log(testTeam.RankingPoints)
}

// func TestLeagueShuffling(t *testing.T) {
// 	tx, err := universedb.Begin()
// 	if err != nil {
// 		t.Fatal(err)
// 	}
// 	defer tx.Rollback()
// 	relaytx, err := relaydb.Begin()
// 	if err != nil {
// 		t.Fatal(err)
// 	}
// 	defer relaytx.Rollback()

// 	bc, err := testutils.NewBlockchainNodeDeployAndInit()
// 	if err != nil {
// 		t.Fatal(err)
// 	}
// 	namesdb, err := names.New("../../names/sql/names.db")
// 	if err != nil {
// 		t.Fatal(err)
// 	}
// 	timezoneIdx := uint8(1)
// 	countryIdx := big.NewInt(0)
// 	leagueIdx := uint32(0)
// 	proc, err := process.NewEventProcessor(bc.Contracts, namesdb)
// 	if err != nil {
// 		t.Fatal(err)
// 	}
// 	if _, err = proc.Process(tx, relaytx, 0); err != nil {
// 		t.Fatal(err)
// 	}
// 	// teamId := big.NewInt(274877906944)

// 	tx0, err := bc.Contracts.Assets.TransferFirstBotToAddr(
// 		bind.NewKeyedTransactor(bc.Owner),
// 		timezoneIdx,
// 		countryIdx,
// 		common.HexToAddress("0x8724aC60ac290837a1fe2d441279413d5B058E5F"),
// 	)
// 	_, err = helper.WaitReceipt(bc.Client, tx0, 10)
// 	if err != nil {
// 		t.Fatal(err)
// 	}
// 	if _, err = proc.Process(tx, relaytx, 0); err != nil {
// 		t.Fatal(err)
// 	}
// 	processor, err := process.NewLeagueProcessor(
// 		bc.Contracts,
// 		namesdb,
// 	)
// 	if err != nil {
// 		t.Fatal(err)
// 	}

// 	err = processor.UpdatePrevPerfPointsAndShuffleTeamsInCountry(tx, timezoneIdx, uint32(countryIdx.Uint64()))
// 	if err != nil {
// 		t.Fatal(err)
// 	}
// 	teams, err := storage.TeamsByTimezoneIdxCountryIdxLeagueIdx(tx, timezoneIdx, uint32(countryIdx.Uint64()), leagueIdx)
// 	if err != nil {
// 		t.Fatal(err)
// 	}
// 	for _, team := range teams {
// 		t.Logf("Check team %v", team)
// 		if team.Owner == "0x0000000000000000000000000000000000000000" {
// 			// BOT team
// 			if team.RankingPoints != 0 {
// 				t.Fatalf("bot team %v has ranking points %v", team.TeamID, team.RankingPoints)
// 			}
// 			if team.PrevPerfPoints != 0 {
// 				t.Fatalf("bot team %v has prev perf points points %v", team.TeamID, team.PrevPerfPoints)
// 			}
// 		} else {
// 			if team.RankingPoints == 0 {
// 				t.Fatal("Owned team has ranking point 0")
// 			}
// 			if team.TeamIdxInLeague != 0 {
// 				t.Fatalf("Only owned team is not in position in league 0 but %v", team.TeamIdxInLeague)
// 			}
// 		}

// 		// log.Infof("team %v, league %v, ranking points %v, idx in league %v, perf points points %v", team.TeamID, team.LeagueIdx, team.RankingPoints, team.TeamIdxInLeague, team.PrevPerfPoints)
// 	}
// }
