package process_test

import (
	"math/big"
	"strconv"
	"testing"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"gotest.tools/assert"

	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/assets"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/updates"
	"github.com/freeverseio/crypto-soccer/go/storage"
	"github.com/freeverseio/crypto-soccer/go/synchronizer/process"
	"github.com/freeverseio/crypto-soccer/go/useractions"
	log "github.com/sirupsen/logrus"
)

func TestProcessInvalidTimezone(t *testing.T) {
	t.Parallel()
	tx, err := universedb.Begin()
	if err != nil {
		t.Fatal(err)
	}
	defer tx.Rollback()

	processor := process.NewLeagueProcessor(
		bc.Contracts,
		useractionsPublishService,
	)
	var event updates.UpdatesActionsSubmission
	event.TimeZone = 25
	err = processor.Process(tx, event)
	assert.Error(t, err, "Unexistent timezone 25")
}

// func TestMatchesToStorage(t *testing.T) {
// 	tx, err := s.Begin()
// 	if err != nil {
// 		t.Fatal(err)
// 	}
// 	defer tx.Rollback()
// 	createMatches(t, tx)
// 	timezoneIdx := uint8(1)
// 	day := uint8(0)
// 	matches, err := engine.FromStorage(tx, timezoneIdx, day)
// 	assert.NilError(t, err)

// }

func TestLeagueProcessMatch(t *testing.T) {
	t.Parallel()
	tx, err := universedb.Begin()
	if err != nil {
		t.Fatal(err)
	}
	defer tx.Rollback()

	timezoneIdx := uint8(1)
	countryIdx := big.NewInt(0)
	divisionIdx := big.NewInt(0)
	assetInitProcessor := process.NewAssetsInitProcessor(bc.Contracts)
	assert.NilError(t, assetInitProcessor.Process(tx, assets.AssetsAssetsInit{common.HexToAddress("0x0"), types.Log{}}))
	divisionCreationProcessor := process.NewDivisionCreationProcessor(bc.Contracts, namesdb)
	assert.NilError(t, divisionCreationProcessor.Process(tx, assets.AssetsDivisionCreation{timezoneIdx, countryIdx, divisionIdx, types.Log{}}))
	processor := process.NewLeagueProcessor(bc.Contracts, useractionsPublishService)
	day := uint8(0)
	seed := [32]byte{0x2}
	turnInDay := uint8(0)
	gameDeployDay, err := bc.Contracts.Assets.GameDeployDay(&bind.CallOpts{})
	assert.NilError(t, err)
	actionsSubmissionTime := gameDeployDay.Int64() * 24 * 3600
	ua := useractions.UserActions{}
	cid, err := useractionsPublishService.Publish(ua)
	assert.NilError(t, err)
	root, err := ua.Root()
	assert.NilError(t, err)
	err = processor.Process(tx, updates.UpdatesActionsSubmission{
		big.NewInt(0),
		timezoneIdx,
		day,
		turnInDay,
		seed,
		big.NewInt(actionsSubmissionTime),
		root,
		cid,
		types.Log{BlockNumber: 1000},
	})
	assert.NilError(t, err)
	turnInDay = 1
	err = processor.Process(tx, updates.UpdatesActionsSubmission{
		big.NewInt(1),
		timezoneIdx,
		day,
		turnInDay,
		seed,
		big.NewInt(actionsSubmissionTime),
		root,
		cid,
		types.Log{BlockNumber: 1001},
	})
	assert.NilError(t, err)
}

//Only run when universe db is loaded with data in tz 10
func TestLeagueProcessMatchWithData(t *testing.T) {
	t.Parallel()
	tx, err := universedb.Begin()
	if err != nil {
		t.Fatal(err)
	}
	defer tx.Rollback()
	log.SetLevel(log.TraceLevel)
	timezoneIdx := uint8(10)
	processor := process.NewLeagueProcessor(bc.Contracts, useractionsPublishService)
	day := uint8(0)
	seed := [32]byte{0x2}
	turnInDay := uint8(0)
	gameDeployDay, err := bc.Contracts.Assets.GameDeployDay(&bind.CallOpts{})
	assert.NilError(t, err)
	actionsSubmissionTime := gameDeployDay.Int64() * 24 * 3600
	ua := useractions.UserActions{}
	cid, err := useractionsPublishService.Publish(ua)
	assert.NilError(t, err)
	root, err := ua.Root()
	assert.NilError(t, err)
	err = processor.Process(tx, updates.UpdatesActionsSubmission{
		big.NewInt(12913),
		timezoneIdx,
		day,
		turnInDay,
		seed,
		big.NewInt(actionsSubmissionTime),
		root,
		cid,
		types.Log{BlockNumber: 1000},
	})
	assert.NilError(t, err)
	// turnInDay = 1
	// err = processor.Process(tx, updates.UpdatesActionsSubmission{
	// 	big.NewInt(12914),
	// 	timezoneIdx,
	// 	day,
	// 	turnInDay,
	// 	seed,
	// 	big.NewInt(actionsSubmissionTime),
	// 	root,
	// 	cid,
	// 	types.Log{BlockNumber: 1001},
	// })
	// assert.NilError(t, err)
	// log.Infof("Just before commit")
	// tx.Commit()
	// log.Infof("Just after commit")
}

func TestGenerateOrgMapWithoutBots(t *testing.T) {
	var teamStatesPerLeague []process.TeamsWithStateInLeague

	// crete 4 leagues in this country
	// for each league, teamIdxInLeauge = 3 will be a zombie
	idxInCountry := int64(0)
	nLeagues := 4
	state := createTeamStateWithFixedSumSkills(344)
	for leagueIdx := 0; leagueIdx < 4; leagueIdx++ {
		teamWithStates := process.TeamsWithStateInLeague{}
		for i := 0; i < 8; i++ {
			teamWithStates.TeamsWithState[i] = process.TeamWithState{
				Team:      createMinimalTeam(idxInCountry),
				TeamState: state,
			}
			idxInCountry += 1
		}
		teamWithStates.TeamsWithState[3].Team.IsZombie = true
		teamStatesPerLeague = append(teamStatesPerLeague, teamWithStates)
	}

	processor := process.NewLeagueProcessor(bc.Contracts, useractionsPublishService)

	orgMap, err := processor.GenerateOrgMap(teamStatesPerLeague)
	assert.NilError(t, err)
	nTeams := nLeagues * 8
	prevRankingPoints := uint64(18446744073709551615) // = 2**64-1
	// check: ranking points must be decreasing (except for the first zombie team)
	// check: the only 4 teams that were zombies are at the end
	for i, team := range orgMap.Teams {
		if i < nTeams-4 {
			assert.Equal(t, team.IsZombie, false)
		} else {
			assert.Equal(t, team.IsZombie, true)
		}
		if i != nTeams-4 {
			assert.Equal(t, prevRankingPoints >= team.RankingPoints, true)
		}
		prevRankingPoints = team.RankingPoints
		// Since all teams had the same sumSkills, they only got different Ranking Points because of their leaderboardPos
		if i < 4*nLeagues {
			assert.Equal(t, team.LeaderboardPosition, i/4)
		} else if i < 7*nLeagues {
			assert.Equal(t, team.LeaderboardPosition, 1+i/4)
		} else {
			assert.Equal(t, team.LeaderboardPosition, 4)
		}
	}

}

func TestGenerateOrgMapWithBots(t *testing.T) {
	var teamStatesPerLeague []process.TeamsWithStateInLeague

	// crete 4 leagues in this country
	// for each league, teamIdxInLeauge = 3 will be a zombie
	// for each league, teamIdxInLeauge = 5 will be a bot
	idxInCountry := int64(0)
	nLeagues := 4
	state := createTeamStateWithFixedSumSkills(344)
	for leagueIdx := 0; leagueIdx < 4; leagueIdx++ {
		teamWithStates := process.TeamsWithStateInLeague{}
		for i := 0; i < 8; i++ {
			teamWithStates.TeamsWithState[i] = process.TeamWithState{
				Team:      createMinimalTeam(idxInCountry),
				TeamState: state,
			}
			idxInCountry += 1
		}
		teamWithStates.TeamsWithState[3].Team.IsZombie = true
		teamWithStates.TeamsWithState[5].Team.Owner = storage.BotOwner
		teamStatesPerLeague = append(teamStatesPerLeague, teamWithStates)
	}

	processor := process.NewLeagueProcessor(bc.Contracts, useractionsPublishService)

	orgMap, err := processor.GenerateOrgMap(teamStatesPerLeague)
	assert.NilError(t, err)
	nTeams := nLeagues * 8
	prevRankingPoints := uint64(18446744073709551615) // = 2**64-1
	// check: first humans, then 4 bots, then 4 zombies
	for i, team := range orgMap.Teams {
		if i < nTeams-8 {
			assert.Equal(t, team.IsZombie, false)
			assert.Equal(t, team.IsBot(), false)
		} else if i < nTeams-4 {
			assert.Equal(t, team.IsZombie, false)
			assert.Equal(t, team.IsBot(), true)
			assert.Equal(t, team.RankingPoints, uint64(0))
		} else {
			assert.Equal(t, team.IsZombie, true)
			assert.Equal(t, team.IsBot(), false)
		}
		if i != nTeams-4 {
			assert.Equal(t, prevRankingPoints >= team.RankingPoints, true)
		}
		prevRankingPoints = team.RankingPoints
		// Since all teams had the same sumSkills, they only got different Ranking Points because of their leaderboardPos
		if i < 4*nLeagues {
			assert.Equal(t, team.LeaderboardPosition, i/4)
		} else if i < 5*nLeagues {
			assert.Equal(t, team.LeaderboardPosition, 1+i/4)
		} else if i < 6*nLeagues {
			assert.Equal(t, team.LeaderboardPosition, 2+i/4)
		} else if i < 7*nLeagues {
			assert.Equal(t, team.LeaderboardPosition, 6)
		} else {
			assert.Equal(t, team.LeaderboardPosition, 4)
		}
	}

	// check: within bots, they are sorted by increasing teamID
	prevBotTeamID := orgMap.Teams[24].TeamID
	for _, team := range orgMap.Teams[25:28] {
		assert.Equal(t, team.TeamID > prevBotTeamID, true)
		prevBotTeamID = team.TeamID
	}

}

// Enable this huge test, with go test -timeout 99999s to check that the ranking changes on day=13 for tz = 24
// func TestEntireLeagueEvolution(t *testing.T) {
// 	t.Parallel()
// 	tx, err := universedb.Begin()
// 	if err != nil {
// 		t.Fatal(err)
// 	}
// 	defer tx.Rollback()

// 	countryIdx := big.NewInt(0)
// 	divisionIdx := big.NewInt(0)

// 	divisionCreationProcessor := process.NewDivisionCreationProcessor(bc.Contracts, namesdb)
// 	tzs := []uint8{1, 24}
// 	for _, tz := range tzs {
// 		assert.NilError(t, divisionCreationProcessor.Process(tx, assets.AssetsDivisionCreation{tz, countryIdx, divisionIdx, types.Log{}}))
// 	}
// 	processor := process.NewLeagueProcessor(bc.Contracts, useractionsPublishService)
// 	seed := [32]byte{0x2}
// 	gameDeployDay, err := bc.Contracts.Assets.GameDeployDay(&bind.CallOpts{})
// 	assert.NilError(t, err)
// 	actionsSubmissionTime := gameDeployDay.Int64() * 24 * 3600
// 	ua := useractions.UserActions{}
// 	cid, err := useractionsPublishService.Publish(ua)
// 	assert.NilError(t, err)
// 	root, err := ua.Root()
// 	assert.NilError(t, err)
// 	block := uint64(1000)
// 	verse := int64(0)

// 	testTimezone := uint8(1)
// 	testCountryIdx := uint32(0)
// 	testLeagueIdx := uint32(0)

// 	var teamIds []string

// 	teams, err := storage.TeamsByTimezoneIdxCountryIdxLeagueIdx(tx, testTimezone, testCountryIdx, testLeagueIdx)
// 	assert.NilError(t, err)
// 	for idx := 0; idx < 8; idx++ {
// 		_, err := bc.Contracts.Assets.TransferFirstBotToAddr(
// 			bind.NewKeyedTransactor(bc.Owner),
// 			testTimezone,
// 			big.NewInt(0),
// 			common.HexToAddress("0x8724aC60ac290837a1fe2d441279413d5B058E5F"),
// 		)
// 		assert.NilError(t, err)
// 		teamIds = append(teamIds, teams[idx].TeamID)
// 		// t.Log(idx, "-", teams[idx].TeamID)
// 	}
// 	for idx, teamId := range teamIds {
// 		testTeam, err := storage.TeamByTeamId(tx, teamId)
// 		assert.NilError(t, err)
// 		testTeam.Owner = "0x433"
// 		assert.NilError(t, testTeam.Update(tx))
// 		// t.Log(testTeam.RankingPoints, testTeam.TeamIdxInLeague)
// 		assert.Equal(t, testTeam.TeamIdxInLeague, uint32(idx))
// 	}

// 	for day := uint8(0); day < 16; day++ {
// 		actualDay := day
// 		if day == 14 {
// 			actualDay = uint8(0)
// 		}
// 		for turnInDay := uint8(0); turnInDay < 2; turnInDay++ {
// 			block++
// 			verse++
// 			for _, tz := range tzs {
// 				t.Log("day: ", day, " | actualDay", actualDay, " | turnInDay", turnInDay, " | tz", tz)
// 				err = processor.Process(tx, updates.UpdatesActionsSubmission{
// 					big.NewInt(verse),
// 					tz,
// 					actualDay,
// 					turnInDay,
// 					seed,
// 					big.NewInt(actionsSubmissionTime),
// 					root,
// 					cid,
// 					types.Log{BlockNumber: block},
// 				})
// 				assert.NilError(t, err)
// 				for idx, teamId := range teamIds {
// 					testTeam, err := storage.TeamByTeamId(tx, teamId)
// 					assert.NilError(t, err)
// 					// t.Log(testTeam.RankingPoints, testTeam.TeamIdxInLeague)
// 					// t.Log(idx, "-", teams[idx].TeamID)
// 					assert.Equal(t, testTeam.TeamIdxInLeague, uint32(idx))
// 				}

// 			}
// 		}
// 	}
// 	assert.NilError(t, err)
// 	for idx, teamId := range teamIds {
// 		testTeam, err := storage.TeamByTeamId(tx, teamId)
// 		assert.NilError(t, err)
// 		t.Log(testTeam.RankingPoints)
// 		assert.Equal(t, testTeam.TeamIdxInLeague, uint32(idx))
// 	}

// }

// func TestLeagueShuffling(t *testing.T) {
// 	tx, err := universedb.Begin()
// 	if err != nil {
// 		t.Fatal(err)
// 	}
// 	defer tx.Rollback()
// 	timezoneIdx := uint8(1)
// 	countryIdx := big.NewInt(0)
// 	leagueIdx := uint32(0)
// 	proc := process.NewEventProcessor(bc.Client,
// 		bc.Contracts.ProxyAddress,
// 		namesdb,
// 		useractionsPublishService,
// 		nil)
// 	if err != nil {
// 		t.Fatal(err)
// 	}
// 	if _, err = proc.Process(tx, 0); err != nil {
// 		t.Fatal(err)
// 	}
// 	// teamId := big.NewInt(274877906944)

// 	tx0, err := bc.Contracts.Assets.TransferFirstBotToAddr(
// 		bind.NewKeyedTransactor(bc.Owner),
// 		timezoneIdx,
// 		countryIdx,
// 		common.HexToAddress("0x8724aC60ac290837a1fe2d441279413d5B058E5F"),
// 	)
// 	_, err = helper.WaitReceipt(bc.Client, tx0, 10)
// 	if err != nil {
// 		t.Fatal(err)
// 	}
// 	if _, err = proc.Process(tx, 0); err != nil {
// 		t.Fatal(err)
// 	}
// 	processor := process.NewLeagueProcessor(
// 		bc.Contracts,
// 		useractionsPublishService,
// 	)
// 	if err != nil {
// 		t.Fatal(err)
// 	}
// 	err = processor.UpdatePrevPerfPointsAndShuffleTeamsInCountry(tx, timezoneIdx, uint32(countryIdx.Uint64()))
// 	if err != nil {
// 		t.Fatal(err)
// 	}
// 	teams, err := storage.TeamsByTimezoneIdxCountryIdxLeagueIdx(tx, timezoneIdx, uint32(countryIdx.Uint64()), leagueIdx)
// 	if err != nil {
// 		t.Fatal(err)
// 	}
// 	for _, team := range teams {
// 		t.Logf("Check team %v", team)
// 		if team.Owner == "0x0000000000000000000000000000000000000000" {
// 			// BOT team
// 			if team.RankingPoints != 0 {
// 				t.Fatalf("bot team %v has ranking points %v", team.TeamID, team.RankingPoints)
// 			}
// 			if team.PrevPerfPoints != 0 {
// 				t.Fatalf("bot team %v has prev perf points points %v", team.TeamID, team.PrevPerfPoints)
// 			}
// 		} else {
// 			if team.RankingPoints == 0 {
// 				t.Fatal("Owned team has ranking point 0")
// 			}
// 			if team.TeamIdxInLeague != 0 {
// 				t.Fatalf("Only owned team is not in position in league 0 but %v", team.TeamIdxInLeague)
// 			}
// 		}

// 		// log.Infof("team %v, league %v, ranking points %v, idx in league %v, perf points points %v", team.TeamID, team.LeagueIdx, team.RankingPoints, team.TeamIdxInLeague, team.PrevPerfPoints)
// 	}
// }

func createTeamStateWithFixedSumSkills(desiredSum uint32) [25]*big.Int {
	var state [25]*big.Int
	for i := 0; i < 25; i++ {
		state[i] = big.NewInt(0)
	}
	state[0], _ = bc.Contracts.PlayAndEvolve.SetSumOfSkills(&bind.CallOpts{}, state[0], desiredSum)
	return state
}

func createMinimalTeam(idxInCountry int64) storage.Team {
	teamId := strconv.FormatInt(2748779069711+idxInCountry, 10)
	leagueIdx := uint32(idxInCountry / 8)
	leaderboardPos := (idxInCountry + 1) % 8  // offet a bit, to test. So idx = 0 is second in his league, and winner is idx=7.
	teamIdxInLeague := (idxInCountry + 2) % 8 // offet a bit, to test. So idx = 0 is 3rd in his league, and winner is idx=6.

	return storage.Team{
		TeamID:              teamId,
		TimezoneIdx:         10,
		CountryIdx:          0,
		Owner:               "0xaa", // just to prove that it is not a bot (!= 0x0)
		LeagueIdx:           leagueIdx,
		LeaderboardPosition: int(leaderboardPos),
		TeamIdxInLeague:     uint32(teamIdxInLeague),
		PrevPerfPoints:      22,
		IsZombie:            false,
	}
}
