package process_test

import (
	"math/big"
	"testing"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/core/types"

	"github.com/ethereum/go-ethereum/common"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/assets"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/updates"
	"github.com/freeverseio/crypto-soccer/go/helper"
	"github.com/freeverseio/crypto-soccer/go/names"
	"github.com/freeverseio/crypto-soccer/go/synchronizer/process"
	"github.com/freeverseio/crypto-soccer/go/synchronizer/storage"
	"github.com/freeverseio/crypto-soccer/go/testutils"
)

func TestProcessInvalidTimezone(t *testing.T) {
	tx, err := universedb.Begin()
	if err != nil {
		t.Fatal(err)
	}
	defer tx.Rollback()

	namesdb, err := names.New("../../names/sql/names.db")
	if err != nil {
		t.Fatal(err)
	}
	bc, err := testutils.NewBlockchainNode()
	if err != nil {
		t.Fatal(err)
	}
	bc.DeployContracts(bc.Owner)
	processor, err := process.NewLeagueProcessor(
		bc.Contracts,
		namesdb,
	)
	if err != nil {
		t.Fatal(err)
	}
	var event updates.UpdatesActionsSubmission
	event.TimeZone = 25
	err = processor.Process(tx, event)
	if err == nil {
		t.Fatal(err)
	}
}

func TestPlayHalfMatch(t *testing.T) {
	bc, err := testutils.NewBlockchainNode()
	if err != nil {
		t.Fatal(err)
	}
	err = bc.DeployContracts(bc.Owner)
	if err != nil {
		t.Fatal(err)
	}
	seed, _ := new(big.Int).SetString("79914733518162338039108289434138268582051932490617416751079415725906677907530", 10)
	matchStartTime := big.NewInt(1570147200)
	matchLog := [2]*big.Int{big.NewInt(0), big.NewInt(0)}
	matchBools := [3]bool{false, false, false}
	var states [2][25]*big.Int
	for i := 0; i < 2; i++ {
		for j := 0; j < 25; j++ {
			states[i][j], _ = new(big.Int).SetString("713624055286353394965726120199142814938406092850", 10)
		}
	}
	var tactics [2]*big.Int
	tactics[0], _ = new(big.Int).SetString("117587469164573768163156115324928", 10)
	tactics[1], _ = new(big.Int).SetString("117587469164573768163156115324928", 10)
	logs, err := bc.Contracts.Engine.PlayHalfMatch(
		&bind.CallOpts{},
		seed,
		matchStartTime,
		states,
		tactics,
		matchLog,
		matchBools,
	)
	if err != nil {
		t.Fatal(err)
	}
	if logs[0].String() != "1645504557572631091828279073381766814124583466071029250581856256" {
		t.Fatalf("Received %v", logs[0].String())
	}
}

func TestLeagueProcessMatch(t *testing.T) {
	tx, err := universedb.Begin()
	if err != nil {
		t.Fatal(err)
	}
	defer tx.Rollback()

	if err != nil {
		t.Fatal(err)
	}
	bc, err := testutils.NewBlockchainNode()
	if err != nil {
		t.Fatal(err)
	}
	err = bc.DeployContracts(bc.Owner)
	if err != nil {
		t.Fatal(err)
	}
	timezoneIdx := uint8(1)
	err = bc.InitOneTimezone(timezoneIdx)
	if err != nil {
		t.Fatal(err)
	}
	namesdb, err := names.New("../../names/sql/names.db")
	if err != nil {
		t.Fatal(err)
	}
	divisionCreationProcessor, err := process.NewDivisionCreationProcessor(
		bc.Contracts,
		namesdb,
	)
	if err != nil {
		t.Fatal(err)
	}
	countryIdx := big.NewInt(0)
	divisionIdx := big.NewInt(0)
	err = divisionCreationProcessor.Process(tx, assets.AssetsDivisionCreation{timezoneIdx, countryIdx, divisionIdx, types.Log{}})
	if err != nil {
		t.Fatal(err)
	}

	processor, err := process.NewLeagueProcessor(
		bc.Contracts,
		namesdb,
	)
	if err != nil {
		t.Fatal(err)
	}
	day := uint8(0)
	turnInDay := uint8(0)
	seed := [32]byte{}
	gameDeployDay, err := bc.Contracts.Assets.GameDeployDay(&bind.CallOpts{})
	if err != nil {
		t.Fatal(err)
	}
	actionsSubmissionTime := gameDeployDay.Int64() * 24 * 3600
	err = processor.Process(tx, updates.UpdatesActionsSubmission{
		big.NewInt(0),
		timezoneIdx,
		day,
		turnInDay,
		seed,
		big.NewInt(actionsSubmissionTime),
		"cid",
		types.Log{},
	})
	if err != nil {
		t.Fatal(err)
	}
	turnInDay = 1
	err = processor.Process(tx, updates.UpdatesActionsSubmission{
		big.NewInt(1),
		timezoneIdx,
		day,
		turnInDay,
		seed,
		big.NewInt(actionsSubmissionTime),
		"cid",
		types.Log{},
	})
	if err != nil {
		t.Fatal(err)
	}
}

func TestLeagueShuffling(t *testing.T) {
	tx, err := universedb.Begin()
	if err != nil {
		t.Fatal(err)
	}
	defer tx.Rollback()

	bc, err := testutils.NewBlockchainNodeDeployAndInit()
	if err != nil {
		t.Fatal(err)
	}
	namesdb, err := names.New("../../names/sql/names.db")
	if err != nil {
		t.Fatal(err)
	}
	timezoneIdx := uint8(1)
	countryIdx := big.NewInt(0)
	leagueIdx := uint32(0)
	proc, err := process.NewEventProcessor(bc.Contracts, namesdb)
	if err != nil {
		t.Fatal(err)
	}
	if _, err = proc.Process(tx, 0); err != nil {
		t.Fatal(err)
	}
	// teamId := big.NewInt(274877906944)

	tx0, err := bc.Contracts.Assets.TransferFirstBotToAddr(
		bind.NewKeyedTransactor(bc.Owner),
		timezoneIdx,
		countryIdx,
		common.HexToAddress("0x8724aC60ac290837a1fe2d441279413d5B058E5F"),
	)
	_, err = helper.WaitReceipt(bc.Client, tx0, 10)
	if err != nil {
		t.Fatal(err)
	}
	if _, err = proc.Process(tx, 0); err != nil {
		t.Fatal(err)
	}
	processor, err := process.NewLeagueProcessor(
		bc.Contracts,
		namesdb,
	)
	if err != nil {
		t.Fatal(err)
	}

	err = processor.UpdatePrevPerfPointsAndShuffleTeamsInCountry(tx, timezoneIdx, uint32(countryIdx.Uint64()))
	if err != nil {
		t.Fatal(err)
	}
	teams, err := storage.TeamsByTimezoneIdxCountryIdxLeagueIdx(tx, timezoneIdx, uint32(countryIdx.Uint64()), leagueIdx)
	if err != nil {
		t.Fatal(err)
	}
	t.Logf("teams in League : %v", teams)
	if teams[0].State.RankingPoints == 0 {
		t.Fatal("Owned team has ranking point 0")
	}
	for _, team := range teams[1:] {
		if team.State.RankingPoints != 0 {
			t.Fatalf("bot team %v has ranking points %v", team.TeamID, team.State.RankingPoints)
		}
		if team.State.PrevPerfPoints != 0 {
			t.Fatalf("bot team %v has prev perf points points %v", team.TeamID, team.State.PrevPerfPoints)
		}
		// log.Infof("team %v, league %v, ranking points %v, idx in league %v, perf points points %v", team.TeamID, team.State.LeagueIdx, team.State.RankingPoints, team.State.TeamIdxInLeague, team.State.PrevPerfPoints)
	}
}
