package process

import (
	"database/sql"
	"math/big"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/freeverseio/crypto-soccer/go/contracts"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/assets"
	"github.com/freeverseio/crypto-soccer/go/synchronizer/storage"
	log "github.com/sirupsen/logrus"
)

type AssetsInitProcessor struct {
	contracts   *contracts.Contracts
	ACADEMYTEAM *big.Int
}

func NewAssetsInitProcessor(
	contracts *contracts.Contracts,
) (*AssetsInitProcessor, error) {
	ACADEMYTEAM, err := contracts.Assets.ACADEMYTEAM(&bind.CallOpts{})
	if err != nil {
		return nil, err
	}
	return &AssetsInitProcessor{
		contracts,
		ACADEMYTEAM,
	}, nil
}

func (b *AssetsInitProcessor) Process(tx *sql.Tx, event assets.AssetsAssetsInit) error {
	log.Infof("AssetsInit: creatorAddr: %v", event.CreatorAddr)
	timezone := storage.Timezone{uint8(0)}
	country := storage.Country{timezone.TimezoneIdx, uint32(0)}
	league := storage.League{timezone.TimezoneIdx, country.CountryIdx, uint32(0)}
	if err := timezone.TimezoneCreate(tx); err != nil {
		return err
	}
	if err := country.CountryCreate(tx); err != nil {
		return err
	}
	if err := league.LeagueCreate(tx); err != nil {
		return err
	}
	teamIdxInLeague := uint32(0)
	team := storage.Team{
		b.ACADEMYTEAM,
		timezone.TimezoneIdx,
		country.CountryIdx,
		storage.TeamState{
			"Academy",
			event.CreatorAddr.String(),
			league.LeagueIdx,
			teamIdxInLeague,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
		},
	}

	if err := team.TeamCreate(tx); err != nil {
		return err
	}
	return nil
}
