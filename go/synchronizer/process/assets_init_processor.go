package process

import (
	"math/big"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/freeverseio/crypto-soccer/go/contracts"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/assets"
	"github.com/freeverseio/crypto-soccer/go/synchronizer/storage"
	log "github.com/sirupsen/logrus"
)

type AssetsInitProcessor struct {
	contracts   *contracts.Contracts
	universedb  *storage.Storage
	ACADEMYTEAM *big.Int
}

func NewAssetsInitProcessor(
	contracts *contracts.Contracts,
	universedb *storage.Storage,
) (*AssetsInitProcessor, error) {
	ACADEMYTEAM, err := contracts.Assets.ACADEMYTEAM(&bind.CallOpts{})
	if err != nil {
		return nil, err
	}
	return &AssetsInitProcessor{
		contracts,
		universedb,
		ACADEMYTEAM,
	}, nil
}

func (b *AssetsInitProcessor) Process(event assets.AssetsAssetsInit) error {
	log.Infof("AssetsInit: creatorAddr: %v", event.CreatorAddr)
	timezone := uint8(0)
	countryIdx := uint32(0)
	leagueIdx := uint32(0)
	teamIdxInLeague := uint32(0)
	if err := b.universedb.TimezoneCreate(storage.Timezone{timezone}); err != nil {
		return err
	}
	if err := b.universedb.CountryCreate(storage.Country{timezone, countryIdx}); err != nil {
		return err
	}
	if err := b.universedb.LeagueCreate(storage.League{timezone, countryIdx, leagueIdx}); err != nil {
		return err
	}

	if err := b.universedb.TeamCreate(
		storage.Team{
			b.ACADEMYTEAM,
			timezone,
			countryIdx,
			storage.TeamState{
				"Academy",
				event.CreatorAddr.String(),
				leagueIdx,
				teamIdxInLeague,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
			},
		},
	); err != nil {
		return err
	}
	return nil
}
