package process

import (
	"database/sql"
	"encoding/hex"
	"math/big"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/freeverseio/crypto-soccer/go/contracts"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/assets"
	"github.com/freeverseio/crypto-soccer/go/storage"
	log "github.com/sirupsen/logrus"
)

type AssetsInitProcessor struct {
	contracts   *contracts.Contracts
	ACADEMYTEAM *big.Int
}

func NewAssetsInitProcessor(
	contracts *contracts.Contracts,
) (*AssetsInitProcessor, error) {
	ACADEMYTEAM, err := contracts.ConstantsGetters.GetACADEMYTEAM(&bind.CallOpts{})
	if err != nil {
		return nil, err
	}
	return &AssetsInitProcessor{
		contracts,
		ACADEMYTEAM,
	}, nil
}

func (b *AssetsInitProcessor) Process(tx *sql.Tx, event assets.AssetsAssetsInit) error {
	log.Infof("AssetsInit: creatorAddr: %v", event.CreatorAddr)
	timezone := storage.Timezone{uint8(0)}
	country := storage.Country{timezone.TimezoneIdx, uint32(0)}
	league := storage.League{timezone.TimezoneIdx, country.CountryIdx, uint32(0)}
	log.Infof("Creating timezone %v country %v league %v", timezone.TimezoneIdx, country.CountryIdx, league.LeagueIdx)
	if err := timezone.Insert(tx); err != nil {
		return err
	}
	if err := country.Insert(tx); err != nil {
		return err
	}
	if err := league.Insert(tx); err != nil {
		return err
	}
	team := storage.NewTeam()
	team.TeamID = b.ACADEMYTEAM.String()
	team.TimezoneIdx = timezone.TimezoneIdx
	team.CountryIdx = country.CountryIdx
	team.Name = "Academy"
	team.Owner = event.CreatorAddr.String()
	team.LeagueIdx = league.LeagueIdx
	team.TeamIdxInLeague = uint32(0)
	log.Infof("Creating Academy with owner 0x%v", hex.EncodeToString(event.CreatorAddr[:]))
	if err := team.Insert(tx); err != nil {
		return err
	}
	return nil
}
