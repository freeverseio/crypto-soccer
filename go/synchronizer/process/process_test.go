package process_test

import (
	"math/big"
	"testing"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/updates"
	"github.com/freeverseio/crypto-soccer/go/helper"
	"github.com/freeverseio/crypto-soccer/go/storage"
	"github.com/freeverseio/crypto-soccer/go/synchronizer/process"
	"github.com/freeverseio/crypto-soccer/go/useractions"
	"gotest.tools/assert"
)

func TestProcessorDispatchUpdatesTimezoneUpdate(t *testing.T) {
	t.Parallel()
	tx, err := universedb.Begin()
	assert.NilError(t, err)
	defer tx.Rollback()

	event := updates.UpdatesTimeZoneUpdate{}
	abstractEvent := process.NewAbstractEvent(0, 0, "", event)

	p, err := process.NewEventProcessor(
		bc.Contracts,
		namesdb,
		ipfsURL,
		nil,
	)
	assert.NilError(t, err)
	assert.NilError(t, p.Dispatch(tx, abstractEvent))
}

func TestSyncTeams(t *testing.T) {
	t.Parallel()
	tx, err := universedb.Begin()
	assert.NilError(t, err)
	defer tx.Rollback()
	p, err := process.NewEventProcessor(
		bc.Contracts,
		namesdb,
		ipfsURL,
		nil,
	)
	assert.NilError(t, err)
	_, err = p.Process(tx, 0)
	assert.NilError(t, err)

	// the null timezone (0) is only used by the Academy Team
	if count, err := storage.TimezoneCount(tx); err != nil {
		t.Fatal(err)
	} else if count != 2 {
		t.Fatalf("Expected 2 time zones at time of creation,  actual %v", count)
	}

	// one country belongs to timezone = 0
	if count, err := storage.CountryCount(tx); err != nil {
		t.Fatal(err)
	} else if count != 2 {
		t.Fatalf("Expected 2 countries at time of creation,  actual %v", count)
	}

	// one team (the Academy) belongs to timezone = 0
	count, err := storage.TeamCount(tx)
	assert.NilError(t, err)
	assert.Equal(t, count, uint64(128+2))
	if count, err := storage.PlayerCount(tx); err != nil {
		t.Fatal(err)
		t.Fatalf("Expected 128*18=2304 actual %v", count)
	} else if count != 128*18 {
	}

	timezoneIdx := uint8(1)
	countryIdx := big.NewInt(0)

	tx0, err := bc.Contracts.Assets.TransferFirstBotToAddr(
		bind.NewKeyedTransactor(bc.Owner),
		timezoneIdx,
		countryIdx,
		crypto.PubkeyToAddress(bc.Owner.PublicKey),
	)
	if err != nil {
		t.Fatal(err)
	}

	_, err = helper.WaitReceipt(bc.Client, tx0, 3)
	if err != nil {
		t.Fatal(err)
	}
	ua := useractions.UserActions{}
	cid, err := ua.ToIpfs(ipfsURL)
	assert.NilError(t, err)
	seed, err := ua.Hash()
	assert.NilError(t, err)
	var txs []*types.Transaction

	t.Skip("TODO reactive the following")

	for i := 0; i < 24*4; i++ {
		tx, err := bc.Contracts.Updates.SubmitActionsRoot(
			bind.NewKeyedTransactor(bc.Owner),
			seed,
			seed,
			seed,
			3,
			cid,
		)
		if err != nil {
			t.Fatal(err)
		}
		txs = append(txs, tx)
	}
	err = helper.WaitReceipts(bc.Client, txs, 3)
	if err != nil {
		t.Fatal(err)
	}
	_, err = p.Process(tx, 0)
	if err != nil {
		t.Fatal(err)
	}

	playerIdx := big.NewInt(30)
	playerID, err := bc.Contracts.Assets.EncodeTZCountryAndVal(&bind.CallOpts{}, timezoneIdx, countryIdx, playerIdx)
	if err != nil {
		t.Fatal(err)
	}
	owner, err := bc.Contracts.Market.GetOwnerPlayer(&bind.CallOpts{}, playerID)
	if err != nil {
		t.Fatal(err)
	}
	if owner.String() != storage.BotOwner {
		t.Fatalf("Owner is wrong %v", owner.String())
	}

	tx0, err = bc.Contracts.Assets.TransferFirstBotToAddr(
		bind.NewKeyedTransactor(bc.Owner),
		timezoneIdx,
		countryIdx,
		crypto.PubkeyToAddress(bc.Owner.PublicKey),
	)
	if err != nil {
		t.Fatal(err)
	}
	_, err = helper.WaitReceipt(bc.Client, tx0, 3)
	if err != nil {
		t.Fatal(err)
	}

	_, err = p.Process(tx, 0)
	if err != nil {
		t.Fatal(err)
	}

	owner, err = bc.Contracts.Market.GetOwnerPlayer(&bind.CallOpts{}, playerID)
	if err != nil {
		t.Fatal(err)
	}
	if owner != crypto.PubkeyToAddress(bc.Owner.PublicKey) {
		t.Fatalf("Owner is wrong %v", owner.String())
	}

	matchCount, err := storage.MatchesByTimezoneIdxCountryIdxLeagueIdx(tx, 1, 0, 0)
	if err != nil {
		t.Fatal(err)
	}
	if len(matchCount) != 56 {
		t.Fatalf("Wrong number of matches %v", len(matchCount))
	}

	matchEventsCount, err := storage.MatchEventCountByTimezoneCountryLeague(tx, 1, 0, 0)
	if err != nil {
		t.Fatal(err)
	}
	if matchEventsCount > 54*34 {
		t.Fatalf("Wrong numnber of match events > 54*34 %v", matchEventsCount)
	}
}
