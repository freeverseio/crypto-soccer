package process_test

import (
	"math/big"
	"testing"

	"github.com/ethereum/go-ethereum/crypto"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/freeverseio/crypto-soccer/go/contracts/autogenerated/assets"
	"github.com/freeverseio/crypto-soccer/go/helper"
	"github.com/freeverseio/crypto-soccer/go/synchronizer/process"
	"github.com/freeverseio/crypto-soccer/go/testutils"
)

func TestScanningIniting(t *testing.T) {
	bc, err := testutils.NewBlockchainNode()
	if err != nil {
		t.Fatal(err)
	}
	err = bc.DeployContracts(bc.Owner)
	if err != nil {
		t.Fatal(err)
	}
	err = bc.Init()
	if err != nil {
		t.Fatal(err)
	}

	scanner := process.NewEventScanner(bc.Contracts)
	err = scanner.Process(nil)
	if err != nil {
		t.Fatal(err)
	}
	nTZsAtStart := int(24)
	nDivsPerTZAtStart := int(1)
	nEventsExpected := nTZsAtStart*nDivsPerTZAtStart + 1
	events := scanner.Events
	if len(events) != nEventsExpected {
		t.Fatalf("Expected %v received %v", nEventsExpected, len(events))
	}
	// the first nTZsAtStart should be timezone creations
	// the last event is AssetsInit.
	for tz := 0; tz < nTZsAtStart; tz++ {
		switch event := events[tz].Value.(type) {
		case assets.AssetsDivisionCreation:
			// t.Log(event.Timezone)
			expected := uint8(tz/nDivsPerTZAtStart + 1)
			if event.Timezone != expected {
				t.Fatalf("Expected %v recived %v for event number %v", expected, event.Timezone, tz)
			}
			break
		default:
			t.Fatalf("Wrong type %v", event)
		}
	}
	switch event := events[nTZsAtStart*nDivsPerTZAtStart].Value.(type) {
	case assets.AssetsAssetsInit:
		break
	default:
		t.Fatalf("Wrong type %v", event)
	}
}

func TestScanningTeamTransfer(t *testing.T) {
	bc, err := testutils.NewBlockchainNode()
	if err != nil {
		t.Fatal(err)
	}
	bc.DeployContracts(bc.Owner)
	bc.Init()

	eventCount := 0

	if scanner := process.NewEventScanner(bc.Contracts); scanner != nil {
		err = scanner.Process(nil)
		if err != nil {
			t.Fatal(err)
		}
		eventCount += len(scanner.Events)
		if eventCount == 0 {
			// skipping check for exact number at creation
			t.Fatalf("Expected some events received %v", eventCount)
		}
	} else {
		t.Fatal("Unable to create scanner")
	}

	timezoneIdx := uint8(1)
	countryIdx := big.NewInt(0)
	address := crypto.PubkeyToAddress(bc.Owner.PublicKey)
	tx, err := bc.Contracts.Assets.TransferFirstBotToAddr(bind.NewKeyedTransactor(bc.Owner), timezoneIdx, countryIdx, address)
	if err != nil {
		t.Fatal(err)
	}
	timezoneIdx = uint8(2)
	tx1, err := bc.Contracts.Assets.TransferFirstBotToAddr(bind.NewKeyedTransactor(bc.Owner), timezoneIdx, countryIdx, address)
	if err != nil {
		t.Fatal(err)
	}
	helper.WaitReceipt(bc.Client, tx, 3)
	helper.WaitReceipt(bc.Client, tx1, 3)

	if scanner := process.NewEventScanner(bc.Contracts); scanner != nil {
		err = scanner.Process(nil)
		if err != nil {
			t.Fatal(err)
		}
		if len(scanner.Events) != eventCount+2 {
			t.Fatalf("Expected 2 received %v", len(scanner.Events)-eventCount)
		}
	} else {
		t.Fatal("Unable to create scanner")
	}
}
